{"version":3,"sources":["model/OpenInterval.ts","model/ChromosomeInterval.ts","model/GenomicBin.ts","util.ts","model/DataWarehouse.ts","components/Scatterplot.tsx","components/DivWithBullseye.tsx","components/SampleViz2D.tsx","components/LinearPlot.tsx","components/RdrBafLinearPlots.tsx","components/SampleViz1D.tsx","components/ClusterTable.tsx","components/SampleViz.tsx","loading-small.gif","components/LogTable.tsx","model/Genome.ts","components/CSVLink.tsx","components/ToggleButton.tsx","components/Sidebar.tsx","components/BarPlot.tsx","App.tsx","index.tsx"],"names":["OpenInterval","start","end","RangeError","this","other","Math","max","min","Symbol","iterator","ChromosomeInterval","chr","_interval","getLength","hasOverlap","multiple","floor","ceil","str","regexMatch","match","Number","parseInt","GenomicBinHelpers","toChromosomeInterval","bin","START","END","flattenNestedBins","arr","result","i","length","value","Array","isArray","push","getRelativeCoordinates","event","relativeTo","currentTarget","targetBoundingRect","getBoundingClientRect","x","clientX","left","y","clientY","top","niceBpCount","bases","sigFigs","sub","basesAmnt","rounded","toFixed","calculateEuclideanDist","pointOne","pointTwo","sqrt","Error","currentDiff","webglColor","color","col","d3","rgb","r","g","b","opacity","calculateInterClusterDist2","p","other_cluster","dists","_","mean","calculateIntraClusterDist2","cluster","dist","calculateSilhoutteScores","rawData","clusteredData","labels","possible_clusters","keys","clusterToSilhoutte","Map","downSamplePercent","bin1","c","binsInCluster","get","downSampledBinsInCluster","downSample","a","minB","Infinity","c2","otherCluster","downSampledOtherCluster","maxAB","s","has","previousSilhouttes","set","avg_cluster_silhouttes","val","undefined","avg","sortBy","data","percent","downSampledData","Set","original_len","new_len","size","random","add","isJsons","array","every","row","jsons2arrays","jsons","headers","headerLabels","from","map","json","Object","reduce","headerKeys","header","label","key","object","getHeaderValue","property","obj","foundValue","replace","split","o","splice","elementOrEmpty","element","joiner","separator","filter","e","column","join","toCSV","enclosingCharacter","jsons2csv","arrays2csv","string2csv","TypeError","reformatBins","samples","applyLog","allRecords","Promise","resolve","reject","multiDimData","clusterToData","rdKey","CLUSTER","j","currentBin","reverseBAF","original","DataWarehouse","_rdRanges","_logRdRanges","_locationGroupedData","brushedBins","brushedCrossfilter","brushedClusterDim","_ndx","_sample_dim","_cluster_dim","_chr_dim","_genomic_pos_dim","_samples","_clusters","_chrs","_sampleGroupedData","clusterTableInfo","_cluster_filters","historyStack","_clusterAmounts","logOfActions","centroids","centroidPts","chrToClusters","centroidDistances","shouldCalculateSilhouttes","currentSilhouttes","initializeLocationGroupedData","crossfilter","dimension","d","String","groupedBySample","groupBy","entries","sample","binsForSample","groupedByCluster","union","values","binsForCluster","groupedByChr","clus","sampleDict","centroid","calculateCentroid","centroidPt","point","tempMap","centroidStr","centroidTableRow","SAMPLE","genomicPosition","allFiltered","cloneDeep","group","all","currentSampleBins","currentRdRange","minBy","RD","maxBy","currentLogRdRange","logRD","initializeCentroidDistMatrix","calculateClusterTableInfo","filterRecordsByScales","memoizeOne","shouldRecalculate","contents","console","error","sampleSpecificCentroids","getCentroidPoints","cluster1","cluster2","points","yAxis","meanBy","setOfClustersInChr","samplePts","clustersAssociatedWithChr","valueOf","clusterInfo","clusterTable","binLocation","toString","getSampleList","log","rdRange","clusters","indexOf","filterAll","chrs","ALL_CHRS_KEY","ALL_CLUSTERS_KEY","genomeRange","JSON","parse","stringify","brushedTableData","action","currentBAFRange","unshift","locKey","allMergedBins","remove","test","includes","setClusterFilters","newRecords","pop","setShouldRecalculateSilhouttes","sampleAmount","clusterIdToAmount","forEach","amountInSelection","clusterTable2","selectPerc","implicitStart","implicitEnd","xScale","yScale","records","dataKey","record","index","PADDING","UNCLUSTERED_COLOR","DELETED_COLOR","UNCLUSTERED_ID","DELETED_ID","SCALES_CLASS_NAME","CIRCLE_GROUP_CLASS_NAME","nextCircleIdPrefix","Scatterplot","props","_svg","_circleIdPrefix","brushedNodes","previous_brushed_nodes","quadTree","_canvas","_canvas2","_currXScale","_currYScale","_original_XScale","_original_YScale","_original_transform","_current_transform","scatter","zoom","onTrigger","selectedCluster","parentCallBack","onBrushedBinsUpdated","computeScales","handleMouseMove","bind","initializeListOfClusters","state","onZoom","resetZoom","width","height","bafScale","rdrScale","yAxisToPlot","addAll","translate","scale","clusterTableData","sort","shift","hoveredRdBaf","rd","invert","baf","domain","radius","abs","onRecordsHovered","find","className","style","position","pointerEvents","hoveredLocation","hoveredRecords","currLoc","range","range2","recordLocation","renderTooltipAtRdBaf","Fragment","clusterOptions","clusterName","ref","node","zIndex","onMouseMove","id","onClick","renderTooltip","newScales","redraw","forceHover","prevProps","some","scales","forceUnhover","propsDidChange","isEqual","currentYDomain","newYDomain","log2","pow","bafRange","useLowerBound","bafScaleRange","rdrScaleRange","rdLowerBound","self","customColor","colors","displayMode","yLabel","svg","selectAll","append","classed","attr","text","xAx","call","yAx","previous","gx","gy","z","zoomX","scaleExtent","zoomY","tx","ty","on","t","transform","k","sourceEvent","layerX","layerY","center","doX","doY","DisplayMode","translateBy","scaleBy","gl","getContext","gl2","clearColor","newData","fillColor","fc","col_index","chooseColor","pointSeries","crossValue","mainValue","context","decorate","program","depthFunc","NEVER","disable","DEPTH_TEST","select","erase","brush","keyModifiers","extent","updatePoints","boxzoom","selection","newRdRange","newBafRange","brush_endEvent","clear","COLOR_BUFFER_BIT","xr","rescaleX","yr","rescaleY","showCentroids","enter","type","chooseColor2","brushNodes","rect","uniq","difference","genomeLocation","getElementsForGenomeLocation","React","Component","defaultProps","onNewCurveState","noop","onRecordHovered","DivWithBullseye","mouseCoordinates","storeMouseCoordinates","clearMouseCoordinates","setState","onMouseLeave","children","otherProps","mergedStyle","assign","Bullseye","where","horizontalLineStyle","willChange","verticalLineStyle","SampleViz2D","handleCallBack","childData","selectedSample","initialSelectedSample","handleSelectedSampleChanged","handleRecordsHovered","handleUpdatedBrushedBins","onRemovePlot","target","onSelectedSample","location","onLocationHovered","plotId","invertAxis","assignCluster","updatedBins","dispMode","onClusterSelected","LinearPlot","previewDriver","lockedDrivers","getXScale","handleMouseLeave","genome","yMin","yMax","collator","Intl","Collator","numeric","sensitivity","compare","driverGeneUpdate","gene","destination","dataKeyToPlot","delete","handleDriverGenesChange","onLinearPlotZoom","getChrStartMap","driverGenes","chromosomes","getChromosomeList","chrStarts","name","getName","tickValues","getChromosomeStarts2","tickFormat","unused","findChrNumber","xAx2","baseNum","ticks","getImplicitCoordinates","getCenter","mouseover","mouseleave","brushed","startEnd","dest","implicitCoords","boxWidth","backgroundColor","border","mouseX","implicitLocation","getChromosomeLocation","renderLockedDrivers","shouldAddBack","drivers","driver","driverSymbol","symbol","bottom","PureComponent","RDLinearPlot","BAFLinearPlot","SampleViz1D","sentDriver","sentGene","visualization","implicitRange","ClusterTable","table_data","handleColorChange","nextProps","hex","tempColors","onClusterColorChange","forceUpdate","updatedClusterTable","colOneName","colTwoName","colThreeName","expandable","selectable","ExpandedComponent","onChangeComplete","conditionalRowStyles","when","alignItems","justifyContent","innerWidth","outerWidth","columns","selector","sortable","compact","wrap","right","columns3","centroidTable","colNames","centroidColumns","centroidCol","pagination","dense","paginationPerPage","paginationComponentOptions","rowsPerPageText","selectAllRowsItem","paginationRowsPerPageOptions","noContextMenu","noHeader","selectableRows","onSelectedRowsChange","onClusterRowsChange","selectableRowSelected","currentFilters","expandableRows","expandableRowsComponent","expandableRowDisabled","noDataComponent","padding","SampleViz","handleSelectedSampleChange","handleZoom","handleLinearPlotZoom","newScale","selected","syncScales","genomicRange","yscale","reset","showLinearPlot","showScatterPlot","showSidebar","getRdRange","sampleOptions","sampleName","selectedRecords","getRecords","disableSelectOptions","getBrushedBins","verticalAlign","onChange","onAddSample","disabled","title","nextAvailable","onUndoClick","cols","LogTable","colName","Genome","_name","_chromosomes","_chrStarts","_length","nameToChr","chromosome","chrName","chrStart","implicit","sortedChrStarts","sortedLastIndex","chrCoordinate","filteredChrs","convertToTsv","headings","slice","CSV","csvLink","createRef","loading","handleFileDownload","csvContent","hiddenElement","document","createElement","href","encodeURIComponent","fileName","nameExt","newFileName","removeDateTime","currentDate","Date","month","getMonth","day","getDate","date","getFullYear","hrs","getHours","getMinutes","sec","getSeconds","time","download","click","actions","logData","logFileContent","hiddenElement2","src","spinner","alt","ToggleButton","setDisplayMode","Sidebar","show","onToggleDirections","onSidebarChange","currentDisplayMode","chosenFile","onFileChosen","onDriverFileChosen","htmlFor","selectedChr","onChrSelected","chrOptions","onToggleLog","onToggleScatter","checked","showScatter","readOnly","onToggleLinear","showLinear","onToggleShowCentroids","showSilhouttes","ProcessingStatus","none","done","onToggleSilhouttes","tableData","currentClusterFilters","margins","margin","BarPlot","marginRatio","bandwidth","tickSize","tickPadding","getFileContentsAsString","file","reader","FileReader","readAsText","onload","onerror","onabort","CLUSTER_COLORS","parseGenomicBins","applyClustering","cast","delimiter","skip_empty_lines","parsed","lastChr","chrNameLength","BAF","localeCompare","parseDriverGenes","skip_lines_with_error","components","start_end","interval","App","processingStatus","indexedData","showComponents","assigned","inputError","sidebar","showDirections","showLog","showCentroidTable","silhouttes","handleFileChoosen","handleDriverFileChosen","handleChrSelected","handleClusterSelected","handleLocationHovered","throttle","handleAxisInvert","handleAddSampleClick","handleAssignCluster","handleClusterAssignmentInput","updateBrushedBins","handleRemovePlot","onSideBarChange","toggleLog","onToggleSync","goBackToPreviousCluster","onToggleSilhoutteBarPlot","keyCode","files","readingFile","processing","setChrFilter","updateCluster","setbrushedBins","newShowComponents","concat","selectedRows","newColors","mode","undoClusterUpdate","recalculateSilhouttes","then","allData","getAllRecords","mainUI","getClusterTableInfo","getActions","isEmpty","scatterplotProps","getAllChromosomes","getAllClusters","times","status","getStatusCaption","onAssignCluster","getFilteredClusters","getCentroidData","ReactDOM","render","getElementById"],"mappings":"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AAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,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","file":"static/js/main.dea9b59a.chunk.js","sourcesContent":["/**\n * A 0-indexed open interval; e.g. [0, 3).  Intervals are iterable, so code can take advantage of the spread operator:\n * `myFunction(...interval)` is equivalent to `myFunction(interval.start, interval.end)`\n * \n * @author Silas Hsu\n */\nexport class OpenInterval {\n    /**\n     * Makes a new instance.  The input should represent a 0-indexed open interval.\n     * \n     * @param start - start of the interval, inclusive\n     * @param end - end of the interval, exclusive\n     * @throws {RangeError} if the end is less than the start\n     */\n    constructor(public readonly start: number, public readonly end: number) {\n        if (end < start) {\n            throw new RangeError(\"End cannot be less than start\");\n        }\n        this.start = start;\n        this.end = end;\n    }\n\n    /**\n     * Enables the spread operator for OpenIntervals.\n     */\n    *[Symbol.iterator] () {\n        yield this.start;\n        yield this.end;\n    }\n\n    /**\n     * @return the length of this interval\n     */\n    getLength(): number {\n        return this.end - this.start;\n    }\n\n    /**\n     * @return the center of this interval\n     */\n    getCenter(): number {\n        return 0.5 * (this.start + this.end);\n    }\n\n    /**\n     * Gets whether this interval overlaps or intersects with another one.\n     * \n     * @param other other OpenInterval with which to check for overlap\n     * @return whether this and the other interval overlap\n     */\n    hasOverlap(other: OpenInterval): boolean {\n        const intersectionStart = Math.max(this.start, other.start);\n        const intersectionEnd = Math.min(this.end, other.end);\n        return intersectionStart < intersectionEnd;\n    }\n\n    /**\n     * @return human-readable representation of this instance\n     */\n    toString(): string {\n        return `[${this.start}, ${this.end})`;\n    }\n}\n","import { OpenInterval } from \"./OpenInterval\";\n\n/**\n * A genomic region or position represented by a chromosome name and an open interval of 0-indexed base numbers.  For\n * example, \"chr1:0-3\" would represent the first, second and third bases of the chromosome called \"chr1\".\n * \n * Note that instances are immutable; they cannot be modified.  Create new instances to \"modify\" them.\n * \n * @author Silas Hsu\n */\nexport class ChromosomeInterval {\n    /** The chromosome's name. */\n    public readonly chr: string;\n\n    /** 0-indexed open interval of base numbers. */\n    private readonly _interval: OpenInterval;\n\n    /**\n     * Parses a string representing a ChromosomeInterval, such as those produced by the toString() method.  Throws an\n     * error if parsing fails.\n     * \n     * @param str interval to parse\n     * @return parsed instance\n     * @throws {RangeError} if parsing fails\n     */\n    static parse(str: string): ChromosomeInterval {\n        const regexMatch = str.match(/([\\w:]+)\\W+(\\d+)\\W+(\\d+)/);\n        if (regexMatch) {\n            const chr = regexMatch[1];\n            const start = Number.parseInt(regexMatch[2], 10);\n            const end = Number.parseInt(regexMatch[3], 10);\n            return new ChromosomeInterval(chr, start, end);\n        } else {\n            throw new RangeError(\"Could not parse interval\");\n        }\n    }\n\n    /**\n     * Makes a new instance.  The input interval should be 0-indexed and open; i.e [start, end)\n     * \n     * @param chr name of the chromosome\n     * @param start start base number of the region, inclusive\n     * @param end end base number of the region, exclusive\n     */\n    constructor(chr: string, start: number, end: number) {\n        if (start < 0) {\n            throw new RangeError(\"Start cannot be negative\");\n        }\n        this.chr = chr;\n        this._interval = new OpenInterval(start, end);\n    }\n\n    /**\n     * @return the start base number of this instance\n     */\n    get start(): number {\n        return this._interval.start;\n    }\n\n    /**\n     * Gets the end base number of this instance.  Since instances are represented as open intervals, note the base\n     * number returned by this method is not actually inside of the genomic region represented by this instance.\n     * \n     * @return the end base number of this instance\n     */\n    get end(): number {\n        return this._interval.end;\n    }\n\n    /**\n     * @return the number of bases represented by this instance\n     */\n    getLength(): number {\n        return this._interval.getLength();\n    }\n\n    /**\n     * Checks if this genomic region overlaps or intersects with another one.\n     * \n     * @param other other ChromosomeInterval with which to check for overlap\n     * @return whether this genomic region overlaps with another one\n     */\n    hasOverlap(other: ChromosomeInterval): boolean {\n        return this.chr === other.chr && this._interval.hasOverlap(other._interval);\n    }\n\n    /**\n     * @return human-readable representation of this instance\n     */\n    toString(): string {\n        return `${this.chr}:${this.start}-${this.end}`;\n    }\n\n    /**\n     * Gets a copy of this instance, with the start coordinate rounded down to the nearest multiple of `multiple` and\n     * the end coordinate rounded up to the nearest multiple of `multiple`.  Used for binning purposes.\n     * \n     * @param multiple - the multiple to round to\n     * @return new instance with rounded end coordinates\n     */\n    endsRoundedToMultiple(multiple: number): ChromosomeInterval {\n        if (multiple <= 0) {\n            throw new RangeError(`Cannot round to a multiple <= 0 (got ${multiple})`);\n        }\n        return new ChromosomeInterval(\n            this.chr,\n            Math.floor(this.start / multiple) * multiple,\n            Math.ceil(this.end / multiple) * multiple\n        );\n    }\n}\n","import { ChromosomeInterval } from \"./ChromosomeInterval\";\n\n/**\n * Represents one data point, or one row from a HATCHet .bbc file.  Called a \"bin\" because during data processing, the\n * genome is binned into equal sized chunks.\n */\nexport interface GenomicBin {\n    readonly \"#CHR\": string; // Despite this key implying that it is a number, it can contain values like \"chr3\"\n    readonly START: number;\n    readonly END: number;\n    readonly SAMPLE: string;\n    /** Read depth ratio */\n    readonly RD: number;\n    readonly logRD: number;\n    readonly \"#SNPS\": number;\n    readonly COV: number;\n    readonly ALPHA: number;\n    readonly BETA: number;\n    \n    /** B allele frequency */\n    readonly BAF: number;\n\n    /** Cluster ID */\n    CLUSTER: number;\n\n    readonly cn_normal: number;\n    readonly u_normal: number;\n    readonly cn_clone1: number;\n    readonly u_clone1: number;\n    readonly cn_clone2: number;\n    readonly u_clone2: number;\n    \n    readonly reverseBAF: number;\n    readonly genomicPosition: number;\n}\n\nexport const GenomicBinHelpers = {\n    /**\n     * Converts a GenomicBin to a ChromosomeInterval.\n     * \n     * @param bin the GenomicBin to convert\n     * @return ChromosomeInterval representing the genomic region of the GenomicBin\n     */\n    toChromosomeInterval: function(bin: GenomicBin): ChromosomeInterval {\n        return new ChromosomeInterval(bin[\"#CHR\"], bin.START, bin.END);\n    },\n\n    flattenNestedBins: function(arr : any, result : any[] = []) : any[] {\n        for (let i = 0, length = arr.length; i < length; i++) {\n          const value = arr[i];\n          if (Array.isArray(value)) {\n            this.flattenNestedBins(value, result);\n          } else {\n            result.push(value);\n          }\n        }\n        \n        return result;\n    }\n}\n","import * as d3 from \"d3\";\nimport { GenomicBin } from \"./model/GenomicBin\";\nimport _ from \"lodash\";\n\nexport interface Coordinate {\n    x: number;\n    y: number;\n}\n\ninterface Window {\n    webkitURL?: any;\n}\n\ndeclare var window2: Window;\n\n/**\n * Gets the x and y coordinates of a mouse event *relative to the top left corner of an element*.  By default, the\n * element is the event's `currentTarget`, the element to which the event listener has been attached.\n * \n * For example, if the top left corner of the element is at screen coordinates (10, 10) and the event's screen\n * coordinates are (11, 12), then this function will return `{x: 1, y: 2}`.\n * \n * @param {React.MouseEvent} event - the event for which to get relative coordinates\n * @param {Element} [relativeTo] - calculate coordinates relative to this element.  Default is event.currentTarget.\n * @return {Coordinate} object with props x and y that contain the relative coordinates\n */\nexport function getRelativeCoordinates(event: React.MouseEvent, relativeTo?: Element): Coordinate {\n    if (!relativeTo) {\n        relativeTo = event.currentTarget as Element;\n    }\n    const targetBoundingRect = relativeTo.getBoundingClientRect();\n    return {\n        x: event.clientX - targetBoundingRect.left,\n        y: event.clientY - targetBoundingRect.top\n    };\n}\n\n/**\n * Gets the device's pixel ratio.  Guaranteed to be a number greater than 0.\n * \n * @return {number} this device's pixel ratio\n */\nfunction getPixelRatioSafely(): number {\n    const pixelRatio = window.devicePixelRatio;\n    if (Number.isFinite(pixelRatio) && pixelRatio > 0) {\n        return pixelRatio;\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Applies a fix for Retina (i.e. high pixel density) displays, to prevent a canvas from being blurry.\n * \n * @param {HTMLCanvasElement} canvas - canvas to modify\n */\nexport function applyRetinaFix(canvas: HTMLCanvasElement) {\n    const pixelRatio = getPixelRatioSafely();\n    if (pixelRatio !== 1) {\n        const width = canvas.width;\n        const height = canvas.height;\n\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n        const ctx = canvas.getContext('2d')!;\n        ctx.scale(pixelRatio, pixelRatio);\n    }\n}\n\n/**\n * @param {number} bases - number of bases\n * @param {number} [sigFigs] - number of digits after the decimal point.  Default = 1\n * @return {string} human-readable string representing that number of bases\n */\nexport function niceBpCount(bases: number, sigFigs=1, sub?: number) {\n    \n    let basesAmnt = bases;\n    if(sub) {\n        basesAmnt = basesAmnt - sub;\n    }\n\n    if(basesAmnt < 0) {\n      return '';\n    }\n\n    const rounded = Math.floor(basesAmnt);\n    if (rounded >= 750000) {\n        return `${(rounded/1000000).toFixed(sigFigs)} Mb`;\n    } else if (rounded >= 10000) {\n        return `${(rounded/1000).toFixed(sigFigs)} kb`;\n    } else {\n        return `${rounded} bp`;\n    }\n}\n\n/**\n * Finds the object in `searchPoints` that is \"closest\" to `queryPoint`, and returns its index.  Returns -1 if given an\n * empty list. Uses euclidean distance.  Takes any type of object, but the object must contain keys that point to number\n * values.\n * \n * @param {T} queryPoint - the point for which to find the closest point in `searchPoints`\n * @param {T[]} searchPoints - points to search\n * @param {keyof T} xKey - key of the input objects, which should have a number value, to use as a \"x\" coordinate\n * @param {keyof T} yKey - key of the input objects, which should have a number value, to use as a \"y\" coordinate\n * @return {number} the index in `searchPoints` that contains the object closest to `queryPoint`\n */\nexport function getMinDistanceIndex<T>(queryPoint: T, searchPoints: T[], xKey: keyof T, yKey: keyof T): number {\n    let minDistance = Number.MAX_VALUE;\n    let minIndex = -1;\n    for (let i = 0; i < searchPoints.length; i++) {\n        const distance = squaredDistance(searchPoints[i], queryPoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minIndex = i;\n        }\n    }\n    return minIndex;\n\n    function squaredDistance(a: T, b: T) {\n        const xDiff = (a[xKey] as any) - (b[xKey] as any);\n        const yDiff = (a[yKey] as any) - (b[yKey] as any);\n        return xDiff * xDiff + yDiff * yDiff;\n    }\n}\n\nexport function calculateEuclideanDist(pointOne: number[] | string[] | Number[], pointTwo: number[] | string[] | Number[], sqrt?: boolean) : number {\n    if(pointOne.length !== pointTwo.length) {\n      throw Error(\"Calculate Euclidean Distance - pointOne dim does not match pointTwo dim\");\n    }\n\n    let result = 0;\n    for(let i = 0; i < pointOne.length; i++) {\n      const currentDiff = Number(pointOne[i]) - Number(pointTwo[i]);\n      result += currentDiff * currentDiff;\n    }\n\n    return (sqrt === true) ? Math.sqrt(result): result;\n}\n\n\n\n/**\n * Samples `numSamples` items from the input list by selecting equally-spaced elements.  If the list is shorter than the\n * desired number of samples, returns the entire list.  Note that if the input is sorted, the output will be sorted as\n * well.\n * \n * @param {T[]} list - list for which to sample\n * @param {number} numSamples - number of samples\n * @return {T[]} items sampled from the list\n */\nexport function sampleWithEqualSpacing<T>(list: T[], numSamples: number): T[] {\n    if (list.length <= numSamples) {\n        return list;\n    }\n\n    const samples: T[] = [];\n    for (let i = 0; i < numSamples; i++) {\n        const fractionIterated = i / numSamples;\n        const selectedIndex = Math.ceil(fractionIterated * list.length);\n        samples.push(list[selectedIndex]);\n    }\n    return samples;\n}\n\nexport const trunc = (str : string, len : number) =>\n  str.length > len ? str.substr(0, len - 1) + \"...\" : str;\n\nexport const webglColor = (color : string) => {\n    let col = d3.color(color);\n    if(col !== null) {  \n        const { r, g, b, opacity } = col.rgb();\n        return [r / 255, g / 255, b / 255, opacity];\n    }\n\n    return;\n}\n\nexport const iterateElements = (selector : any, fn : any) =>\n  [].forEach.call(document.querySelectorAll(selector), fn);\n\n/**\n * calculates the average Euclidean distance from p to every point in other_cluster\n * @param p point from which distances will be calculated\n * @param other_cluster a cluster that p is NOT a part of\n */\nexport const calculateInterClusterDist1D = (p: GenomicBin, other_cluster: GenomicBin[]) : number => {\n  let pointOne : [number, number] = [p.reverseBAF, p.RD];\n  let dists = [];\n  for(const bin of other_cluster) {\n    dists.push(calculateEuclideanDist(pointOne, [bin.reverseBAF, bin.RD], true));\n  }\n\n  return _.mean(dists);\n}\n\n\n/**\n * calculates the average Euclidean distance from p to every point in other_cluster\n * @param p point from which distances will be calculated\n * @param other_cluster a cluster that p is NOT a part of\n */\n export const calculateInterClusterDist2 = (p: number[] | Number[], other_cluster: number[][] | Number[][]) : number => {\n  let dists = [];\n  for(const bin of other_cluster) {\n    dists.push(calculateEuclideanDist(p, bin, true));\n  }\n\n  return _.mean(dists);\n}\n\n/**\n * calculates the average Euclidean distance from every point in cluster to p\n * @param p a single point within cluster\n * @param cluster cluster from which the distances from p will be calculated\n */\nexport const calculateIntraClusterDist1D = (p: GenomicBin, cluster: GenomicBin[]) => {\n  let pointOne : [number, number] = [p.BAF, p.RD];\n  let dists = [];\n  if(cluster.length === 1) {\n    return 0;\n  }\n\n  for(const bin of cluster) {\n    let pointTwo : [number, number] = [bin.BAF, bin.RD];\n    const dist = calculateEuclideanDist(pointOne, pointTwo, true);\n    if(dist !== 0) {\n      dists.push(dist);\n    }\n  }\n\n  return _.mean(dists)\n}\n\n\n/**\n * calculates the average Euclidean distance from every point in cluster to p\n * @param p a single point within cluster\n * @param cluster cluster from which the distances from p will be calculated\n */\n export const calculateIntraClusterDist2 = (p: number[], cluster: number[][] | Number[][]) => {\n  let dists = [];\n  if(cluster.length === 1) {\n    return 0;\n  }\n\n  for(const bin of cluster) {\n    const dist = calculateEuclideanDist(p, bin, true);\n    if(dist !== 0) {\n      dists.push(dist);\n    }\n  }\n\n  return _.mean(dists)\n}\n\nexport function distanceMatrix(data : any, distanceFn : any) {\n  const result = getMatrix(data.length);\n\n  // Compute upper distance matrix\n  for (let i = 0; i < data.length; i++) {\n    for (let j = 0; j <= i; j++) {\n      const bin1 = [data[i][0], data[i][1]];\n      const bin2 = [data[j][0], data[j][1]];\n      result[i][j] = distanceFn(bin1, bin2, true);\n      result[j][i] = result[i][j];\n    }\n  }\n\n  return result;\n}\n\nfunction getMatrix(size : number) {\n  const matrix = [];\n  for (let i = 0; i < size; i++) {\n    const row : number[] = [];\n    matrix.push(row);\n    for (let j = 0; j < size; j++) {\n      row.push(0);\n    }\n  }\n  return matrix;\n}\n\nexport function calculateSilhoutteScores(rawData: number[][], clusteredData: Map<Number, Number[][]>,  labels: number[]) {\n  let possible_clusters = [...clusteredData.keys()];\n    let clusterToSilhoutte = new Map<number, number[] | undefined>();\n    if(possible_clusters.length === 1) {\n      return [];\n    }\n    \n    const downSamplePercent = (rawData.length > 0) ? .01 : 1;\n    for(let i = 0; i < rawData.length; i++) {\n      \n        const bin1 = rawData[i];\n        const c = labels[i];\n\n        const binsInCluster = clusteredData.get(c);\n        if(binsInCluster) {\n          if(binsInCluster.length === 1) {\n            if(clusterToSilhoutte.has(c)) {\n              const previousSilhouttes = clusterToSilhoutte.get(c);\n              if(previousSilhouttes) {\n                previousSilhouttes.push(0);\n                clusterToSilhoutte.set(c, previousSilhouttes);\n              }\n            } else {\n              clusterToSilhoutte.set(c, [0]);\n            }\n\n            continue;\n          }\n\n          // downsample both bins_in_clust er and bins_not_in_cluster\n          const downSampledBinsInCluster = downSample(binsInCluster, downSamplePercent);\n\n          const a = calculateIntraClusterDist2(bin1, downSampledBinsInCluster);\n          let minB = Infinity;\n          for(let c2 of possible_clusters) {\n            if(c2 !== c) {\n              const otherCluster = clusteredData.get(c2);\n              if(otherCluster) {\n                const downSampledOtherCluster = downSample(otherCluster, downSamplePercent);\n                const b = calculateInterClusterDist2(bin1, downSampledOtherCluster);\n                if(b < minB) {\n                  minB = b;\n                }\n\n              } else {\n                throw new Error(\"Key error: Cluster not found\");\n                // reject(\"Key error: Cluster not found\");\n              }\n            }\n          }\n\n          let maxAB = _.max([minB, a]);\n          if(maxAB) {\n            const s = (minB - a) / maxAB;\n\n            if(clusterToSilhoutte.has(c)) {\n              const previousSilhouttes = clusterToSilhoutte.get(c);\n              if(previousSilhouttes) {\n                previousSilhouttes.push(s);\n                clusterToSilhoutte.set(c, previousSilhouttes);\n              }\n            } else {\n              clusterToSilhoutte.set(c, [s]);\n            }\n          }\n        } else {\n          throw new Error(\"Key error: Cluster not found\");\n          // reject(\"Key error: Cluster not found\");\n        }\n    }\n\n    const avg_cluster_silhouttes = [];\n    for(const c of possible_clusters) {\n      const val = clusterToSilhoutte.get(Number(c));\n      if(val !== undefined) {\n        const avg = {cluster: Number(c), avg : _.mean(val)};\n        avg_cluster_silhouttes.push(avg);\n      }\n    }\n    const sorted = _.sortBy(avg_cluster_silhouttes, \"cluster\");\n    return sorted;\n}\n\n\n\n/**\n * Calculate Silhouette Coefficient\n * @param {Array<Array<number>>} data - list of input data samples\n * @param {Array<number>} labels - label values for each sample\n * @returns {number} score - Silhouette Score for input clustering\n */\n export default function silhouetteScore2(data: any, labels : any) {\n  /*\n\tTODO: Check X and Y for consistent length - enforce X to be 2D and Y 1D.\n\t\tThe length of Y should equal the number of rows in X, which in turn\n\t\tshould be non-empty and should contain only finite values - no NaN-s\n\t\tand Inf-s allowed. The same goes for Y. Check that number of labels\n\t\t(number of distinct values in Y) is valid. Valid values are from 2 to\n\t\tdata.length - 1 (inclusive)\".\n \t*/\n  let dist = distanceMatrix(data, calculateEuclideanDist);\n  let result = silhouetteSamples(dist, labels, silhouetteReduce);\n  return result.reduce((p : any, c : any, i : any) => p + (c - p) / (i + 1), 0);\n}\n\n/**\n * Calculate Silhouette for each data sample\n * @param {Array<Array<number>>} data - list of input data samples\n * @param {Array<number>} labels - label values for each sample\n * @param {Function|Mock} reduceFunction - reduce function to apply on samples\n * @returns {Array<number>} arr - Silhouette Coefficient for each sample\n */\nfunction silhouetteSamples(data : any, labels : any, reduceFunction : any) {\n  /*\n\tTODO: Check X and Y for consistent length - enforce X to be 2D and Y 1D.\n\t\tThe length of Y should equal the number of rows in X, which in turn\n\t\tshould be non-empty and should contain only finite values - no NaN-s\n\t\tand Inf-s allowed. The same goes for Y. Check that number of labels\n\t\t(number of distinct values in Y) is valid. Valid values are from 2 to\n\t\tdata.length - 1 (inclusive)\".\n\t */\n  let labelsFreq = countBy(labels); // # of points in each cluster\n  let samples = reduceFunction(data, labels, labelsFreq);\n  let denom = labels.map((val : any) => labelsFreq[val] - 1);\n  let intra = samples.intraDist.map((val : any, ind : any) => val / denom[ind]);\n  let inter = samples.interDist;\n  return inter\n    .map((val : any, ind : any) => val - intra[ind])\n    .map((val : any, ind : any) => val / Math.max(intra[ind], inter[ind]));\n}\n\n/**\n * Count the number of occurrences of each value in array.\n * @param {Array<number>} arr - Array of positive Integer values\n * @return {Array<number>} out - number of occurrences of each value starting from\n * 0 to max(arr).\n */\nfunction countBy(arr : any) {\n  let valid = arr.every((val : any) => {\n    if (typeof val !== 'number') return false;\n    return val >= 0.0 && Math.floor(val) === val && val !== Infinity;\n  });\n  if (!valid) throw new Error('Array must contain only natural numbers');\n\n  let out = Array.from({ length: Math.max(...arr) + 1 }, () => 0);\n  arr.forEach((value : any) => {\n    out[value]++;\n  });\n  return out;\n}\n\nfunction silhouetteReduce(dataChunk : any, labels : any, labelFrequencies : any) {\n  // datachunk: # of data points x # of data points in size\n\n  // clusterDistances is # of data points x # of clusters\n  // gives distance from each data point to every cluster\n  let clusterDistances : number[][] = dataChunk.map((row : any) => {\n      let ar = labelFrequencies.map((_ : any, mInd : any) => // mInd represents cluster we are going to run the function on\n        {\n          let test = labels.reduce(\n            (acc : any, val : any, rInd : any) => {\n              return (val === mInd ? acc + row[rInd] : acc + 0)\n            }, 0\n          )\n          return test;\n        }\n      )\n      return ar;\n    }\n  );\n\n  // Each row in clusterDistances represents a bin and its distances to each cluster\n  // So we for each bin we get the distance of that bin to the cluster that the bin is a part of\n  let intraDist = clusterDistances.map((val : any, ind : any) => val[labels[ind]]);\n\n  let interDist = clusterDistances\n    .map((mVal : any, mInd : any) => {\n      mVal[labels[mInd]] += Infinity; // don't want to pick the cluster that the current bin is a part of when taking the min so add infinity\n      labelFrequencies.forEach((fVal : any, fInd : any) => (mVal[fInd] /= fVal)); // avg distances in the row\n      return mVal;\n    })\n    .map((val : any) => Math.min(...val)); // take the (avg) distance to the closest cluster\n\n  return {\n    intraDist: intraDist,\n    interDist: interDist,\n  };\n}\n\n// function xmur3(str : string) {\n//   for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {\n//       h = Math.imul(h ^ str.charCodeAt(i), 3432918353);\n//       h = h << 13 | h >>> 19;\n//   }\n\n//   return function() {\n//       h = Math.imul(h ^ h >>> 16, 2246822507);\n//       h = Math.imul(h ^ h >>> 13, 3266489909);\n//       return (h ^= h >>> 16) >>> 0;\n//   }\n// }\n\n// function mulberry32(a : any) {\n//   return function() {\n//     var t = a += 0x6D2B79F5;\n//     t = Math.imul(t ^ t >>> 15, t | 1);\n//     t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n//     return ((t ^ t >>> 14) >>> 0) / 4294967296;\n//   }\n// }\n\nexport function downSample<T>(data: T[], percent: number) : T[] {\n  let downSampledData = new Set<T>();\n  const original_len = data.length;\n  const new_len = percent * original_len;\n  // var seed = xmur3(\"testseed\");\n  while(downSampledData.size < new_len) {\n    const rand_idx = Math.floor(Math.random() * original_len);\n    // const rand_idx = Math.floor(mulberry32(seed())() * original_len);\n    const bin = data[rand_idx];\n    downSampledData.add(bin);\n  }\n  \n  return [...downSampledData];\n}\n\n\n/**\nMIT License\n\nCopyright (c) 2019 react-csv\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n*/\n  /**\n * Simple safari detection based on user agent test\n */\nexport const isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\nexport const isJsons = ((array: any) => Array.isArray(array) && array.every(\n row => (typeof row === 'object' && !(row instanceof Array))\n));\n\nexport const isArrays = ((array: any) => Array.isArray(array) && array.every(\n row => Array.isArray(row)\n));\n\nexport const jsonsHeaders = ((array: any) => Array.from(\n array.map((json: any) => Object.keys(json))\n .reduce((a: any, b: any) => new Set([...a, ...b]), [])\n));\n\nexport const jsons2arrays = (jsons: any, headers: any) => {\n  headers = headers || jsonsHeaders(jsons);\n\n  // allow headers to have custom labels, defaulting to having the header data key be the label\n  let headerLabels = headers;\n  let headerKeys = headers;\n  if (isJsons(headers)) {\n    headerLabels = headers.map((header: any) => header.label);\n    headerKeys = headers.map((header: any) => header.key);\n  }\n\n  const data = jsons.map((object: any) => headerKeys.map((header: any) => getHeaderValue(header, object)));\n  return [headerLabels, ...data];\n};\n\nexport const getHeaderValue = (property: any, obj: any) => {\n  const foundValue = property\n    .replace(/\\[([^\\]]+)]/g, \".$1\")\n    .split(\".\")\n    .reduce(function(o: any, p: any, i: any, arr: any) {\n      // if at any point the nested keys passed do not exist, splice the array so it doesnt keep reducing\n      if (o[p] === undefined) {\n        arr.splice(1);\n        return null;\n      } else {\n        return o[p];\n      }\n    }, obj);\n  // if at any point the nested keys passed do not exist then looks for key `property` in object obj\n  return (foundValue === undefined) ? ((property in obj) ? obj[property] : '') : foundValue;\n}\n\nexport const elementOrEmpty = (element : any) => {\n  return (typeof element === 'undefined' || element === null) ? '' : element;\n};\n\nexport const joiner = ((data : any, separator = ',', enclosingCharacter = '') => {\n  return data\n    .filter((e : any) => e)\n    .map(\n      (row: any) => row\n        .map((element : any) => elementOrEmpty(element))\n        .map((column: any) => `${column}`)\n        .join(separator)\n    )\n    .join(`\\n`);\n});\n\nexport const arrays2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n joiner(headers ? [headers, ...data] : data, separator, enclosingCharacter)\n);\n\nexport const jsons2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n joiner(jsons2arrays(data, headers), separator, enclosingCharacter)\n);\n\nexport const string2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n  (headers) ? `${headers.join(separator)}\\n${data}`: data\n);\n\nexport const toCSV = (data: any, headers: any, separator: any, enclosingCharacter: any) => {\n if (isJsons(data)) return jsons2csv(data, headers, separator, enclosingCharacter);\n if (isArrays(data)) return arrays2csv(data, headers, separator, enclosingCharacter);\n if (typeof data ==='string') return string2csv(data, headers, separator, enclosingCharacter);\n throw new TypeError(`Data should be a \"String\", \"Array of arrays\" OR \"Array of objects\" `);\n};\n\nexport const buildURI = ((data : any, uFEFF: any, headers: any, separator: any, enclosingCharacter: any) => {\n  const csv = toCSV(data, headers, separator, enclosingCharacter);\n  const type = isSafari() ? 'application/csv' : 'text/csv';\n  const blob = new Blob([uFEFF ? '\\uFEFF' : '', csv], {type});\n  const dataURI = `data:${type};charset=utf-8,${uFEFF ? '\\uFEFF' : ''}${csv}`;\n\n  const URL = window.URL || window2.webkitURL;\n\n  return (typeof URL.createObjectURL === 'undefined')\n    ? dataURI\n    : URL.createObjectURL(blob);\n});\n\n\n\n\n\n\n","import _ from \"lodash\";\nimport { GenomicBin, GenomicBinHelpers } from \"./GenomicBin\";\nimport \"crossfilter2\";\nimport crossfilter, { Crossfilter } from \"crossfilter2\";\nimport memoizeOne from \"memoize-one\";\nimport {calculateEuclideanDist, calculateSilhoutteScores} from \"../util\"\nimport { brush } from \"d3\";\nimport { resolve } from \"dns\";\n\nfunction silhouttePromise(multiDimData : number[][], clusterToData : Map<Number, Number[][]>, labels : number[]) : Promise<{cluster: number, avg:number}[]>{\n    return new Promise((resolve : any, reject : any)=> {\n        resolve(calculateSilhoutteScores(multiDimData, clusterToData, labels));\n    })\n}\n\nexport function reformatBins(samples: string[], applyLog: boolean, allRecords: readonly GenomicBin[]) : Promise<{multiDimData: number[][], clusterToData : Map<Number, Number[][]>, labels: number[]}> {\n    return new Promise<{multiDimData: number[][], clusterToData : Map<Number, Number[][]>, labels: number[]}>((resolve, reject) => {\n        // const samples = samples;\n        const multiDimData = []; \n        const labels : number[] = [];\n        const clusterToData = new Map<Number, Number[][]>();\n\n        const rdKey = (applyLog) ? \"logRD\" :  \"RD\";\n\n        // Reformat data into multidimensional format for RDRs and BAFs\n        // Assumption: length of data % number of samples == 0\n        // Every genome range has the same number of samples\n        for(let i = 0; i < allRecords.length; i += samples.length) {\n            const row = [];\n            const c = allRecords[i].CLUSTER;\n            for(let j = i; j < i + samples.length; j++) {\n                if(j < allRecords.length) {\n                    const currentBin = allRecords[j];\n                    if(j === i) {\n                        labels.push(c);\n                    }\n                    row.push(currentBin.reverseBAF);\n                    row.push(currentBin[rdKey]);\n                } else {\n                    throw Error(\"Out of Range Error. There are bins missing in the data (bin must exist across all samples).\")\n                }\n            }\n\n            multiDimData.push(row);\n            if(clusterToData.has(c)) {\n                let original = clusterToData.get(c);\n                if(original !== undefined) {\n                    original.push(row);\n                    clusterToData.set(c, original);\n                }\n            } else {\n                clusterToData.set(c, [row]);\n            }\n        }\n         \n        let returnVal = {multiDimData: multiDimData, clusterToData: clusterToData, labels: labels};\n        resolve(returnVal);\n    });\n}\n/**\n * Nested dictionary type.  First level key is the sample name; second level key is cluster in that sample; third level key is the chromosome in the given sample with the given cluster.\n * \n * @typeParam T type of value stored\n */\ntype IndexedBioData<T> = {\n    [sample: string]: {\n        [cluster: string] : {\n            [chr: string]: T\n        }\n    }\n};\n\ntype LocationIndexedData<T> = {\n    [loc : string]: T\n};\n\nexport type ClusterIndexedData<T> = {\n    [cluster: string] : T\n}\n\ntype SampleIndexedData<T> = {\n    [sample: string] : T\n}\n\ntype LogTableRow = {\n    action: string\n}\n\ntype clusterIdMap = {[id: string] : number}\ntype clusterTableRow =  {key: number, value: number}\ntype selectionTableRow =  {key: number, value: number, selectPerc: number}\ntype centroidPoint = {cluster: number, point: [number, number]}\ntype newCentroidTableRow = {key: string, sample: {[sampleName: string] : string}}\nexport type heatMapElem = {cluster1: number, cluster2: number, dist: number}\n\n/**\n * A container that stores metadata for a list of GenomicBin and allows fast queries first by sample, and then by\n * chromosome.  For applications that want a limited amount of data, pre-aggregates GenomicBin and allows fast queries\n * of that data too.\n * \n * @author Silas Hsu\n */\nexport class DataWarehouse {\n    /** The special chromosome name that signifies a query for the entire genome (all chromosomes). */\n    public static readonly ALL_CHRS_KEY : string = \"\"; \n    public static readonly ALL_CLUSTERS_KEY : string = \"\";\n\n    /** Indexed GenomicBin for supporting fast queries. */\n    //private _indexedData: IndexedBioData<GenomicBin[]>;\n    /** Indexed, pre-aggregated GenomicBin for supporting fast queries. */\n    //private _indexedMergedData: IndexedBioData<MergedGenomicBin[]>;\n    /** The range of read depth ratios represented in this data set.  First number is min, second is max. */\n    private readonly _rdRanges: SampleIndexedData<[number, number]>;\n    private readonly _logRdRanges: SampleIndexedData<[number, number]>;\n    private _locationGroupedData: LocationIndexedData<GenomicBin[]>;\n    private brushedBins: GenomicBin[];\n    private brushedCrossfilter: Crossfilter<GenomicBin>;\n    private brushedClusterDim: crossfilter.Dimension<GenomicBin, number>;\n    private _ndx: Crossfilter<GenomicBin>;\n    private _sample_dim: crossfilter.Dimension<GenomicBin, string>;\n    private _cluster_dim: crossfilter.Dimension<GenomicBin, number>;\n    private _chr_dim: crossfilter.Dimension<GenomicBin, string>;\n    private _genomic_pos_dim: crossfilter.Dimension<GenomicBin, number>;\n    private _samples: string[];\n    private _clusters: string[];\n    private _chrs: string[];\n    private _sampleGroupedData: SampleIndexedData<GenomicBin[]>;\n    private clusterTableInfo: clusterTableRow[]; \n    private allRecords: readonly GenomicBin[];\n    private _cluster_filters: String[];\n    private historyStack: GenomicBin[][];\n    private _clusterAmounts: readonly crossfilter.Grouping<crossfilter.NaturallyOrderedValue, unknown>[];//ChrIndexedData<GenomicBin[]>;\n    private logOfActions: LogTableRow[];\n    private centroids: newCentroidTableRow[];\n    private centroidPts: SampleIndexedData<ClusterIndexedData<centroidPoint[]>>;\n    private chrToClusters: {[chr: string] : Set<string>}\n    private centroidDistances: SampleIndexedData<heatMapElem[]>;\n    private shouldCalculateSilhouttes: boolean;\n    private currentSilhouttes: {cluster: number,  avg: number}[]\n\n    /**\n     * Indexes, pre-aggregates, and gathers metadata for a list of GenomicBin.  Note that doing this inspects the entire\n     * data set, and could be computationally costly if the data set is large.\n     * \n     * @param rawData the data to process\n     * @param merger aggregator to use\n     * @throws {Error} if the data contains chromosome(s) with the reserved name of `DataWarehouse.ALL_CHRS_KEY`\n     */\n    constructor(rawData: GenomicBin[]) {\n        this._locationGroupedData = {};\n        this.initializeLocationGroupedData(rawData);\n        this._sampleGroupedData = {};\n        this._rdRanges = {};\n        this._logRdRanges = {};\n        this._samples = [];\n        this._chrs = [];\n        this._clusters = [];\n        this.brushedBins = [];\n        this.brushedCrossfilter = crossfilter(this.brushedBins);\n        this.brushedClusterDim = this.brushedCrossfilter.dimension((d:GenomicBin) => d.CLUSTER);\n        this._cluster_filters = [];\n        this.historyStack = [];\n        this._ndx = crossfilter(rawData);\n        this.logOfActions = [];\n        this.centroidPts = {}; // used for plotting centroids\n        this.centroids = []; // used for displaying centroids in centroid table\n        this.chrToClusters = {};\n        this.centroidDistances = {};\n        this.shouldCalculateSilhouttes = true;\n        this.currentSilhouttes = [];\n\n        for(const d of rawData) {\n            if(this.chrToClusters[d[\"#CHR\"]])\n                this.chrToClusters[d[\"#CHR\"]].add(String(d.CLUSTER));\n            else\n                this.chrToClusters[d[\"#CHR\"]] = new Set([String(d.CLUSTER)]);\n        }\n\n        const groupedBySample = _.groupBy(rawData, \"SAMPLE\");\n        for (const [sample, binsForSample] of Object.entries(groupedBySample)) {\n            this._samples.push(sample);\n            const groupedByCluster = _.groupBy(binsForSample, \"CLUSTER\");\n            this._clusters = _.union(this._clusters, Object.keys(groupedByCluster));\n            for (const binsForCluster of Object.values(groupedByCluster)) {\n                const groupedByChr = _.groupBy(binsForCluster, \"#CHR\");\n                this._chrs = _.union(this._chrs, Object.keys(groupedByChr));\n            }\n        }\n\n\n        const groupedByCluster = _.groupBy(rawData, \"CLUSTER\");\n        for (const [clus, binsForCluster] of Object.entries(groupedByCluster)) {\n            const groupedBySample = _.groupBy(binsForCluster, \"SAMPLE\");\n            let sampleDict : {[sampleName: string] : string} = {};\n            for(const [sample, binsForSample] of Object.entries(groupedBySample)) {\n                const centroid = this.calculateCentroid(binsForSample, \"RD\");\n                let centroidPt : centroidPoint = {cluster: parseInt(clus), point: centroid};\n\n                if(this.centroidPts[sample] && this.centroidPts[clus]) {\n                    this.centroidPts[sample][clus].push(centroidPt);\n                } else if(this.centroidPts[sample]) {\n                    this.centroidPts[sample][clus] = [centroidPt];\n                } else  { \n                    let dataKey : string = clus; //.toString();\n                    let tempMap : ClusterIndexedData<centroidPoint[]> = {};\n                    tempMap[dataKey] = [centroidPt];\n                    this.centroidPts[sample] = tempMap;\n                }\n\n                let centroidStr = \"(\" + centroid[0].toFixed(2) + \",\" + centroid[1].toFixed(2) + \")\";\n                sampleDict[sample] = centroidStr;\n            }\n\n            let centroidTableRow : newCentroidTableRow = {\n                key: clus,\n                sample: sampleDict\n            };\n            this.centroids.push(centroidTableRow);\n        }\n        \n\n        this._cluster_filters = this._clusters;\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this._genomic_pos_dim = this._ndx.dimension((d:GenomicBin) => d.genomicPosition);\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        \n        if (rawData.length > 0) {\n            for(const sample of this._samples) {\n                let currentSampleBins = this._sampleGroupedData[sample];\n                let currentRdRange : [number, number] = [_.minBy(currentSampleBins, \"RD\")!.RD, _.maxBy(currentSampleBins, \"RD\")!.RD];\n                let currentLogRdRange : [number, number] = [_.minBy(currentSampleBins, \"logRD\")!.logRD, _.maxBy(currentSampleBins, \"logRD\")!.logRD];\n                this._rdRanges[sample] = currentRdRange;\n                this._logRdRanges[sample] = currentLogRdRange;\n                \n            }\n        }\n\n        this.initializeCentroidDistMatrix();\n        this.allRecords = this._ndx.all();\n        this.clusterTableInfo = this.calculateClusterTableInfo();\n        this.filterRecordsByScales = memoizeOne(this.filterRecordsByScales);\n    }\n\n    setShouldRecalculateSilhouttes(shouldRecalculate: boolean) {\n        this.shouldCalculateSilhouttes = shouldRecalculate;\n    }\n\n    async recalculateSilhouttes(applyLog: boolean) {\n        if(this.shouldCalculateSilhouttes) {\n            let contents = null;\n            try {\n                contents = await reformatBins(this._samples, applyLog, this.allRecords);\n            } catch (error) {\n                console.error(error);\n                return;\n            }\n\n            const s = calculateSilhoutteScores(contents.multiDimData, contents.clusterToData, contents.labels);\n            this.currentSilhouttes = s;\n            this.shouldCalculateSilhouttes = false;\n        }\n        return this.currentSilhouttes;\n    }\n\n    initializeCentroidDistMatrix() {\n        for(const sample of this._samples) {\n            this.centroidDistances[sample] = [];\n            let sampleSpecificCentroids : centroidPoint[] = this.getCentroidPoints(sample);\n            for(const c of sampleSpecificCentroids) {\n                for(const c2 of sampleSpecificCentroids) {\n                    const d : number = calculateEuclideanDist(c.point, c2.point);\n                    this.centroidDistances[sample].push({cluster1: c.cluster, cluster2: c2.cluster, dist: d});\n                }\n            }\n        }\n    }\n\n    getCentroidDistMatrix(sample: string) {\n        return this.centroidDistances[sample];\n    }\n\n    calculateCentroid(points: GenomicBin[], yAxis: keyof Pick<GenomicBin, \"RD\" | \"logRD\">):  [number, number] {\n        return [_.meanBy(points, d => d.reverseBAF), _.meanBy(points, d => d[yAxis])];\n    }\n\n    getCentroidData() {\n        return this.centroids;\n    }\n\n    getCentroidPoints(sample: string, chr?: string) {\n        const samplePts = this.centroidPts[sample]; // Get centroids for a specific sample\n        \n        let clustersAssociatedWithChr = this._cluster_filters;\n        let setOfClustersInChr;\n        if(chr) {\n            setOfClustersInChr = this.chrToClusters[chr]; // All clusters that appear when filtered by the given chr\n        } else {\n            setOfClustersInChr = new Set(clustersAssociatedWithChr);\n        }\n       \n        let sampleSpecificCentroids : centroidPoint[] = [];\n        for(const cluster of clustersAssociatedWithChr) { // Go through all filtered clusters\n            if(setOfClustersInChr.has(cluster) && samplePts[cluster.valueOf()]) { // Check that the cluster appears when filtered by chr \n                sampleSpecificCentroids.push(samplePts[cluster.valueOf()][0]);\n            }\n        }\n\n        return sampleSpecificCentroids;\n    }\n\n    calculateClusterTableInfo() : clusterTableRow[] {\n        const clusterInfo = this._cluster_dim.group().all();\n        const clusterTable : clusterTableRow[] = [];\n        for(const row of clusterInfo) {\n            let value = Number(((Number(row.value)/this.allRecords.length) * 100).toFixed(2));\n            clusterTable.push(\n            {\n                key: Number(row.key), \n                value: value\n            });\n        }\n        return clusterTable;\n    }\n\n    initializeLocationGroupedData(rawData: GenomicBin[]) {\n        this._locationGroupedData = {};\n        for(const bin of rawData) {\n            const binLocation = GenomicBinHelpers.toChromosomeInterval(bin).toString();\n            if(this._locationGroupedData[binLocation]) {\n                this._locationGroupedData[binLocation].push(bin);\n            } else {\n                this._locationGroupedData[binLocation] = [bin];\n            }\n        }\n    }\n\n    /**\n     * @return whether this instance stores any data\n     */\n    isEmpty(): boolean {\n        return this.getSampleList().length === 0;\n    }\n\n    /**\n     * Gets the range of read depth ratios represented in this data set.  Returns the result as a 2-tuple; the first\n     * number is the min, and the second is the max.\n     * \n     * @return the range of read depth ratios represented in this data set\n     */\n    getRdRange(sample : string, log?: boolean): [number, number] {\n        const rdRange = (log) ? this._logRdRanges[sample] : this._rdRanges[sample];\n        return [rdRange[0], rdRange[1]];\n    }\n\n    /**\n     * @return a list of sample names represented in this data set\n     */\n    getSampleList(): string[] {\n        return this._samples;\n    }\n\n    /**\n     * @return a list of chromosome names represented in this data set\n     */\n    getAllChromosomes(): string[] {\n        return this._chrs;\n    }\n\n    getAllClusters(): string[] {\n        return this._clusters;\n    }\n\n    setFilters(sample?: string, chr?: string, clusters?: string[]) {\n        if(chr) { this._chr_dim.filter(d => d === chr); }\n\n        if(clusters) {\n            this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        }\n    }\n\n    setChrFilter(chr?: string) {\n        if(chr) {\n            this._chr_dim.filterAll();\n            this._chr_dim.filter(d => d === chr);\n        } else {\n            this._chr_dim.filterAll();\n        }\n        \n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    setChrFilters(chrs?: string[]) {\n        if(chrs && ((chrs.length === 1 && chrs[0] === DataWarehouse.ALL_CHRS_KEY))) {\n            this._chr_dim.filterAll();\n        } else if(chrs) {\n            this._chr_dim.filterAll();\n            this._chr_dim.filter(d => chrs.indexOf(String(d)) === -1 ? false : true);\n        }\n    }\n\n\n    setClusterFilters(clusters?: String[]) {\n        if(clusters && ((clusters.length === 1 && clusters[0] === DataWarehouse.ALL_CLUSTERS_KEY))) {\n            this._cluster_dim.filterAll();\n        } else if(clusters) {\n            this._cluster_dim.filterAll();\n            this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        }\n        if(clusters) {\n            this._cluster_filters = clusters;\n        }\n        \n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    setGenomicPositionFilter(genomeRange: [number, number]) {\n        this._genomic_pos_dim.filterAll();\n        this._genomic_pos_dim.filter(d => d > genomeRange[0] && d < genomeRange[1]);\n\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    clearAllFilters() {\n        this._sample_dim.filterAll();\n        this._cluster_dim.filterAll();\n        this._chr_dim.filterAll();\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    getActions() {\n        return this.logOfActions;\n    }\n\n    updateCluster(cluster: number) {\n        if(!this.brushedBins || this.brushedBins.length === 0) {\n            return;\n        }\n\n        this.historyStack.push(JSON.parse(JSON.stringify(this.brushedBins)));\n        let brushedTableData  = this.brushedTableData();\n        \n        let action = \"Assigned to cluster \" + cluster + \" | \";\n        action += \"Clusters selected: \";\n        for(const row of brushedTableData) {\n            action += String(row.key) + \" (\" + String(row.value) + \"%), \";\n        }\n        action += \" | \"\n        let currentRdRange : [number, number] = [_.minBy(this.brushedBins, \"RD\")!.RD, _.maxBy(this.brushedBins, \"RD\")!.RD];\n        let currentBAFRange : [number, number] = [_.minBy(this.brushedBins, \"reverseBAF\")!.reverseBAF, _.maxBy(this.brushedBins, \"reverseBAF\")!.reverseBAF];\n        \n        action += \"RD Range of Selected: [\" + currentRdRange[0].toFixed(2) + \", \"+currentRdRange[1].toFixed(2) + \"] | \";\n\n        action += \"Allelic Imbalance Range of Selected: [\" + currentBAFRange[0].toFixed(2) + \", \"+currentBAFRange[1].toFixed(2) + \"]\";\n\n        this.logOfActions.unshift({action: action});\n        \n        for(let i = 0; i < this.brushedBins.length; i++) {\n            let locKey = GenomicBinHelpers.toChromosomeInterval(this.brushedBins[i]).toString();\n            if(this._locationGroupedData[locKey]) {\n                for(let j = 0; j < this._locationGroupedData[locKey].length; j++) {\n                    this._locationGroupedData[locKey][j].CLUSTER = cluster;\n                }\n            }\n        }\n\n        const allMergedBins : GenomicBin[][] = Object.values(this._locationGroupedData);\n        let flattenNestedBins : GenomicBin[] = GenomicBinHelpers.flattenNestedBins(allMergedBins);\n        this.centroids = [];\n        this.centroidPts = {};\n        this.chrToClusters = {};\n        for(const d of flattenNestedBins) {\n            if(this.chrToClusters[d[\"#CHR\"]]) {\n                this.chrToClusters[d[\"#CHR\"]].add(String(d.CLUSTER));\n                \n            } else {\n                this.chrToClusters[d[\"#CHR\"]] = new Set([String(d.CLUSTER)]); \n            }   \n        }\n\n        // Steps to find centroids (in a format that can be displayed in the table properly)\n        // 1. group by cluster\n        // 2. Get each group of points with all matching cluster\n        // 3. Group by sample\n        // 4. Find centroid for that group of points\n        // 5. Create a Sample dictionary with each sample name mapped to centroid\n        // 6. Add dictionary to table row\n        // 7. Push table row into list of table rows\n        // 8. Move on to next cluster and repeat\n        const groupedByCluster = _.groupBy(flattenNestedBins, \"CLUSTER\");\n        for (const [clus, binsForCluster] of Object.entries(groupedByCluster)) {\n            const groupedBySample = _.groupBy(binsForCluster, \"SAMPLE\");\n            let sampleDict : {[sampleName: string] : string} = {};\n            for(const [sample, binsForSample] of Object.entries(groupedBySample)) {\n                const centroid = this.calculateCentroid(binsForSample, \"RD\");\n                let centroidPt : centroidPoint = {cluster: parseInt(clus), point: centroid};\n\n                if(this.centroidPts[sample] && this.centroidPts[clus]) {\n                    this.centroidPts[sample][clus].push(centroidPt);\n                } else if(this.centroidPts[sample]) {\n                    this.centroidPts[sample][clus] = [centroidPt];\n                } else  { \n                    let dataKey : string = clus; //.toString();\n                    let tempMap : ClusterIndexedData<centroidPoint[]> = {};\n                    tempMap[dataKey] = [centroidPt];\n                    this.centroidPts[sample] = tempMap;\n                }\n                let centroidStr = \"(\" + centroid[0].toFixed(2) + \",\" + centroid[1].toFixed(2) + \")\";\n                sampleDict[sample] = centroidStr;\n            }\n\n            let centroidTableRow : newCentroidTableRow = {\n                key: clus,\n                sample: sampleDict\n            };\n            this.centroids.push(centroidTableRow);\n            \n        }\n        \n        this.initializeCentroidDistMatrix();\n\n        this._ndx.remove();\n        this._ndx = crossfilter(flattenNestedBins);\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this.brushedBins = [];\n        this.brushedCrossfilter.remove();\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        this.allRecords =  this._ndx.all(); \n        let test = this.calculateClusterTableInfo();\n        this.clusterTableInfo = test;\n        this.allRecords = this.allRecords.filter((d: GenomicBin) => d.CLUSTER !== -2);\n\n        if(!this._cluster_filters.includes(String(cluster))) {\n            this._cluster_filters.push(String(cluster));\n        }\n        this.setClusterFilters(this._cluster_filters);\n        this.shouldCalculateSilhouttes = true;\n    }\n\n    undoClusterUpdate() {\n        if(this.historyStack.length === 0) {\n            return;\n        }\n\n        let newRecords = this.historyStack[this.historyStack.length-1];  \n        this.historyStack.pop();\n        for(let i = 0; i < newRecords.length; i++) {\n            let currentBin = newRecords[i];\n            let locKey = GenomicBinHelpers.toChromosomeInterval(currentBin).toString();\n            let cluster = currentBin.CLUSTER;\n            if(!this._cluster_filters.includes(String(cluster))) {\n                this._cluster_filters.push(String(cluster));\n            }\n            if(this._locationGroupedData[locKey]) {\n                for(let j = 0; j < this._locationGroupedData[locKey].length; j++) {\n                    this._locationGroupedData[locKey][j].CLUSTER = cluster;\n                }\n            }\n        }\n\n        const allMergedBins : GenomicBin[][] = Object.values(this._locationGroupedData);\n        let flattenNestedBins : GenomicBin[] = GenomicBinHelpers.flattenNestedBins(allMergedBins);\n        \n        \n        \n        this.initializeCentroidDistMatrix();\n        this._ndx.remove();\n        this._ndx = crossfilter(flattenNestedBins);\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this.brushedBins = [];\n        this.brushedCrossfilter.remove();\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        this.allRecords =  this._ndx.all(); \n        let test = this.calculateClusterTableInfo();\n        this.clusterTableInfo = test;\n        this.allRecords = this.allRecords.filter((d: GenomicBin) => d.CLUSTER !== -2);\n        \n        \n        this.setClusterFilters(this._cluster_filters);\n        this.setShouldRecalculateSilhouttes(true);\n    }\n\n    brushedTableData() {\n        \n        const sampleAmount = this._samples.length;\n        const clusterInfo = this._clusterAmounts;\n        // map each cluster to the amount of points in a single sample \n        // (Each sample contains the same amount of points so we divide by total amount of samples)\n        let clusterIdToAmount : clusterIdMap = {};\n        clusterInfo.forEach(row => clusterIdToAmount[Number(row.key)] = Number(row.value)/sampleAmount);\n        const amountInSelection = this.brushedBins.length;\n        const clusterTable = this.brushedClusterDim.group().all();\n        //clusterTable.forEach(d => d.value = (Number(d.value)/Number(clusterIdToAmount[Number(d.key)]) * 100).toFixed(2));\n\n        const clusterTable2 : selectionTableRow[] = [];\n        for(const row of clusterTable) {\n            clusterTable2.push(\n            {\n                key: Number(row.key), \n                value: Number((Number(row.value)/Number(clusterIdToAmount[Number(row.key)]) * 100).toFixed(2)),\n                selectPerc: Number((Number(row.value)/Number(amountInSelection) * 100).toFixed(2))\n            });\n        }\n\n        \n        return clusterTable2;\n    }\n\n    /**\n     * Performs a query for records matching a sample and a chromosome.  To get all records matching a sample,\n     * regardless of chromosome, use the special chromosome name `DataWarehouse.ALL_CHRS_KEY`.  If either sample or\n     * chromosome are not present in the data, returns an empty list.\n     * \n     * @param sample sample name for which to find matching records\n     * @param chr chromosome name for which to find matching records\n     * @return a list of matching records\n     */\n    getRecords(sample: string, applyLog: boolean, implicitStart: number | null, implicitEnd: number | null, xScale: [number, number] | null, yScale: [number, number] | null): GenomicBin[] {\n        if(sample in this._sampleGroupedData) {\n            return this.filterRecordsByScales(this._sampleGroupedData[sample], applyLog, implicitStart, implicitEnd, xScale, yScale);\n        }\n        return [];\n    }\n\n    filterRecordsByScales(records: GenomicBin[], applyLog: boolean, implicitStart: number | null, implicitEnd: number | null, xScale: [number, number] | null, yScale: [number, number] | null) : GenomicBin[]{\n       \n       let dataKey : keyof Pick<GenomicBin, \"RD\" | \"logRD\"> = (applyLog) ? \"logRD\" : \"RD\"\n        if((implicitStart && implicitEnd) && xScale && yScale) {\n            return records.filter(record => record.genomicPosition > implicitStart \n                && record.genomicPosition < implicitEnd \n                && record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n        } else if((implicitStart && implicitEnd) && xScale) {\n            return records.filter(record => record.genomicPosition > implicitStart \n                && record.genomicPosition < implicitEnd \n                && record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                )\n        } else if((implicitStart && implicitEnd) && yScale) {\n             return records.filter(record => record.genomicPosition > implicitStart \n                 && record.genomicPosition < implicitEnd \n                 && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                 )\n         } else if(xScale && yScale) {\n            return records.filter(record => \n                record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n         } else if (xScale) {\n            return records.filter(record => \n                record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                )\n        } else if(yScale) {\n            return records.filter(record => \n                record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n        }\n\n        return records;\n        \n    }\n\n    getAllRecords() {\n        return this.allRecords;\n    }\n\n    getClusterTableInfo() {\n        return this.clusterTableInfo;\n    }\n\n    getFilteredClusters() {\n        return this._cluster_filters;\n    }\n\n    setbrushedBins(brushedBins: GenomicBin[]) {\n        this.brushedBins = brushedBins;\n        this.brushedCrossfilter = crossfilter(brushedBins);\n        this.brushedClusterDim = this.brushedCrossfilter.dimension((d:GenomicBin) => d.CLUSTER);\n    }\n\n    getBrushedBins() {\n        return this.brushedBins;\n    }\n\n    getClusterDim() {\n        return this._cluster_dim;\n    }\n    \n    /**\n     * Helper function for performing queries.\n     * \n     * @typeParam T type of value stored in the index\n     * @param index the index to query\n     * @param sample sample name for which to find matching records\n     * @param chr chromosome name for which to find matching records\n     * @return a list of matching records\n     */\n    private _getData<T>(index: IndexedBioData<T[]>, sample: string, chr: string, cluster: string): T[] {\n        const dataForSample = index[sample][cluster] || {};\n        return dataForSample[chr] || [];\n    }\n}\n","import React from \"react\";\nimport * as d3 from \"d3\";\n// @ts-ignore: Unreachable code error\nimport * as fc from \"d3fc\";\nimport _ from \"lodash\";\nimport memoizeOne from \"memoize-one\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {GenomicBin, GenomicBinHelpers} from \"../model/GenomicBin\";\nimport {webglColor, getRelativeCoordinates, niceBpCount } from \"../util\";\nimport \"./Scatterplot.css\";\nimport {DisplayMode} from \"../App\"\n\nconst PADDING = { // For the SVG\n    left: 60,\n    right: 20,\n    top: 35,\n    bottom: 60,\n};\n\nconst UNCLUSTERED_COLOR = \"#999999\";\nconst DELETED_COLOR = \"rgba(232, 232, 232, 1)\";\nconst UNCLUSTERED_ID = \"-1\";\nconst DELETED_ID = \"-2\";\nconst SCALES_CLASS_NAME = \"scatterplot-scale\";\nconst CIRCLE_GROUP_CLASS_NAME = \"circles\";\nconst CIRCLE_R = 1;\nconst TOOLTIP_OFFSET = 10; // Pixels\nlet nextCircleIdPrefix = 0;\n\ninterface Props {\n    parentCallBack: any;\n    data: GenomicBin[];\n    rdRange: [number, number];\n    yAxisToPlot: keyof Pick<GenomicBin, \"RD\" | \"logRD\">;\n    hoveredLocation?: ChromosomeInterval;\n    width: number;\n    height: number;\n    invertAxis: boolean;\n    onRecordsHovered: (record: GenomicBin | null) => void;\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    customColor: string;\n    col: string;\n    colors: string[];\n    assignCluster: boolean;\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    displayMode: DisplayMode;\n    onZoom: (newScales: any) => void;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    scales: any;\n    centroidPts: {cluster: number, point: [number, number]}[];\n    showCentroids: boolean;\n    \n}\n\ninterface State {\n    selectedCluster: string;\n}\n\nexport class Scatterplot extends React.Component<Props, State> {\n    static defaultProps = {\n        width: 400,\n        height: 302,\n        onNewCurveState: _.noop,\n        onRecordHovered: _.noop,\n    };\n\n    private _svg: SVGSVGElement | null;\n    private _circleIdPrefix: number;\n    private _clusters : string[];\n    private brushedNodes: Set<GenomicBin>;\n    private previous_brushed_nodes: Set<string>;\n    private quadTree: d3.Quadtree<GenomicBin>;\n    private _canvas: HTMLCanvasElement | null;\n    private _canvas2: HTMLCanvasElement | null;\n    private _currXScale: d3.ScaleLinear<number, number>;\n    private _currYScale: d3.ScaleLinear<number, number>;\n    private _original_XScale: d3.ScaleLinear<number, number>;\n    private _original_YScale: d3.ScaleLinear<number, number>;\n\n    private _original_transform: any;\n    private _current_transform: any;\n    private scatter: any;\n    private zoom: any;\n    //private selectedCluster: string;\n\n    constructor(props: Props) {\n        super(props);   \n        this._svg = null;\n        this._canvas = null;\n        this.scatter = null;\n        this._canvas2 = null;\n        this._circleIdPrefix = nextCircleIdPrefix;\n        nextCircleIdPrefix++;\n        this.computeScales = memoizeOne(this.computeScales);\n        this.handleMouseMove = this.handleMouseMove.bind(this);\n        this.onTrigger = this.onTrigger.bind(this);\n        this.onBrushedBinsUpdated = this.onBrushedBinsUpdated.bind(this);\n        this._clusters = this.initializeListOfClusters();\n        this.state = {\n            selectedCluster: (this._clusters.length > 0) ? this._clusters[0] : UNCLUSTERED_ID\n        }\n        this.brushedNodes = new Set();\n        this.previous_brushed_nodes = new Set();\n        this.onZoom = this.onZoom.bind(this);\n        this.resetZoom = this.resetZoom.bind(this);\n        this.zoom = null;\n       \n        const {bafScale, rdrScale} = this.computeScales(this.props.rdRange, props.width, props.height);\n        this._currXScale = bafScale;\n        this._currYScale = rdrScale;\n        this._original_XScale = this._currXScale;\n        this._original_YScale = this._currYScale;\n\n        let data : GenomicBin[] = props.data;\n        this.quadTree = d3\n            .quadtree<GenomicBin>()\n            .x((d : GenomicBin) => d.reverseBAF)\n            .y((d : GenomicBin)  => d[props.yAxisToPlot])\n            .addAll(data)\n\n        this._original_transform = d3.zoomIdentity.translate(0, 0).scale(1);\n        this._current_transform = this._original_transform;\n    }\n\n    initializeListOfClusters() : string[] {\n        let clusterTableData = this.props.clusterTableData;\n        clusterTableData.sort((a : any, b : any) => {\n            if (a.key > b.key) return 1;\n            if (a.key < b.key) return -1;\n            return 0;\n        })\n\n        this._clusters = [];\n        for(const obj of clusterTableData) {\n            this._clusters.push(obj.key);\n        }\n\n        while(this._clusters.length > 0 \n            && (this._clusters[0] === UNCLUSTERED_ID \n            || this._clusters[0] === DELETED_ID)) {\n            this._clusters.shift();\n        }\n\n        return this._clusters;\n    }\n\n    handleMouseMove(event: React.MouseEvent<SVGSVGElement>) {\n        // const {rdRange, width, height, curveState, onNewCurveState, invertAxis} = this.props;\n        const {x, y} = getRelativeCoordinates(event);\n        const hoveredRdBaf = {\n            rd: this._currYScale.invert(y),\n            baf: this._currXScale.invert(x)\n        };\n\n        if( hoveredRdBaf.baf > this._currXScale.domain()[0] && hoveredRdBaf.baf < this._currXScale.domain()[1] \n            && hoveredRdBaf.rd > this._currYScale.domain()[0] && hoveredRdBaf.rd < this._currYScale.domain()[1] ) {\n            \n            const radius = Math.abs(this._currXScale.invert(x) - this._currXScale.invert(x - 20));\n            this.props.onRecordsHovered(this.quadTree.find(hoveredRdBaf.baf, hoveredRdBaf.rd, radius) || null);\n        } else {\n            this.props.onRecordsHovered(null);\n        }\n    }\n\n    renderTooltipAtRdBaf(rd: number, baf: number, contents: JSX.Element | null) {\n        if (!contents) {\n            return null;\n        }\n\n        const top =  (this._currYScale(rd) || 0);\n        const left = ((this._currXScale(baf) || 0) + TOOLTIP_OFFSET);\n        const tooltipHeight = 150;\n        const tooltipWidth = 275;\n        \n        return <div\n            className=\"Scatterplot-tooltip\"\n            style={{\n                position: \"absolute\",\n                top: top - tooltipHeight, // Alternatively, this could be 0.5 - baf\n                left:  left,\n                width: tooltipWidth,\n                height: tooltipHeight,\n                pointerEvents: \"none\"\n            }}\n        >\n            {contents}\n        </div>;\n    }\n\n    renderTooltip() {\n        const {data, hoveredLocation, yAxisToPlot} = this.props;\n\n        if (!hoveredLocation) {\n            return null;\n        }\n        let hoveredRecords : GenomicBin[] = [];\n        hoveredRecords = data.filter(record => {\n            let currLoc = GenomicBinHelpers.toChromosomeInterval(record);\n            return (hoveredLocation.chr === currLoc.chr\n            && hoveredLocation.start === currLoc.start \n            && hoveredLocation.end === currLoc.end)}) //record.location.hasOverlap(hoveredLocation));\n\n        if(hoveredRecords.length === 0) {\n            hoveredRecords = data.filter(record => GenomicBinHelpers.toChromosomeInterval(record).hasOverlap(hoveredLocation))\n        }\n        if(hoveredRecords[0]) {\n            const x = this._currXScale(hoveredRecords[0].reverseBAF);\n            const y = this._currYScale(hoveredRecords[0][yAxisToPlot]);\n            \n            let range = this._currXScale.range();\n            let range2 = this._currYScale.range();\n            if (hoveredRecords.length === 1 && x && y && x > range[0] && x < range[1] && y < range2[0] && y > range2[1]) {\n                const record = hoveredRecords[0];\n                const recordLocation = GenomicBinHelpers.toChromosomeInterval(record);\n                return this.renderTooltipAtRdBaf(record[yAxisToPlot], record.reverseBAF, <React.Fragment>\n                    <p>\n                        <b>{recordLocation.toString()}</b><br/>\n                        ({niceBpCount(recordLocation.getLength())})\n                    </p>\n                    <div> RDR: {record[yAxisToPlot].toFixed(2)}</div>\n                    <div> 0.5 - BAF: {record.reverseBAF.toFixed(2)}</div>\n                    <div> Cluster ID: {record.CLUSTER}</div>\n                    {/* <div> Genome Position: {record.genomicPosition}</div> */}\n                    \n                </React.Fragment>);\n            } \n        }\n\n        return null;\n    }\n\n    render() {\n        \n        const {width, height} = this.props;\n        \n        let clusterOptions = this._clusters.map(clusterName =>\n            <option key={clusterName} value={clusterName} >{clusterName}</option>\n        );\n        \n        clusterOptions.unshift(<option key={UNCLUSTERED_ID} value={UNCLUSTERED_ID} >{UNCLUSTERED_ID}</option>);\n        clusterOptions.unshift(<option key={DELETED_ID} value={DELETED_ID} >{DELETED_ID}</option>);\n        \n        let scatterUI = <div ref={node => this.scatter= node} className=\"Scatterplot\" >\n                            \n                            <canvas\n                                ref={node => this._canvas = node}\n                                width={width}\n                                height={height}\n                                className={\"canvas\"}\n                                style={{position: \"absolute\", \n                                        top: PADDING.top, \n                                        zIndex: -4, \n                                        left: PADDING.left, \n                                        width: width-PADDING.left - PADDING.right, \n                                        height: height-PADDING.top-PADDING.bottom}}\n                            />\n                            <canvas\n                                ref={node => this._canvas2 = node}\n                                width={width}\n                                height={height}\n                                className={\"canvas\"}\n                                style={{position: \"absolute\", \n                                        top: PADDING.top, \n                                        zIndex: -1, \n                                        left: PADDING.left, \n                                        width: width-PADDING.left - PADDING.right, \n                                        height: height-PADDING.top-PADDING.bottom}}\n                            />\n                            <svg\n                                ref={node => this._svg = node}\n                                width={width} height={height}\n                                style={{zIndex: 100}}\n                                // preserveAspectRatio={'xMinYMin'}\n                                onMouseMove={this.handleMouseMove}\n                            ></svg>\n                            <div className=\"Scatterplot-tools\">\n                                <button id=\"reset\" onClick={this.resetZoom}>Reset View</button>\n                            </div>\n\n                            {this.renderTooltip()}\n                        </div>;\n        return scatterUI;\n    }\n\n    resetZoom() {\n        if(!this._svg) { return; }\n        this._currXScale = this._original_XScale;\n        this._currYScale = this._original_YScale;\n        const newScales = {xScale: this._currXScale.domain(), yScale: this._currYScale.domain()}\n        this.props.onZoom(newScales);\n        this.redraw();\n    }\n\n    componentDidMount() { \n        this.redraw();\n        this.forceHover(this.props.hoveredLocation);\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(!this.props.scales.xScale && !this.props.scales.yScale && prevProps.scales.xScale && prevProps.scales.yScale) {\n            this.resetZoom();\n        } else if((this.props.scales.xScale  // sync scales\n            && prevProps.scales.xScale\n            && this.props.scales.xScale[0] !== prevProps.scales.xScale[0] \n            && this.props.scales.xScale[1] !== prevProps.scales.xScale[1]) \n            || (this.props.scales.xScale  && !prevProps.scales.xScale)) {\n                this._currXScale.domain(this.props.scales.xScale);\n                if(this.props.scales.yScale) {\n                    this._currYScale.domain(this.props.scales.yScale);\n                }\n                this.redraw();\n        } else if((this.props.scales.yScale &&  prevProps.scales.yScale \n            && this.props.scales.yScale[0] !== prevProps.scales.yScale[0]\n            && this.props.scales.yScale[1] !== prevProps.scales.yScale[1])\n            || (this.props.scales.yScale  && !prevProps.scales.yScale)) {\n            if(this.props.scales.xScale) {\n                this._currXScale.domain(this.props.scales.xScale);\n            }\n            this._currYScale.domain(this.props.scales.yScale);\n            this.redraw();\n        } else if(this.props[\"assignCluster\"]) {\n            this.onTrigger(this.state.selectedCluster);\n            this.brushedNodes = new Set();\n        } else if (this.props.hoveredLocation !== prevProps.hoveredLocation) {\n            this.forceUnhover();\n            this.forceHover(this.props.hoveredLocation); \n        } else if (this.propsDidChange(prevProps, [\"showCentroids\", \"displayMode\", \"colors\", \"brushedBins\", \"width\", \"height\"])) {\n            let data : GenomicBin[] = this.props.data;\n            // Update quadtree so that when hovering works on new points that appear \n            // (when assigning to an existing cluster - all the points in that cluster show up even if it has been filtered out)\n            this.quadTree = d3\n                .quadtree<GenomicBin>()\n                .x((d : GenomicBin) => d.reverseBAF)\n                .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                .addAll(data)\n            this.redraw();\n            this.forceHover(this.props.hoveredLocation);\n        } else if((!(_.isEqual(this.props[\"data\"], prevProps[\"data\"])) || this.props.yAxisToPlot !== prevProps.yAxisToPlot)) {\n            const {bafScale, rdrScale} = this.computeScales(this.props.rdRange, this.props.width, this.props.height);\n\n            if((this._currXScale.domain()[0] === this._original_XScale.domain()[0] \n                && this._currXScale.domain()[1] === this._original_XScale.domain()[1]\n                && this._currYScale.domain()[0] === this._original_YScale.domain()[0]\n                && this._currYScale.domain()[1] === this._original_YScale.domain()[1])) {  \n                // When the sample filter changes, the y-axis max will also change so must recaculate the scales\n                // Original scales saves the scales to which we should reset the view\n                this._currXScale = bafScale;\n                this._currYScale = rdrScale;\n                this._original_XScale = this._currXScale;\n                this._original_YScale = this._currYScale;\n            } else { // If zoom is applied, then update original scales but don't change current zoom\n                // CASE 1: going to log\n                if(this.props.yAxisToPlot !== prevProps.yAxisToPlot){\n                    let currentYDomain = this._currYScale.domain();\n                    if (this.props.yAxisToPlot===\"logRD\") {  \n                        if(currentYDomain[0] <= 0) {\n                            currentYDomain[0] = 0.1;\n                        }\n                        if(currentYDomain[1] <= 0) {\n                            currentYDomain[1] = 0.1;\n                        }\n                        const newYDomain = [Math.log2(currentYDomain[0]), Math.log2(currentYDomain[1])];\n                        this._currYScale = d3.scaleLinear().domain(newYDomain).range(this._currYScale.range());\n                    } else {\n                        const newYDomain = [Math.pow(2, currentYDomain[0]), Math.pow(2, currentYDomain[1])];\n                        this._currYScale = d3.scaleLinear().domain(newYDomain).range(this._currYScale.range());\n                    }\n                   \n                } \n                this._original_XScale = bafScale;\n                this._original_YScale = rdrScale;\n            }\n            \n            let data : GenomicBin[] = this.props.data;\n            this.quadTree = d3\n                .quadtree<GenomicBin>()\n                .x((d : GenomicBin) => d.reverseBAF)\n                .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                .addAll(data)\n\n            let newScales = {xScale: this._currXScale.domain(), yScale: this._currYScale.domain()}\n            this.props.onZoom(newScales);\n            this.redraw();\n            this.forceHover(this.props.hoveredLocation);\n        } \n\n        if(this.props.clusterTableData !== prevProps.clusterTableData) {\n            this.initializeListOfClusters();\n        }\n    }\n\n    computeScales(rdRange: [number, number], width: number, height: number, \n                    bafRange?: [number, number], useLowerBound?: boolean) {\n        let bafScaleRange = [PADDING.left, width - PADDING.right];\n        let rdrScaleRange = [height - PADDING.bottom, PADDING.top];\n        const rdLowerBound = (useLowerBound) ? rdRange[0] :((this.props.applyLog) ? -2 : 0);\n        let baf = bafRange ? bafRange : [-.0001, 0.5001] // .0001 allows for points exactly on the axis to still be seen\n        \n        return {\n            bafScale: d3.scaleLinear()\n                .domain(baf)\n                .range(bafScaleRange),\n            rdrScale: d3.scaleLinear()\n                .domain([rdLowerBound, rdRange[1]])\n                .range(rdrScaleRange)\n        };\n    }\n\n    onTrigger = (selectedCluster: string | number) => {\n        this.props.parentCallBack(selectedCluster);\n    }\n\n    onBrushedBinsUpdated = (brushedNodes: GenomicBin[]) => {\n        this.props.onBrushedBinsUpdated(brushedNodes);\n    }\n\n    onZoom(newScales: any) {\n        this.props.onZoom(newScales);\n    }\n\n    redraw() {\n        if (!this._svg || !this._canvas || !this.scatter || !this._canvas2) {\n            return;\n        }\n        let self = this;\n        const {width, height, customColor, brushedBins, data, colors, yAxisToPlot, centroidPts} = this.props;\n        let {displayMode} = this.props;\n        let xScale = this._currXScale;\n        let yScale = this._currYScale;\n        let xLabel = \"Allelic Imbalance (0.5 - BAF)\";\n        let yLabel = yAxisToPlot === \"RD\" ? \"RDR\" : \"log RDR\";\n        \n        const svg = d3.select(this._svg);\n        \n        // Remove any previous scales\n        svg.selectAll(\".\" + SCALES_CLASS_NAME).remove();\n\n        // X axis stuff\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"x\", _.mean(this._currXScale.range()))\n            .attr(\"y\", height - PADDING.bottom + 40)\n            .style(\"text-anchor\", \"middle\")\n            .text(xLabel);\n\n        // Y axis stuff\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"y\", PADDING.left-40)\n            .attr(\"x\", 0-_.mean(this._currYScale.range()))\n            .attr(\"transform\", `rotate(-90)`)\n            .style(\"text-anchor\", \"middle\")\n            .text(yLabel);\n        \n        let xAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale))\n        \n        let yAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(${PADDING.left}, 0)`)\n            .call(d3.axisLeft(scale))\n            \n\n        let previous : string[] = [];\n        \n        brushedBins.forEach(d => previous.push(GenomicBinHelpers.toChromosomeInterval(d).toString()))\n        this.previous_brushed_nodes = new Set(previous);\n        \n        const previous_brushed_nodes = this.previous_brushed_nodes;\n\n        const gx = svg.append(\"g\");\n        const gy = svg.append(\"g\");\n        let z = d3.zoomIdentity;\n        const zoomX : any = d3.zoom().scaleExtent([0, 100]);\n        const zoomY : any = d3.zoom().scaleExtent([0, 100]);\n        const tx = () => d3.zoomTransform(gx.node() as Element);\n        const ty = () => d3.zoomTransform(gy.node() as Element);\n        gx.call(zoomX).attr(\"pointer-events\", \"none\");\n        gy.call(zoomY).attr(\"pointer-events\", \"none\");\n        \n        const zoom : any = d3.zoom().on(\"zoom\", () => {\n            try {\n                const t = d3.event.transform;\n                const k = t.k / z.k;\n                const point = center(d3.event);\n\n                // is it on an axis?\n                const doX = point[0] > xScale.range()[0];\n                const doY = point[1] < yScale.range()[0];\n                if(displayMode === DisplayMode.zoom || !(doX && doY)) {\n                    if (k === 1) {\n                    // pure translation?\n                    doX && zoomX && k && point && gx && gx.call(zoomX.translateBy, (t.x - z.x) / tx().k, 0);\n                    doY && zoomY && k && point && gy && gy.call(zoomY.translateBy, 0, (t.y - z.y) / ty().k);\n                    } else {\n                    // if not, we're zooming on a fixed point\n                    doX && zoomX && k && point && gx && gx.call(zoomX.scaleBy, k, point);\n                    doY && zoomY && k && point && gy && gy.call(zoomY.scaleBy, k, point);\n                    }\n                }\n            \n                z = t;\n                redraw();\n            } catch(error) {\n                console.log(\"Error: \", error);\n            }\n          }).on(\"end\", () => {\n                let newScales = {xScale: self._currXScale.domain(), yScale: self._currYScale.domain()}\n                self.props.onZoom(newScales);\n            }\n        );\n        \n        function center(event : any) {\n            if (event.sourceEvent) {\n                return [event.sourceEvent.layerX, event.sourceEvent.layerY];\n            }\n            return [width / 2, height / 2];\n        }\n\n        const gl = this._canvas.getContext(\"webgl\")!;\n        const gl2 = this._canvas2.getContext(\"webgl\")!;\n        gl.clearColor(0,0,0,1);\n        gl2.clearColor(0, 0, 0, 1);\n\n        let languageFill = (d:any) => {\n            return webglColor(chooseColor(d));\n        };\n        \n        let newData :GenomicBin[]= [];\n        for(const d of data) {\n            if(!previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                newData.push(d);\n            }\n        }\n\n        for(const d of data) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                newData.push(d);\n            }\n        }\n        \n        let fillColor = fc.webglFillColor().value(languageFill).data(newData);\n        let pointSeries = fc\n            .seriesWebglPoint()\n            .xScale(self._currXScale)\n            .yScale(self._currYScale)\n            .size(3)\n            .crossValue((d : any) => d.reverseBAF)\n            .mainValue((d : any) => d[yAxisToPlot])\n            .context(gl);\n        \n        pointSeries.decorate((program:any) => {\n                fillColor(program)\n                gl.depthFunc(gl.NEVER);\n                gl.disable(gl.DEPTH_TEST);\n                \n        });\n\n\n        svg\n        .append(\"clipPath\")\n        .attr(\"id\", \"clip\")\n        .append(\"rect\")\n            .attr(\"x\", PADDING.left)\n            .attr(\"y\", PADDING.top)\n            .attr(\"width\", width - PADDING.right - PADDING.left)\n            .attr(\"height\", height - PADDING.bottom - PADDING.top);\n\n        // Create event-rect that allows for svg points to be overlayed under mouse pointer\n        svg\n            .append(\"g\")\n            .classed(\"eventrect\", true)\n            .append(\"rect\")\n                .attr(\"x\", PADDING.left)\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width - PADDING.right - PADDING.left)\n                .attr(\"height\", height - PADDING.bottom - PADDING.top)\n                .style(\"fill\", \"none\")\n                .style(\"pointer-events\", \"all\")\n                .attr(\"clip-path\", \"url(#clip)\");\n         \n       \n\n        function redraw() {\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.clearColor(255,255,255,1);\n            const xr = tx().rescaleX(xScale);\n            const yr = ty().rescaleY(yScale);\n        \n            gx.call(xAx , xr);\n            gy.call(yAx, yr);\n            \n            self._currXScale = xr;\n            self._currYScale = yr;\n\n            if(self._canvas) {\n                pointSeries\n                    .xScale(self._currXScale)\n                    .yScale(self._currYScale)\n                pointSeries(newData);\n            }\n            \n\n            svg.select(\".Centroids\").remove();\n            if(self.props.showCentroids) {\n                svg.select(\".eventrect\")\n                    .append(\"g\")\n                    .attr(\"clip-path\", \"url(#clip)\")\n                    .classed(\"Centroids\", true)\n                    .selectAll(\"path\")\n                    .data(centroidPts)\n                    .enter()\n                    .append(\"path\")\n                    .attr(\"class\", \"point\")\n                    .attr(\"d\", d3.symbol().type(d3.symbolCross))\n                    .attr(\"fill\", d => chooseColor2(d.cluster))\n                    .attr(\"fill-opacity\", 1)\n                    .attr(\"stroke-width\", 2)\n                    .attr(\"stroke\", \"black\") \n                    .attr(\"transform\", function(d) {\n                        return \"translate(\" + self._currXScale(d.point[0]) + \",\" + self._currYScale(d.point[1]) + \")\"; \n                    });\n            }\n        }\n        \n        this._canvas.width = width;\n        this._canvas.height = height;\n\n        redraw();\n\n        \n\n        if(displayMode === DisplayMode.select || displayMode === DisplayMode.erase) {\n            const brush = d3.brush()\n            .keyModifiers(false)\n            .extent([[PADDING.left - 2*CIRCLE_R, PADDING.top - 2*CIRCLE_R], \n                    [this.props.width - PADDING.right + 2*CIRCLE_R , this.props.height - PADDING.bottom + 2*CIRCLE_R]])\n                    .on(\"end\", () => {\n                        this.updatePoints(d3.event)\n                        svg.selectAll(\".brush\").remove();\n                        this.onBrushedBinsUpdated([...this.brushedNodes]);\n                    });\n            \n              \n            // attach the brush to the chart\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n\n        } else if(displayMode === DisplayMode.zoom) {\n            svg.selectAll(\".brush\").remove();\n        } else if(displayMode === DisplayMode.boxzoom) {\n            const brush = d3.brush()\n            .keyModifiers(false)\n            .extent([[PADDING.left - 2*CIRCLE_R, PADDING.top - 2*CIRCLE_R], \n                    [this.props.width - PADDING.right + 2*CIRCLE_R , this.props.height - PADDING.bottom + 2*CIRCLE_R]])\n                    .on(\"start brush\", () => this.updatePoints(d3.event))\n                    .on(\"end\", () => {\n                        svg.selectAll(\".brush\").remove();\n                        brush_endEvent();\n                });\n               \n            // attach the brush to the chart\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n        }\n\n        svg.call(zoom).call(zoom.transform, d3.zoomIdentity.scale(1.0));\n\n        function brush_endEvent() {\n            if(!self._svg) {return;}\n            const {data} = self.props;\n            if (data) {\n                const { selection } = d3.event;\n                if(selection) { \n                    let newRdRange : [number, number] = [Number(self._currYScale.invert(selection[1][1])), \n                                                        Number(self._currYScale.invert(selection[0][1]))];\n                    let newBafRange : [number, number] = [Number(self._currXScale.invert(selection[0][0])), \n                                                            Number(self._currXScale.invert(selection[1][0]))];\n                    const {bafScale, rdrScale} = self.computeScales(newRdRange, width, height, newBafRange, true);\n                    self._currXScale = bafScale;\n                    self._currYScale = rdrScale;\n                    \n                    self.redraw();\n\n                    let newScales = {xScale: self._currXScale.domain(), yScale: self._currYScale.domain()}\n                    self.props.onZoom(newScales);\n                }\n            }\n        }\n        \n        function chooseColor(d: GenomicBin) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                return customColor;\n            } else if (d.CLUSTER === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(d.CLUSTER === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = d.CLUSTER;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n\n        function chooseColor2(c: number) {\n            if (c === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(c === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = c;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n    \n     }\n\n     updatePoints(event : any) {\n        if(!this._svg) {return;}\n        const {brushedBins, data, yAxisToPlot, displayMode} = this.props;\n        if (data) {\n            const { selection } = d3.event\n            if(selection) {   \n\n                function rectContains(rect : any, point : any) {\n                    const X = 0;\n                    const Y = 1;\n                    const TOP_LEFT = 0;\n                    const BOTTOM_RIGHT = 1;\n                    return rect[TOP_LEFT][X] <= point[X] && point[X] <= rect[BOTTOM_RIGHT][X] &&\n                           rect[TOP_LEFT][Y] <= point[Y] && point[Y] <= rect[BOTTOM_RIGHT][Y];\n                }\n\n                let brushNodes = data.filter(d => rectContains(selection, [this._currXScale(d.reverseBAF), this._currYScale(d[yAxisToPlot])]));\n                \n                if (brushNodes) {\n                    if(displayMode === DisplayMode.select) {\n                        brushNodes = _.uniq(_.union(brushNodes, brushedBins));  \n                    } else if(displayMode === DisplayMode.erase) {\n                        brushNodes = _.difference(brushedBins, brushNodes);\n                    }\n\n                    this.brushedNodes = new Set(brushNodes);                  \n                } \n            } else {\n                this.brushedNodes = new Set([]);\n            }\n        }\n    }\n\n    getElementsForGenomeLocation(hoveredLocation?: ChromosomeInterval) {\n        if (!this._svg || !hoveredLocation || !this._canvas) {\n            return [];\n        }\n        const {data, yAxisToPlot} = this.props;\n\n        let hoveredRecords : GenomicBin[] = [];\n        hoveredRecords = data.filter(record => {\n            let currLoc = GenomicBinHelpers.toChromosomeInterval(record);\n            return (hoveredLocation.chr === currLoc.chr\n            && hoveredLocation.start === currLoc.start \n            && hoveredLocation.end === currLoc.end)\n        })\n        \n        let range = this._currXScale.range();\n        let range2 = this._currYScale.range();\n        if(hoveredRecords.length === 0) {\n            \n            hoveredRecords = data.filter(record => GenomicBinHelpers.toChromosomeInterval(record).hasOverlap(hoveredLocation))\n            hoveredRecords = hoveredRecords.filter(record => {\n                const x = this._currXScale(record.reverseBAF);\n                const y = this._currYScale(record[yAxisToPlot]);\n                return x && y && x > range[0] && x < range[1] && y < range2[0] && y > range2[1]\n            })\n        }\n    \n        let svg = d3.select(this._svg);\n        svg.select(\".\" + CIRCLE_GROUP_CLASS_NAME).remove();\n        svg.select(\".eventrect\")\n            .append(\"g\")\n            .classed(CIRCLE_GROUP_CLASS_NAME, true)\n            .selectAll(\"circle\")\n                .data(hoveredRecords)\n                .enter()\n                .append(\"circle\")\n                    .attr(\"id\", d => this._circleIdPrefix + GenomicBinHelpers.toChromosomeInterval(d).toString())\n                    .attr(\"cx\", d => this._currXScale(d.reverseBAF) || 0)\n                    .attr(\"cy\", d => this._currYScale(d[yAxisToPlot]) || 0) // Alternatively, this could be 0.5 - baf\n                    .attr(\"r\", 3)\n                    .attr(\"fill\", d => {\n                        if(this.previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                            return this.props.customColor;\n                        } else if (d.CLUSTER === -1){\n                            return UNCLUSTERED_COLOR;\n                        } else if(d.CLUSTER === -2){\n                            return DELETED_COLOR;\n                        } else {\n                            const cluster = d.CLUSTER;\n                            const col_index = cluster % this.props.colors.length;\n                            return this.props.colors[col_index];\n                        }\n                        \n                    })\n                    .attr(\"fill-opacity\", 1)\n                    .attr(\"stroke-width\", 2)\n                    .attr(\"stroke\", \"black\");\n\n    }\n\n    forceHover(genomeLocation?: ChromosomeInterval) {\n        this.getElementsForGenomeLocation(genomeLocation);\n    }\n\n    forceUnhover() {\n        if(this._svg) {\n            d3.select(this._svg).select(\".\" + CIRCLE_GROUP_CLASS_NAME).remove();\n        }\n    }\n}","import React from 'react';\nimport { Coordinate, getRelativeCoordinates } from '../util';\n\nimport './DivWithBullseye.css';\n\ninterface State {\n    mouseCoordinates: Coordinate | null;\n}\n\n/**\n * Like a <div> in every way, except it has \"bullseye\", dotted lines that track where the mouse is.\n * \n * @author Silas Hsu\n */\nexport class DivWithBullseye extends React.Component<React.HTMLAttributes<HTMLDivElement>, State> {\n    constructor(props: React.HTMLAttributes<HTMLDivElement>) {\n        super(props);\n        this.state = {\n            mouseCoordinates: null\n        };\n\n        this.storeMouseCoordinates = this.storeMouseCoordinates.bind(this);\n        this.clearMouseCoordinates = this.clearMouseCoordinates.bind(this);\n    }\n\n    /**\n     * Stores a mouse event's coordinates in state.\n     * \n     * @param {MouseEvent} event - mousemove event whose coordinates to store\n     */\n    storeMouseCoordinates(event: React.MouseEvent<HTMLDivElement>) {\n        this.setState({mouseCoordinates: getRelativeCoordinates(event)});\n        if (this.props.onMouseMove) {\n            this.props.onMouseMove(event);\n        }\n    }\n\n    /**\n     * Clears stored mouse event coordinates.\n     * \n     * @param {MouseEvent} event - mouseleave event that triggered this callback\n     */\n    clearMouseCoordinates(event: React.MouseEvent<HTMLDivElement>) {\n        this.setState({mouseCoordinates: null});\n        if (this.props.onMouseLeave) {\n            this.props.onMouseLeave(event);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    render() {\n        const {onMouseMove, onMouseLeave, style, children, ...otherProps} = this.props;\n        // Default `position: relative` so the bullseye looks right\n        const mergedStyle = Object.assign({position: 'relative'}, style);\n        return (\n        <div\n            onMouseMove={this.storeMouseCoordinates}\n            onMouseLeave={this.clearMouseCoordinates}\n            style={mergedStyle}\n            {...otherProps}\n        >\n            {children}\n            {this.state.mouseCoordinates && <Bullseye where={this.state.mouseCoordinates} />}\n        </div>\n        );\n    }\n}\n\n/**\n * The actual intersecting lines that form the bullseye.  Uses prop `where`, an object with props `x` and `y`.\n * \n * @param {Object} props - props as specified by React\n * @return {JSX.Element} - element to render\n */\nfunction Bullseye(props: {where: Coordinate}) {\n    const {x, y} = props.where;\n    const horizontalLineStyle = {\n        top: y - 1,\n        willChange: \"top\",\n    };\n    const verticalLineStyle = {\n        left: x - 1,\n        willChange: \"left\",\n    };\n    return (\n        <React.Fragment>\n            <div className=\"Bullseye-horizontal-line\" style={horizontalLineStyle} />\n            <div className=\"Bullseye-vertical-line\" style={verticalLineStyle} />\n        </React.Fragment>\n    );\n}\n","import React from \"react\";\nimport _ from \"lodash\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { Scatterplot } from \"./Scatterplot\";\nimport { DivWithBullseye } from \"./DivWithBullseye\";\nimport \"./SampleViz.css\";\nimport {DisplayMode} from \"../App\"\nimport { GenomicBin, GenomicBinHelpers } from \"../model/GenomicBin\";\n\ninterface Props {\n    parentCallBack: any;\n    data: GenomicBin[];\n    chr: string;\n    cluster: string;\n    initialSelectedSample: string;\n    initialSelectedCluster?: string;\n    width?: number;\n    height?: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null, record?: GenomicBin | null) => void;\n    selectedSample: string;\n    onSelectedSample: any;\n    invertAxis?: boolean;\n    customColor: string;\n    colors: string[];\n    assignCluster: boolean;\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    dispMode: DisplayMode;\n    onZoom: (newScales: any) => void;\n    onRemovePlot: any;\n    rdRange: [number, number];\n    plotId: number;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    implicitRange: [number, number] | null;\n    scales: any;\n    centroidPts: {cluster: number, point: [number, number]}[]\n    showCentroids: boolean;\n}\n\ninterface State {\n    selectedSample: string;\n\n}\n\nexport class SampleViz2D extends React.Component<Props, State> {\n    static defaultProps = {\n        onLocationHovered: _.noop,\n        invertAxis: false,\n        customColor: \"#1b9e77\"\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            selectedSample: props.initialSelectedSample\n        };\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleRecordsHovered = this.handleRecordsHovered.bind(this);\n        this.handleCallBack = this.handleCallBack.bind(this);\n        this.handleUpdatedBrushedBins = this.handleUpdatedBrushedBins.bind(this);\n        this.onRemovePlot = this.onRemovePlot.bind(this);\n    }\n\n    handleSelectedSampleChanged(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedSample: event.target.value});\n        this.props.onSelectedSample(event.target.value);\n    }\n\n    handleRecordsHovered(record: GenomicBin | null) {\n        const location = record ? GenomicBinHelpers.toChromosomeInterval(record) : null;\n        this.props.onLocationHovered(location);\n    }\n\n    handleCallBack = (childData : GenomicBin[]) => {\n        this.props.parentCallBack(childData);\n    }\n\n    handleUpdatedBrushedBins(brushedBins: GenomicBin[]) {\n        this.props.onBrushedBinsUpdated(brushedBins);\n    }\n\n    onRemovePlot() {\n        this.props.onRemovePlot(this.props.plotId);\n    }\n    \n    render() {\n        const {data, width, height, hoveredLocation, invertAxis, customColor, assignCluster, \n                brushedBins, updatedBins, dispMode, onZoom, rdRange, clusterTableData, \n                applyLog, scales, centroidPts, showCentroids} = this.props;\n\n        return <div className=\"SampleViz-scatter\">\n            <DivWithBullseye className=\"SampleViz-pane\">\n                <Scatterplot\n                    parentCallBack = {this.handleCallBack}\n                    data={data}\n                    rdRange={rdRange}\n                    width={width}\n                    height={height}\n                    hoveredLocation={hoveredLocation}\n                    onRecordsHovered={this.handleRecordsHovered}\n                    invertAxis= {invertAxis || false} \n                    customColor= {customColor}\n                    colors = {this.props.colors}\n                    col = {this.props.colors[0]}\n                    assignCluster= {assignCluster} \n                    onBrushedBinsUpdated= {this.handleUpdatedBrushedBins}\n                    brushedBins= {brushedBins}\n                    updatedBins= {updatedBins}\n                    displayMode = {dispMode}\n                    onZoom = {onZoom}\n                    clusterTableData = {clusterTableData}\n                    applyLog = {applyLog}\n                    yAxisToPlot = {applyLog ? \"logRD\" : \"RD\"}\n                    onClusterSelected ={this.props.onClusterSelected}\n                    scales={scales}\n                    centroidPts={centroidPts}\n                    showCentroids={showCentroids}\n                    />\n            </DivWithBullseye>\n        </div>;\n    }\n}\n","import React from \"react\";\nimport * as d3 from \"d3\";\n// @ts-ignore: Unreachable code error\nimport * as fc from \"d3fc\";\nimport _ from \"lodash\";\nimport memoizeOne from \"memoize-one\";\nimport { GenomicBin, GenomicBinHelpers } from \"../model/GenomicBin\";\nimport { Genome, Chromosome } from \"../model/Genome\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {webglColor, getRelativeCoordinates, niceBpCount } from \"../util\";\nimport { DisplayMode } from \"../App\";\nimport \"./LinearPlot.css\";\nimport { Gene } from \"../model/Gene\";\n\nconst SCALES_CLASS_NAME = \"linearplot-scale\";\nconst UNCLUSTERED_COLOR = \"#999999\";\nconst DELETED_COLOR = \"rgba(232, 232, 232, 1)\";\nconst PADDING = { // For the SVG\n    left: 50,\n    right: 10,\n    top: 10,\n    bottom: 35,\n};\n\nfunction findChrNumber(chr: string) {\n    const match = chr.match(/\\d+/);\n    if (!match) {\n        return chr;\n    } else {\n        return match[0];\n    }\n}\n\ninterface Props {\n    data: GenomicBin[];\n    chr: string;\n    dataKeyToPlot: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"reverseBAF\" | \"BAF\">;\n    applyLog: boolean;\n    width: number;\n    height: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null) => void;\n    brushedBins: GenomicBin[];\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    genome: Genome;\n    yLabel?: string;\n    yMin: number;\n    yMax: number;\n    implicitStart : number | null;\n    implicitEnd : number | null;\n    customColor: string;\n    colors: string[];\n    clusterTableData: any;\n    displayMode: DisplayMode;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    onZoom: (newScales: any) => void;\n    driverGenes: Gene[] | null;\n    handleDriverGenesChange: (sentGene: {gene: Gene | null, destination: string | null}) => void;\n    driverGeneUpdate: {gene: Gene | null, destination: string | null};\n}\n\nexport class LinearPlot extends React.PureComponent<Props> {\n    static defaultProps = {\n        width: 600,\n        height: 150,\n        onLocationHovered: _.noop\n    };\n\n    private _svg: SVGSVGElement | null;\n    private _canvas: HTMLCanvasElement | null;\n    private _clusters: string[];\n    private brushedNodes: Set<GenomicBin>;\n    private _currXScale: d3.ScaleLinear<number, number>;\n    private _currYScale: d3.ScaleLinear<number, number>;\n    private _original_XScale: d3.ScaleLinear<number, number>;\n    private _original_YScale: d3.ScaleLinear<number, number>;\n    private previewDriver: Gene | null;\n    private lockedDrivers: Set<Gene>;\n\n    constructor(props: Props) {\n        super(props);\n        this._svg = null;\n        this._canvas = null;\n        this.getXScale = memoizeOne(this.getXScale);\n        this.handleMouseMove = this.handleMouseMove.bind(this);\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\n        this._clusters = this.initializeListOfClusters();\n        this.brushedNodes = new Set();\n        this._currXScale = this.getXScale(props.width, props.genome, props.chr, this.props.implicitStart, this.props.implicitEnd);\n        this._currYScale = d3.scaleLinear()\n            .domain([this.props.yMin, this.props.yMax])\n            .range([this.props.height - PADDING.bottom, PADDING.top]);\n        this._original_XScale = this._currXScale;\n        this._original_YScale = this._currYScale;\n        this.previewDriver = null;\n        this.lockedDrivers = new Set();\n    } \n\n    initializeListOfClusters() : string[] {\n        let collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});\n        let clusters = [...new Set(this.props.data.map(d => String(d.CLUSTER)))].sort(collator.compare);\n        if(clusters[0] === \"-2\") {\n            clusters.shift();\n        }\n        if(clusters[0] === \"-1\") {\n            clusters.shift();\n        }\n        return clusters;  \n    }\n\n    componentDidMount() {\n        this.redraw();\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.driverGeneUpdate.gene !== null) {\n            if(this.props.driverGeneUpdate.destination === this.props.dataKeyToPlot) {\n                if(this.lockedDrivers.has(this.props.driverGeneUpdate.gene)) {\n                    this.lockedDrivers.delete(this.props.driverGeneUpdate.gene);\n                } else {\n                    this.lockedDrivers.add(this.props.driverGeneUpdate.gene);\n                }\n                this.props.handleDriverGenesChange({gene: null, destination: null});\n            }\n        }\n\n        if(this.propsDidChange(prevProps, [\"chr\"])) {\n            if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\") {\n                this.props.onLinearPlotZoom(null, null, true);\n            } else {\n                this.props.onLinearPlotZoom(null, null, false);\n            }\n\n        } else if (this.propsDidChange(prevProps, [\"driverGenes\", \"displayMode\", \"implicitEnd\", \"implicitStart\", \"yMin\", \"yMax\", \"colors\", \"brushedBins\", \"width\", \"height\", \"chr\"])) {\n            if(this.props[\"brushedBins\"].length === 0)\n                this._clusters = this.initializeListOfClusters();\n            this.redraw();\n        } else if(!(_.isEqual(this.props[\"data\"], prevProps[\"data\"])) || this.props[\"dataKeyToPlot\"] !== prevProps[\"dataKeyToPlot\"]) {\n            this.redraw();\n        }\n    }\n\n    getXScale(width: number, genome: Genome, chr?: string, implicitStart ?: number | null, implicitEnd ?: number | null) {\n        let domain = [0, 0];\n        if(implicitStart != null && implicitEnd != null) {\n            domain[0] = implicitStart;\n            domain[1] = implicitEnd;\n        } else if (!chr) { // No chromosome specified: X domain is entire genome\n            domain[1] = genome.getLength();\n        } else { // Chromosome specified: X domain is length of one chromosome\n            domain[0] = genome.getChrStartMap()[chr];\n            domain[1] = domain[0] + genome.getLength(chr);\n        }\n\n        return d3.scaleLinear()\n            .domain(domain)\n            .range([PADDING.left, width - PADDING.right]);\n    }\n\n    createNewBrush() {\n        const svg = d3.select(this._svg);\n        const brush = d3.brush()\n        .keyModifiers(true)\n        .extent([[PADDING.left, PADDING.top], \n                [this.props.width - PADDING.right, this.props.height - PADDING.bottom]])\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    \n                });\n                \n        // attach the brush to the chart\n        svg.append('g')\n            .attr('class', 'brush')\n            .call(brush);\n    }\n\n    redraw() {\n        if (!this._svg) {\n            return;\n        }\n\n        let self = this;\n        const {data, width, height, genome, chr, dataKeyToPlot, \n            yMin, yMax, yLabel, customColor, brushedBins, colors, displayMode, driverGenes} = this.props;\n\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd); // Full genome implicit scale\n        const yScale =\n            d3.scaleLinear()\n            .domain([yMin, yMax])\n            .range([height - PADDING.bottom, PADDING.top]);\n\n        const chromosomes = genome.getChromosomeList();\n        let chrs: Chromosome[]= [];\n        let chrStarts = genome.getChrStartMap();\n        for(let chr of chromosomes) {\n            let start = chrStarts[chr.name];\n            if(start >= xScale.domain()[0] && start <= xScale.domain()[1]) {\n                chrs.push(chr);\n            }\n        }\n\n        const svg = d3.select(this._svg);\n\n        // Remove any previous scales\n        svg.selectAll(\".\" + SCALES_CLASS_NAME).remove();\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"font-size\", 11)\n            .attr(\"x\", _.mean(xScale.range()))\n            .attr(\"y\", height - PADDING.bottom + 30)\n            .text(chr || genome.getName());\n\n        // Y axis stuff\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `rotate(-90, ${PADDING.left- 30}, ${_.mean(yScale.range())})`)\n            .text(yLabel || dataKeyToPlot)\n            .attr(\"y\", _.mean(yScale.range()));\n\n        let xAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale)\n                    .tickValues(genome.getChromosomeStarts2(chrs, scale.domain()[0], scale.domain()[1]))\n                    .tickFormat((unused, i) => findChrNumber(chrs[i].name)))\n        \n        let xAx2 = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale)\n                    .tickFormat(baseNum => {\n                        return niceBpCount(Number(baseNum.valueOf()), 0, chrStarts[chr])\n                    }))\n        \n\n        let yAx = (g : any, scale : any) => g\n                    .classed(SCALES_CLASS_NAME, true)\n                    .attr(\"transform\", `translate(${PADDING.left}, 0)`)\n                    .call(d3.axisLeft(scale).ticks((scale.range()[0] - scale.range()[1]) / 15))\n                    \n        const gx = svg.append(\"g\");\n        const gy = svg.append(\"g\");\n        let z = d3.zoomIdentity;\n        const zoomX : any = d3.zoom().scaleExtent([0, 100]);\n        const zoomY : any = d3.zoom().scaleExtent([0, 100]);\n        const tx = () => d3.zoomTransform(gx.node() as Element);\n        const ty = () => d3.zoomTransform(gy.node() as Element);\n        gx.call(zoomX).attr(\"pointer-events\", \"none\");\n        gy.call(zoomY).attr(\"pointer-events\", \"none\");\n\n        const zoom : any = d3.zoom().on(\"zoom\", () => {\n            try {\n                const t = d3.event.transform;\n                const k = t.k / z.k;\n                const point = center(d3.event);\n\n                // is it on an axis?\n                const doX = point[0] > xScale.range()[0];\n                const doY = point[1] < yScale.range()[0];\n\n                if(displayMode === DisplayMode.zoom || !(doX && doY)) {\n                    if (k === 1) {\n                    // pure translation?\n                        doX && zoomX && k && point && gx && gx.call(zoomX.translateBy, (t.x - z.x) / tx().k, 0);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.translateBy, 0, (t.y - z.y) / ty().k);\n                    } else {\n                        // if not, we're zooming on a fixed point\n                        doX && zoomX && k && point && gx && gx.call(zoomX.scaleBy, k, point);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.scaleBy, k, point);\n                    }\n                }\n                z = t;\n                redraw();\n            } catch(error) {\n                console.log(\"Error: \", error);\n            }\n          }).on(\"end\", () => {\n                if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\") {\n                    self.props.onLinearPlotZoom([self._currXScale.domain()[0], self._currXScale.domain()[1]], [self._currYScale.domain()[0], self._currYScale.domain()[1]], true);\n                } else {\n                    self.props.onLinearPlotZoom([self._currXScale.domain()[0], self._currXScale.domain()[1]], [self._currYScale.domain()[0], self._currYScale.domain()[1]], false);\n                }\n            }\n\n        );\n\n        function center(event : any) {\n            if (event.sourceEvent) {\n                return [event.sourceEvent.layerX, event.sourceEvent.layerY];\n            }\n            return [width / 2, height / 2];\n        }\n\n        if (!this._canvas) {\n            return;\n        }\n\n        this._canvas.width = 800;\n        this._canvas.height = 150;\n        let previous : string[] = [];\n        brushedBins.forEach(d => previous.push(GenomicBinHelpers.toChromosomeInterval(d).toString()));\n        let previous_brushed_nodes = new Set(previous);\n        \n        const gl = this._canvas.getContext(\"webgl\")!;\n        gl.clearColor(0,0,0,1);\n        let colorFill = (d:any) => {\n            return webglColor(chooseColor(d));\n        };\n        let fillColor = fc.webglFillColor().value(colorFill).data(this.props.data);\n        let pointSeries = fc\n                .seriesWebglPoint()\n                .size(3)\n                .crossValue((d : any) => genome.getImplicitCoordinates(GenomicBinHelpers.toChromosomeInterval(d)).getCenter())\n                .mainValue((d : any) => d[dataKeyToPlot])\n                .context(gl);\n        pointSeries.decorate((program:any) => fillColor(program));\n\n        svg\n            .append(\"clipPath\")\n            .attr(\"id\", \"clip2\")\n            .append(\"rect\")\n                .attr(\"x\", PADDING.left)\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width)\n                .attr(\"height\", height)\n                .attr(\"fill\", \"red\");\n\n        // Create event-rect that allows for svg points to be overlayed under mouse pointer\n        svg\n            .append(\"g\")\n            .classed(\"eventrect\", true)\n            .append(\"rect\")\n                .attr(\"x\", PADDING.left)\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width - PADDING.right - PADDING.left)\n                .attr(\"height\", height - PADDING.bottom - PADDING.top)\n                .style(\"fill\", \"none\")\n                .style(\"pointer-events\", \"all\")\n                .attr(\"clip-path\", \"url(#clip2)\");\n\n        var mouseover = function(d : Gene) {\n            self.previewDriver = d;\n        }\n\n        var mouseleave = function(d : Gene) {\n            self.previewDriver = null;\n        }\n\n\n        function redraw() {\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.clearColor(255,255,255,1);\n            const yr = ty().rescaleY(yScale);\n            gy.call(yAx, yr);\n            self._currYScale = yr;\n            if(!chr) {\n                const xr = tx().rescaleX(xScale);\n                gx.call(xAx , xr);\n                self._currXScale = xr;\n                pointSeries.xScale(xr).yScale(yr);\n            } else {\n                const xr = tx().rescaleX(xScale);\n                gx.call(xAx2 , xr);\n                self._currXScale = xr;\n                pointSeries.xScale(xr).yScale(yr);\n            }\n            \n            pointSeries(data);\n            if(driverGenes) {\n                \n                svg.select(\".Drivers\").remove();\n                svg.select(\".eventrect\")\n                        .append(\"g\")\n                        .attr(\"clip-path\", \"url(#clip2)\")\n                        .classed(\"Drivers\", true)\n                        .selectAll(\"circle\")\n                        .data(driverGenes)\n                            .enter()\n                            .append(\"circle\")\n                            .attr(\"class\", \"point\")\n                            .attr(\"d\", d3.symbol().type(d3.symbolCircle))\n                            .attr(\"fill\", \"red\")\n                            .attr(\"fill-opacity\", 1)\n                            .attr(\"stroke-width\", 2)\n                            .attr(\"r\", 2)\n                            .attr(\"transform\", function(d) {\n                                return \"translate(\" + self._currXScale(genome.getImplicitCoordinates(d.location).getCenter()) + \",\" + ((self._currYScale(yr.domain()[0]) || 0) + 3) + \")\"; \n                            })\n                            .on(\"mouseover\", mouseover)\n                            .on(\"mouseleave\", mouseleave )\n                            .on(\"click\", d => {\n                                let dest = \"\";\n                                if(dataKeyToPlot === \"reverseBAF\" && self.props.applyLog) {\n                                    dest = \"logRD\"\n                                } else if(dataKeyToPlot === \"reverseBAF\") {\n                                    dest = \"RD\"\n                                } else {\n                                    dest = \"reverseBAF\"\n                                }\n\n                                (self.lockedDrivers.has(d)) ? self.lockedDrivers.delete(d) : self.lockedDrivers.add(d);\n                                self.props.handleDriverGenesChange({gene: d, destination: dest});\n                            })\n            }\n        }\n\n        redraw();\n\n        function chooseColor(d: GenomicBin) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                return customColor;\n            } else if (d.CLUSTER === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(d.CLUSTER === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = d.CLUSTER;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n\n        let brush : any = null;\n        if(displayMode === DisplayMode.select || displayMode === DisplayMode.erase) {\n            brush = d3.brush()\n                .keyModifiers(false)\n                .extent([[PADDING.left, PADDING.top], \n                        [this.props.width, this.props.height - PADDING.bottom]])\n                .on(\"start brush\", () => {\n                    const {selection} = d3.event;\n                    if(selection && selection[0][0] !== selection[1][0] && selection[0][1] !== selection[1][1]) {\n                        function rectContains(rect : any, point : any) {\n                            const X = 0;\n                            const Y = 1;\n                            const TOP_LEFT = 0;\n                            const BOTTOM_RIGHT = 1;\n                            return rect[TOP_LEFT][X] <= point[X] && point[X] <= rect[BOTTOM_RIGHT][X] &&\n                                   rect[TOP_LEFT][Y] <= point[Y] && point[Y] <= rect[BOTTOM_RIGHT][Y];\n                        }\n                        \n                        let brushed : GenomicBin[] = data.filter(d => {\n                            const location = GenomicBinHelpers.toChromosomeInterval(d);\n                            const range = genome.getImplicitCoordinates(location);\n                            return rectContains(selection, [xScale(range.getCenter()), yScale(d[dataKeyToPlot])])\n                        });\n\n                        if (brushed) {\n                            if(displayMode === DisplayMode.select) {\n                                brushed = _.uniq(_.union(brushed, brushedBins));  \n                            } else if(displayMode === DisplayMode.erase) {\n                                brushed = _.difference(brushedBins, brushed);\n                            }\n        \n                            this.brushedNodes = new Set(brushed);                  \n                        }\n                    } else {\n                        this.brushedNodes = new Set([]);\n                    }\n                })\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    this.props.onBrushedBinsUpdated([...this.brushedNodes]);\n                });\n\n                svg.append('g')\n                    .attr('class', 'brush')\n                    .call(brush);\n        } else if(displayMode === DisplayMode.boxzoom || displayMode === DisplayMode.zoom) {\n            brush = d3.brushX()\n                .extent([[PADDING.left, PADDING.top], \n                        [this.props.width, this.props.height - PADDING.bottom]])\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    const {selection} = d3.event;\n                    try {\n                        const startEnd = {\n                            start: selection[0],\n                            end: selection[1]\n                        };\n                        const implicitStart = xScale.invert(startEnd.start);\n                        const implicitEnd = xScale.invert(startEnd.end);\n                    \n                        if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\") {\n                            this.props.onLinearPlotZoom([implicitStart, implicitEnd], [self._currYScale.domain()[0], self._currYScale.domain()[1]], true);\n                        } else {\n                            this.props.onLinearPlotZoom([implicitStart, implicitEnd], [self._currYScale.domain()[0], self._currYScale.domain()[1]], false);\n                        }\n                    } catch (error) {}\n                })\n\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n        }\n        svg.call(zoom).call(zoom.transform, d3.zoomIdentity.scale(1.0));\n    }\n\n    renderHighlight() {\n        const {width, genome, chr, hoveredLocation} = this.props;\n        if (!hoveredLocation) {\n            return null;\n        }\n\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd);\n        const implicitCoords = genome.getImplicitCoordinates(hoveredLocation);\n        const start = xScale(implicitCoords.start);\n        const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n        return <div style={{\n            position: \"absolute\",\n            left: start,\n            width: boxWidth,\n            height: \"100%\",\n            backgroundColor: \"rgba(255,255,0,0.2)\",\n            border: \"1px solid rgba(255,255,0,0.7)\",\n            zIndex: -1\n        }} />\n    }\n\n    handleMouseMove(event: React.MouseEvent) {\n        const {width, genome, chr, onLocationHovered} = this.props;\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd);\n        const range = xScale.range();\n        const mouseX = getRelativeCoordinates(event).x;\n        if (mouseX < range[0] || mouseX > range[1]) { // Count mouse events outside the range as mouseleaves\n            this.handleMouseLeave();\n            return;\n        }\n        const implicitLocation = xScale.invert(mouseX);\n        onLocationHovered(genome.getChromosomeLocation(implicitLocation));\n    }\n\n    handleMouseLeave() {\n        this.props.onLocationHovered(null);\n    }\n\n    render() {\n        const {width, height, dataKeyToPlot} = this.props;\n        return <div\n                className=\"LinearPlot\"\n                style={{position: \"relative\"}}\n                onMouseMove={this.handleMouseMove}\n                onMouseLeave={this.handleMouseLeave}\n            >\n            {/* {this.renderHighlight()} */}\n            {this.renderTooltip()}\n            {this.renderLockedDrivers()}\n            <canvas\n                ref={node => this._canvas = node}\n                width={width}\n                height={height}\n                className={\"canvas\"}\n                style={{position: \"absolute\", \n                        top: PADDING.top, \n                        zIndex: -1, \n                        left: PADDING.left, \n                        width: width-PADDING.left - PADDING.right, \n                        height: height-PADDING.top-PADDING.bottom}} />\n            \n            <svg ref={node => this._svg = node} width={width} height={height}/>\n            <div className=\"LinearPlot-tools\">\n                {(dataKeyToPlot === \"RD\" || dataKeyToPlot === \"logRD\")\n                && <button onClick={() => {\n                    this.props.onLinearPlotZoom(null, null, true, true);\n                }}\n                >Reset View</button>}\n            </div>\n        </div>;\n    }\n\n    renderLockedDrivers() {\n        const {width, genome, chr, height} = this.props;\n        let shouldAddBack = false;\n        if(this.previewDriver != null && this.lockedDrivers.has(this.previewDriver)) {\n            this.lockedDrivers.delete(this.previewDriver);\n            shouldAddBack = true;\n        }\n\n        const drivers = [...this.lockedDrivers];\n        if(this.previewDriver != null && shouldAddBack) {\n            this.lockedDrivers.add(this.previewDriver);\n        }\n\n        return (\n            drivers.map(\n                driver => {\n                    const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd);\n                    const implicitCoords = genome.getImplicitCoordinates(driver.location);\n                    const start = xScale(implicitCoords.start) || 0;\n                    const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n                    const driverSymbol = driver.symbol;\n                    const contents = <React.Fragment>\n                                        <div> {driverSymbol} </div>\n                                    </React.Fragment>;\n\n                    if(start > PADDING.left && start < width - PADDING.right) {\n                        return (\n                            <div key={this.props.dataKeyToPlot + driverSymbol}>\n                                <div style={{\n                                    position: \"absolute\",\n                                    left: start-20,\n                                    bottom: height,\n                                    border: \"1px solid rgba(0,0,0,0)\",\n                                    zIndex: 0\n                                }}>\n                                    {contents}\n                                </div>\n                                <div style={{\n                                    position: \"absolute\",\n                                    left: start,\n                                    width: boxWidth,\n                                    height: \"75%\",\n                                    backgroundColor: \"rgba(255,165,0,1)\",\n                                    border: \"1px solid rgba(255,165,0,1)\",\n                                    zIndex: 0\n                                }} />   \n                        </div>\n                        )\n                    } else {\n                        return null;\n                    }\n                }\n            ))\n    }\n\n    renderTooltip() {\n        const {driverGenes, hoveredLocation, width, genome, chr, height} = this.props;\n\n        if (!hoveredLocation) {\n            return null;\n        }\n\n        if(!driverGenes) {\n            return null;\n        }\n\n        if(!this.previewDriver) {\n            return null;\n        }\n\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd);\n        const implicitCoords = genome.getImplicitCoordinates(this.previewDriver.location);\n        const start = xScale(implicitCoords.start) || 0;\n        const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n        const driverSymbol = this.previewDriver.symbol;\n\n        const contents = <React.Fragment>\n                            <div> {driverSymbol} </div>\n                        </React.Fragment>\n\n        return (\n            <div>\n                <div style={{\n                    position: \"absolute\",\n                    left: start-20,\n                    bottom: height,\n                    border: \"1px solid rgba(0,0,0,0)\",\n                    zIndex: 0\n                }}>\n                    {contents}\n                </div>\n                <div style={{\n                    position: \"absolute\",\n                    left: start,\n                    width: boxWidth + 1,\n                    height: \"75%\",\n                    backgroundColor: (this.lockedDrivers.has(this.previewDriver)) ?\"red\" : \"rgba(0, 200 , 0, 1)\",\n                    zIndex: 0\n                }} />   \n            </div>\n        )\n    }\n}\n","import React from \"react\";\n\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {DisplayMode, genome} from \"../App\";\nimport { LinearPlot } from \"./LinearPlot\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { Gene } from \"../model/Gene\";\n\ninterface Props {\n    data: GenomicBin[];\n    chr: string;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered?: (location: ChromosomeInterval | null) => void\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    customColor: string;\n    colors: string[];\n    yScale: [number, number] | null;\n    xScale: [number, number] | null;\n    clusterTableData: any;\n    applyLog: boolean;\n    displayMode: DisplayMode;\n    width: number;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    implicitStart: number | null;\n    implicitEnd: number | null;\n    onZoom: (newScales: any) => void;\n    driverGenes: Gene[] | null;\n    handleDriverGenesChange: (sentGene: {gene: Gene | null, destination: string | null}) => void;\n    driverGeneUpdate: {gene: Gene | null, destination: string | null};\n}\n\nexport function RDLinearPlot(props: Props & {rdRange: [number, number]}) {\n    const {data, chr, rdRange, hoveredLocation, onLocationHovered, onBrushedBinsUpdated, \n        brushedBins, customColor, colors, yScale, clusterTableData, applyLog, \n        displayMode, width, onLinearPlotZoom, implicitStart, implicitEnd, onZoom, driverGenes} = props;\n    return <LinearPlot\n                data={data}\n                dataKeyToPlot={applyLog ? \"logRD\" : \"RD\"}\n                applyLog={applyLog}\n                genome={genome}\n                chr={chr}\n                hoveredLocation={hoveredLocation}\n                onLocationHovered={onLocationHovered}\n                onBrushedBinsUpdated={onBrushedBinsUpdated}\n                yMin={yScale ? yScale[0] : (applyLog ? -2 : 0)}\n                yMax={yScale ? yScale[1] : rdRange[1]}\n                yLabel={applyLog ? \"log RDR\" : \"RDR\"}\n                brushedBins={brushedBins}\n                customColor={customColor}\n                colors={colors}\n                clusterTableData={clusterTableData}\n                displayMode={displayMode}\n                width={width}\n                onZoom={onZoom}\n                onLinearPlotZoom={onLinearPlotZoom}\n                implicitStart={implicitStart}\n                implicitEnd={implicitEnd}\n                driverGenes={driverGenes}\n                driverGeneUpdate={props.driverGeneUpdate}\n                handleDriverGenesChange={props.handleDriverGenesChange}\n        />\n}\n\nexport function BAFLinearPlot(props: Props) {\n    const {data, chr, hoveredLocation, onLocationHovered, onBrushedBinsUpdated, brushedBins, \n            customColor, colors, xScale, clusterTableData, displayMode, width, onLinearPlotZoom, \n            implicitStart, implicitEnd, onZoom, driverGenes, applyLog} = props;\n\n    return <LinearPlot\n                data={data}\n                chr={chr}\n                dataKeyToPlot=\"reverseBAF\"\n                applyLog={applyLog}\n                genome={genome}\n                hoveredLocation={hoveredLocation}\n                onLocationHovered={onLocationHovered}\n                onBrushedBinsUpdated= {onBrushedBinsUpdated}\n                yMin={xScale ? xScale[0] : 0}\n                yMax={xScale ? xScale[1] : 0.5}\n                yLabel={\"0.5 - BAF\"}\n                brushedBins={brushedBins}\n                customColor={customColor}\n                colors={colors} \n                clusterTableData={clusterTableData}\n                displayMode={displayMode}\n                width={width}\n                onLinearPlotZoom={onLinearPlotZoom}\n                implicitStart={implicitStart}\n                implicitEnd={implicitEnd}\n                onZoom={onZoom}\n                driverGenes={driverGenes}\n                driverGeneUpdate={props.driverGeneUpdate}\n                handleDriverGenesChange={props.handleDriverGenesChange}\n        />;\n}\n","import React from \"react\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { DivWithBullseye } from \"./DivWithBullseye\";\nimport { RDLinearPlot, BAFLinearPlot } from \"./RdrBafLinearPlots\";\n\nimport \"./SampleViz.css\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { DisplayMode } from \"../App\";\nimport { Gene } from \"../model/Gene\";\n\ninterface Props {\n    data: GenomicBin[];\n    chr: string;\n    hoveredLocation?: ChromosomeInterval;\n    initialSelectedSample: string;\n    onLocationHovered?: (location: ChromosomeInterval | null) => void;\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    customColor: string;\n    colors: string[];\n    selectedSample: string;\n    yScale: [number, number] | null;\n    xScale: [number, number] | null;\n    rdRange: [number, number];\n    clusterTableData: any;\n    applyLog: boolean;\n    displayMode: DisplayMode;\n    width: number;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    onZoom: (newScales: any) => void;\n    implicitRange: [number, number] | null;\n    driverGenes: Gene[] | null;\n}\n\ninterface State {\n    selectedSample: string;\n    sentDriver: {gene: Gene | null, destination: string | null} // keeps baf and RD driver markers in sync by sending what update was done to the lockedDrivers set\n}\n\nexport class SampleViz1D extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            selectedSample: props.initialSelectedSample,\n            sentDriver: {gene: null, destination: null}\n        };\n\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleDriverGenesChange = this.handleDriverGenesChange.bind(this);\n    }\n\n    handleSelectedSampleChanged(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedSample: event.target.value});\n    }\n\n    handleDriverGenesChange(sentGene: {gene: Gene | null, destination: string | null}) {\n        this.setState({sentDriver: sentGene});\n    }\n\n    render() {\n        const {data, chr, hoveredLocation, onLocationHovered, onBrushedBinsUpdated, brushedBins,\n             customColor, yScale, xScale, rdRange, clusterTableData, applyLog, displayMode, width, onLinearPlotZoom, implicitRange, onZoom, driverGenes} = this.props;\n\n        let visualization: React.ReactNode = null;\n            visualization = <DivWithBullseye className=\"SampleViz-pane\">\n                <RDLinearPlot\n                    data={data}\n                    chr={chr}\n                    rdRange={rdRange}\n                    hoveredLocation={hoveredLocation}\n                    onLocationHovered={onLocationHovered} \n                    onBrushedBinsUpdated={onBrushedBinsUpdated}\n                    brushedBins={brushedBins}\n                    customColor={customColor}\n                    colors={this.props.colors}\n                    yScale= {yScale}\n                    xScale= {xScale}\n                    clusterTableData={clusterTableData}\n                    applyLog={applyLog}\n                    displayMode={displayMode}\n                    width={width}\n                    onLinearPlotZoom ={onLinearPlotZoom}\n                    implicitStart={(implicitRange) ? implicitRange[0] : implicitRange}\n                    implicitEnd={(implicitRange) ? implicitRange[1] : implicitRange}\n                    onZoom={onZoom}\n                    driverGenes={driverGenes}\n                    handleDriverGenesChange={this.handleDriverGenesChange}\n                    driverGeneUpdate={this.state.sentDriver}\n                    />\n                    \n                <div className=\"SampleViz-separator\" />\n                <BAFLinearPlot\n                    data={data}\n                    chr={chr}\n                    hoveredLocation={hoveredLocation}\n                    onLocationHovered={onLocationHovered}\n                    onBrushedBinsUpdated={onBrushedBinsUpdated}\n                    brushedBins={brushedBins} \n                    customColor={customColor}\n                    colors={this.props.colors}\n                    yScale={yScale}\n                    xScale= {xScale}\n                    clusterTableData={clusterTableData}\n                    applyLog={applyLog}\n                    displayMode={displayMode}\n                    width={width}\n                    onLinearPlotZoom={onLinearPlotZoom}\n                    onZoom={onZoom}\n                    implicitStart={(implicitRange) ? implicitRange[0] : implicitRange}\n                    implicitEnd={(implicitRange) ? implicitRange[1] : implicitRange}\n                    driverGenes={driverGenes}\n                    handleDriverGenesChange={this.handleDriverGenesChange}\n                    driverGeneUpdate={this.state.sentDriver}\n                />\n                    \n            </DivWithBullseye>;\n\n        return <div className=\"SampleViz-linear\" >\n            {visualization}\n        </div>;\n    }\n}\n","import React from \"react\"\nimport _ from \"lodash\";\nimport DataTable from 'react-data-table-component';\nimport {BlockPicker} from \"react-color\";\nimport \"./ClusterTable.css\"\n\nconst UNCLUSTERED_COLOR = \"#999999\";\n\ninterface Props {\n    data : any;\n    onClusterRowsChange : any;\n    onClusterColorChange: any;\n    currentFilters: String[];\n    selectable ?: boolean;\n    expandable ?: boolean;\n    colOneName : string;\n    colTwoName: string;\n    colThreeName?: string;\n    cols: any;\n    centroidTable?: boolean;\n    colors : string[];\n    updatedClusterTable?: () => void;\n}\n\nexport class ClusterTable extends React.Component<Props> {\n    private readonly table_data : any;\n    \n    constructor(props: Props) {\n        super(props);\n        this.table_data = props.data;\n        this.handleColorChange = this.handleColorChange.bind(this);\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return this.props[\"data\"] !== nextProps[\"data\"] ||  this.props[\"colors\"] !== nextProps[\"colors\"];\n    }\n\n    handleColorChange(color : any, index: any) {\n        this.props.colors[index] = color.hex;\n        const tempColors = _.cloneDeep(this.props.colors);\n        this.props.onClusterColorChange(tempColors);\n        this.forceUpdate();\n    }\n    \n    componentDidUpdate(prevProps: Props) {\n        if(this.props.updatedClusterTable)\n            this.props.updatedClusterTable();\n    }\n\n    render() {\n        const {colOneName, colTwoName, colThreeName, data, expandable, selectable, colors, centroidTable} = this.props;\n        const ExpandedComponent =(data:any) => \n        <div> \n            <BlockPicker \n                width=\"100%\"\n                color={this.props.colors[data.data.key]}\n                onChangeComplete={c => this.handleColorChange(c, data.data.key)} \n            />\n        </div>;\n\n        const conditionalRowStyles : any = [\n            {\n              when: (row:any) => row,\n              style: (row:any) => ({\n                backgroundColor: (Number(row.key) === -1) ? UNCLUSTERED_COLOR : colors[Number(row.key) % colors.length],\n                alignItems: 'center',\n                justifyContent: 'center',\n                innerWidth: 50,\n                outerWidth: 50\n\n              }),\n            }\n        ];\n\n        const columns = [\n            {\n              name: colOneName,\n              selector: 'key',\n              sortable: true,\n              compact: true,\n              wrap: true,\n              innerWidth: 40,\n              outerWidth: 40,\n              width: \"50\",\n              center: true\n            },\n            {\n              name: colTwoName,\n              selector: 'value',\n              sortable: true,\n              right: true,\n              compact: true,\n              wrap: true,\n              innerWidth: 40,\n              outerWidth: 40,\n              width: \"50\",\n              center: true\n            },\n        ];\n\n        const columns3 = [\n            {\n                name: colOneName,\n                selector: 'key',\n                sortable: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n            {\n                name: colTwoName,\n                selector: 'value',\n                sortable: true,\n                right: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n            {\n                name: colThreeName,\n                selector: 'selectPerc',\n                sortable: true,\n                right: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n        ];\n\n        if(centroidTable) {\n            let colNames : any[] = [];\n            \n            if(data !== null && data !== undefined && data.length > 0) {\n                colNames.push({name: \"Cluster ID\", type: \"key\"})\n                for(const s of Object.keys(data[0].sample)) {\n                    colNames.push({name: s, type: \"sample.\"+s});\n                }\n            }\n        \n            const centroidColumns = [];\n            for(const name of colNames) {\n                let centroidCol = {\n                    name: name.name,\n                    selector: name.type,\n                    sortable: true,\n                    compact: true,\n                    wrap: true,\n                    center: true\n                }\n                centroidColumns.push(centroidCol);\n            }\n            \n            return (\n                <DataTable\n                    columns={centroidColumns}\n                    data={data}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={5}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            )\n\n        }\n        \n        if(!expandable && !selectable) {\n            return (\n                <DataTable\n                    columns={columns3}\n                    data={data}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={3}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[3, 5, 10, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    noDataComponent={<div style={{padding: 10}}>No Records Selected</div>}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            )\n        }\n\n        return (\n            <div className=\"scroll\">\n                <DataTable\n                    columns={columns}\n                    data={data}\n                    selectableRows\n                    onSelectedRowsChange={this.props.onClusterRowsChange}\n                    selectableRowSelected={row => {\n                        if(this.props.currentFilters.includes(String(row.key))) {\n                            return row;\n                        }\n                    }}\n                    expandableRows\n                    expandableRowsComponent={<ExpandedComponent/>}\n                    expandableRowDisabled={row => row.key === -1 || row.key === -2}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={5}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            </div>\n\n            \n        )\n    }\n};\n\n","import React from \"react\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { DataWarehouse } from \"../model/DataWarehouse\";\nimport { SampleViz2D } from \"./SampleViz2D\";\nimport { SampleViz1D } from \"./SampleViz1D\";\nimport \"./SampleViz.css\";\nimport {DisplayMode} from \"../App\"\nimport {ClusterTable} from \"./ClusterTable\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { Gene } from \"../model/Gene\";\n\n\nconst UNCLUSTERED_ID = \"-1\";\nconst DELETED_ID = \"-2\";\n\ninterface Props {\n    parentCallBack: any;\n    data: DataWarehouse;\n    chr: string;\n    cluster: string;\n    initialSelectedSample: string;\n    initialSelectedCluster?: string;\n    width?: number;\n    height?: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null, record?: GenomicBin | null) => void;\n    invertAxis?: boolean;\n    customColor: string;\n    colors: string[];\n    assignCluster: boolean;\n    onBrushedBinsUpdated: any;\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    dispMode: DisplayMode;\n    onRemovePlot: any;\n    onAddSample: any;\n    plotId: number;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    showLinearPlot: boolean;\n    showScatterPlot: boolean;\n    showSidebar: boolean;\n    onUndoClick: () => void;\n    sampleAmount: number;\n    syncScales: boolean;\n    handleZoom: (newScales: any) => void;\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n    showCentroids: boolean;\n    driverGenes: Gene[] | null;\n}\n\ninterface State {\n    selectedSample: string;\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n    selectedCluster:string;\n    implicitRange: [number, number]  | null;\n}\n\nexport class SampleViz extends React.Component<Props, State> {\n    private _clusters : string[];\n    constructor(props: Props) {\n        super(props);\n        this._clusters = this.initializeListOfClusters();\n        this.state = {\n            selectedSample: props.initialSelectedSample || props.data.getSampleList()[0],\n            scales: {xScale: null, yScale: null},\n            selectedCluster: (this._clusters.length > 0) ? this._clusters[0] : UNCLUSTERED_ID,\n            implicitRange: null\n        }\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleSelectedSampleChange = this.handleSelectedSampleChange.bind(this);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.handleLinearPlotZoom = this.handleLinearPlotZoom.bind(this);\n        \n    }\n\n    initializeListOfClusters() : string[] {\n        let clusterTableData = this.props.clusterTableData;\n\n        this._clusters = [];\n        for(const obj of clusterTableData) {\n            this._clusters.push(obj.key);\n        }\n\n        while(this._clusters.length > 0 \n            && (this._clusters[0] === UNCLUSTERED_ID \n            || this._clusters[0] === DELETED_ID)) {\n            this._clusters.shift();\n        }\n\n        return this._clusters;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.clusterTableData !== prevProps.clusterTableData) {\n            this.initializeListOfClusters();\n        } else if(this.props.applyLog !== prevProps.applyLog) {\n            let newScale = {xScale: this.state.scales.xScale, yScale: null};\n            this.setState({scales: newScale});\n        }\n    }\n\n    handleSelectedSampleChanged(selected : string) {\n        this.setState({selectedSample: selected});\n    }\n\n    handleSelectedSampleChange(event : any) {\n        this.setState({selectedSample: event.target.value});\n    }\n\n    handleZoom(newScales: any) {\n        const {syncScales, handleZoom} = this.props;\n        (syncScales) ?  handleZoom(newScales) : this.setState({scales: newScales})\n    }\n\n    handleLinearPlotZoom(genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) {\n        if(reset) {\n            this.setState({implicitRange: null});\n            let newScale = {xScale: null, yScale: null};\n            this.setState({scales: newScale});\n        } else {\n            this.setState({implicitRange: genomicRange});\n            let newScale = (!key) ? {xScale: yscale, yScale: this.state.scales.yScale} : {xScale: this.state.scales.xScale, yScale: yscale};\n            this.setState({scales: newScale});\n        }\n    }\n\n    \n    render() {\n        const {data, initialSelectedSample, applyLog, \n            showLinearPlot, showScatterPlot, dispMode, showSidebar, sampleAmount, syncScales} = this.props;\n        const {implicitRange} = this.state;\n        \n        const selectedSample = this.state.selectedSample;\n        const rdRange = data.getRdRange(selectedSample, applyLog);\n        \n        const sampleOptions = data.getSampleList().map(sampleName =>\n            <option key={sampleName} value={sampleName}>{sampleName}</option>\n        );\n\n        let selectedRecords = [];\n        let scales = (syncScales) ? this.props.scales : this.state.scales;\n        if (implicitRange !== null || scales.xScale !== null || scales.yScale !== null) {\n            let implicitStart = (implicitRange) ? implicitRange[0] : null;\n            let implicitEnd = (implicitRange) ? implicitRange[1] : null;\n            selectedRecords = data.getRecords(selectedSample, applyLog, implicitStart, implicitEnd, scales.xScale, scales.yScale);\n        } else { \n            selectedRecords = data.getRecords(selectedSample, applyLog, null, null, null, null);\n        }\n        \n        rdRange[1] += 0.5;\n        \n        let clusterOptions = this._clusters.map(clusterName =>\n            <option key={clusterName} value={clusterName} >{clusterName}</option>\n        );\n        \n        clusterOptions.unshift(<option key={UNCLUSTERED_ID} value={UNCLUSTERED_ID} >{UNCLUSTERED_ID}</option>);\n        clusterOptions.unshift(<option key={DELETED_ID} value={DELETED_ID} >{DELETED_ID}</option>);\n        let disableSelectOptions = (data.getBrushedBins().length === 0);\n        return <div className=\"SampleViz-wrapper\">\n            <div style={{verticalAlign: \"middle\"}}>\n            {(showLinearPlot || showScatterPlot) &&\n            <div className=\"SampleViz-select\">\n                <span>Sample: </span>\n                <select value={selectedSample} onChange={this.handleSelectedSampleChange}>\n                    {sampleOptions}\n                </select>\n                <button onClick={this.props.onAddSample} disabled={sampleAmount >= sampleOptions.length}> Add Sample </button>\n                <button onClick={this.props.onRemovePlot} disabled={sampleAmount <= 1}> Remove Sample </button>\n            </div>}\n            \n            {(showLinearPlot || showScatterPlot) &&\n            <div className=\"SampleViz-select\">\n                    <span >Cluster: </span>\n                        \n                    <select\n                    name=\"Select Cluster\" \n                    title=\"Cluster\"\n                    className=\"Sampleviz-cluster-select\"\n                    value={this.state.selectedCluster}\n                    disabled={disableSelectOptions}\n                    onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {this.setState({selectedCluster: event.target.value})}} >\n                    {clusterOptions}\n                    </select>\n                        \n\n                    <button onClick={() => {\n                        this.props.parentCallBack(this.state.selectedCluster);\n                        this.props.onBrushedBinsUpdated([]);\n                    }}\n                    disabled={disableSelectOptions}>Assign Cluster</button>\n\n                    <button onClick={()=>{\n                        this.initializeListOfClusters();\n                        let clusters = this._clusters;\n                        clusters.sort((a: string, b:string) => (Number(a) - Number(b)))\n                        const highestCurrentCluster = (clusters.length > 0) ? Number(clusters[clusters.length-1]) : -1;\n                        let nextAvailable = highestCurrentCluster + 1;\n\n                        for(let i = 0; i < clusters.length; i++) {\n                            if(Number(clusters[i]) !== i){\n                                nextAvailable = i;\n                                break;\n                            }\n                        }\n\n                        this.props.parentCallBack(nextAvailable);\n                        this.props.onBrushedBinsUpdated([]);\n                    }}\n                    disabled={disableSelectOptions} >New Cluster</button>\n                    <button onClick={this.props.onUndoClick}> Undo</button>\n                </div>}\n            </div>\n\n            <div className=\"SampleViz-plots\">\n                {showScatterPlot && <SampleViz2D \n                        {...this.props} \n                        data={selectedRecords}\n                        onSelectedSample={this.handleSelectedSampleChanged}\n                        selectedSample={selectedSample}\n                        initialSelectedSample={initialSelectedSample}\n                        onZoom={this.handleZoom}\n                        rdRange={rdRange}\n                        implicitRange={this.state.implicitRange}\n                        scales={(syncScales) ? this.props.scales : this.state.scales}\n                        centroidPts={data.getCentroidPoints(selectedSample, this.props.chr)}\n                        />\n                }\n                {showLinearPlot && <SampleViz1D \n                    {...this.props}  \n                    data={selectedRecords}\n                    onLinearPlotZoom={this.handleLinearPlotZoom}\n                    onZoom={this.handleZoom}\n                    yScale={this.state.scales.yScale} \n                    xScale={this.state.scales.xScale} \n                    selectedSample={this.state.selectedSample} \n                    initialSelectedSample={initialSelectedSample}\n                    rdRange={rdRange}\n                    displayMode={dispMode}\n                    width={showSidebar ? 600 : 600} \n                    implicitRange={this.state.implicitRange}/>}\n            </div>\n            \n\n            {(showLinearPlot || showScatterPlot) &&\n            <div className={(showLinearPlot && showScatterPlot) ? \"SampleViz-clusters\" : \"\"}>\n                <ClusterTable \n                    data={data.brushedTableData()} \n                    onClusterRowsChange={() => {}} \n                    onClusterColorChange={() => {}}\n                    currentFilters={[\"-1\"]}\n                    colOneName={\"Cluster ID\"}\n                    colTwoName={\"Cluster (%)\"}\n                    colThreeName={\"Selection (%)\"}\n                    cols={\"\"}\n                    expandable={false}\n                    selectable={false}\n                    colors={this.props.colors}\n                ></ClusterTable>\n            </div>}\n            \n        </div>\n    }\n}","export default \"data:image/gif;base64,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\"","import React from \"react\"\nimport DataTable from 'react-data-table-component';\nimport \"./ClusterTable.css\";\n\ninterface Props {\n    data : any;\n    onClusterRowsChange : any;\n    onClusterColorChange: any;\n    colName : string;\n    updatedClusterTable?: () => void;\n}\n\nexport class LogTable extends React.Component<Props> {\n    private readonly table_data : any;\n\n    constructor(props: Props) {\n        super(props);\n        this.table_data = props.data;\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return this.props[\"data\"] !== nextProps[\"data\"];\n    }\n\n    render() {\n        const {colName, data} = this.props;\n\n        const columns = [\n            {\n              name: colName,\n              selector: \"action\",\n              compact: true,\n              wrap: true,\n            }\n        ];\n        let newData = [];\n        for(let s of data) {\n            newData.push(s);\n        }\n        return <div>\n            <DataTable\n                columns={columns}\n                data={newData}\n                pagination={true}\n                paginationPerPage={5}\n                paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                noContextMenu={true}\n                noHeader={true}\n            ></DataTable>\n        </div>\n\n\n    }\n\n}   ","import _ from \"lodash\";\nimport { OpenInterval } from \"./OpenInterval\";\nimport { ChromosomeInterval } from \"./ChromosomeInterval\";\n\n/**\n * Container to hold the name and length of a chromosome in bases.\n */\nexport interface Chromosome {\n    /** Name of the chromosome. */\n    readonly name: string;\n    /** Length of the chromosome, in bases. */\n    readonly length: number;\n}\n\n/**\n * A named set of chromosomes.  Because a single number system is easier to work with for visualization, instances\n * assign a unique base number to every location in the genome.  We term these unique base numbers as members of an \n * \"implicit\" coordinate system.  In contrast, locations specified by a set of base numbers in a specific chromosome,\n * for example \"chr1:0-1000\", are termed \"chromosome\" locations.\n * \n * You may assume that if bases are adjacent in chromosomes, they are also adjacent in the implicit coordinate system.\n * For instance, if the first base of chr10 maps to an implicit coordinate of 1000, and chr10 is five hundred bases\n * long, then it is safe to assume that chr10 maps to implicit bases 10000 to 10499.\n * \n * @author Silas Hsu\n */\nexport class Genome {\n    /** The name of this genome. */\n    private _name: string;\n\n    /** Ordered list of chromosomes in the genome. */\n    private _chromosomes: Chromosome[];\n\n    /**\n     * Mapping from chromosome name to the implicit coordinate of the chromosome's first base (see class description).\n     */\n    private _chrStarts: {[chrName: string]: number};\n\n    /** Total number of bases in the genome. */\n    private _length: number;\n\n    private nameToChr: {[chr: string]: Chromosome}\n\n    /**\n     * Makes a new instance, with name and list of chromosomes.  Chromosomes *must* have unique names.\n     * \n     * @param name - name of the genome\n     * @param chromosomes - list of chromosomes in the genome\n     * @throws {Error} if there are duplicate chromosome names\n     */\n    constructor(chromosomes: Chromosome[], name?: string) {\n        this._name = name ? name : \"\";\n        this._chromosomes = chromosomes;\n        this._chrStarts = {};\n        this._length = 0;\n\n        for (const chromosome of chromosomes) {\n            const chrName = chromosome.name;\n            if (this._chrStarts[chrName] !== undefined) {\n                throw new Error(`Duplicate chromosome name \"${chrName}\" in genome \"${name}\"`);\n            }\n            this._chrStarts[chrName] = this._length;\n            this._length += chromosome.length;\n        }\n        \n        this.nameToChr = {};\n        for (const chr of this._chromosomes) {\n            this.nameToChr[chr.name] = chr;\n        }\n    }\n\n    /**\n     * @return this genome's name\n     */\n    getName(): string {\n        return this._name;\n    }\n\n    /**\n     * Returns the list of Chromosome objects backing this instance.  Caution: modifying this list or objects in the\n     * list will modify this instance.\n     * \n     * @return the list of Chromosome objects backing this instance.\n     */\n    getChromosomeList(): Chromosome[] {\n        return this._chromosomes;\n    }\n\n    /**\n     * Gets a list of implicit coordinates of each chromosome's 0th base.  This list is in the same order as the list of\n     * chromosomes returned by `getChromosomeList()`.\n     * \n     * @return list of implicit coordinates of each chromosome's 0th base\n     */\n    getChromosomeStarts(): number[] {\n        return this._chromosomes.map(chr => this._chrStarts[chr.name]);\n    }\n\n    getChrStartMap() : any {\n        return this._chrStarts;\n    }\n\n    getChromosomeStarts2(chrs: Chromosome[], implicitStart: number, implicitEnd: number): number[] {\n        \n        // return chrStarts;\n        return chrs.map(chr => {\n           return this._chrStarts[chr.name];\n        });\n    }\n\n    /**\n     * Gets a length of a chromosome in base pairs, or the entire genome if the chromosome is unspecified.  Returns 0\n     * if the chromosome does not exist.\n     * \n     * @param chrName - the name of the chromosome to query, or `undefined` to query the entire genome's length\n     * @return length of the chromosome or genome.\n     */\n    getLength(chrName?: string): number {\n        if (!chrName) {\n            return this._length;\n        } else {\n            if ( !(chrName in this._chrStarts) ) {\n                return 0; // Chr not in this genome\n            }\n            return this._chromosomes.find(chr => chr.name === chrName)!.length;\n        }\n    }\n\n    getLength2(chrs: Chromosome[]) : number {\n        let length = 0;\n        for(const chr of chrs) {\n            length += chr.length;\n        }\n        return length\n    }\n\n    /**\n     * Converts a chromosome location into this instance's implicit coordinates.  See class description for more about\n     * implicit coordinates.\n     * \n     * @param location the genomic location to convert into implicit coordinates\n     * @return implicit base numbers in this instance that represent the genomic location\n     * @throws {Error} if the chromosome in the genomic location does not exist in this instance\n     */\n    getImplicitCoordinates(location: ChromosomeInterval): OpenInterval {\n        const {chr, start, end} = location;\n        if ( !(chr in this._chrStarts) ) {\n            throw new Error(`Chromosome \"${chr}\" not in this genome`);\n        }\n        const chrStart = this._chrStarts[chr];\n        return new OpenInterval(chrStart + start, chrStart + end);\n    }\n\n    /**\n     * Converts an implicit base number into a base number of a specific chromosome.  The result is returned in a\n     * ChromosomeInterval that has a length of 1.\n     * \n     * Input base numbers will be clamped to be a valid implicit coordinate before conversion takes place.  More\n     * formally, inputs will be clamped to be between [0, this.getLength() - 1].\n     * \n     * @param implicit the implicit base number to convert\n     * @return base number in a specific chromosome\n     */\n    getChromosomeLocation(implicit: number): ChromosomeInterval {\n        // Clamp the input\n        if (implicit < 0) {\n            implicit = 0;\n        } else if (implicit >= this.getLength()) {\n            implicit = this.getLength() - 1;\n        }\n\n        const sortedChrStarts = Object.values(this._chrStarts).sort((a, b) => a - b); // Sorted smallest to largest\n        const index = _.sortedLastIndex(sortedChrStarts, implicit) - 1;\n        const chrCoordinate = implicit - sortedChrStarts[index];\n        return new ChromosomeInterval(this._chromosomes[index].name, chrCoordinate, chrCoordinate + 1);\n    }\n\n    getChrs(chrs : string[]) {\n        let filteredChrs : Chromosome[] = [];\n        for(const chr of chrs) {\n            filteredChrs.push(this.nameToChr[chr]);\n        }\n        \n        return filteredChrs;\n    }\n}\n\nexport const hg38 = new Genome([\n    {name: \"chr1\", length: 248956422},\n    {name: \"chr2\", length: 242193529},\n    {name: \"chr3\", length: 198295559},\n    {name: \"chr4\", length: 190214555},\n    {name: \"chr5\", length: 181538259},\n    {name: \"chr6\", length: 170805979},\n    {name: \"chr7\", length: 159345973},\n    {name: \"chr8\", length: 145138636},\n    {name: \"chr9\", length: 138394717},\n    {name: \"chr10\", length: 133797422},\n    {name: \"chr11\", length: 135086622},\n    {name: \"chr12\", length: 133275309},\n    {name: \"chr13\", length: 114364328},\n    {name: \"chr14\", length: 107043718},\n    {name: \"chr15\", length: 101991189},\n    {name: \"chr16\", length: 90338345},\n    {name: \"chr17\", length: 83257441},\n    {name: \"chr18\", length: 80373285},\n    {name: \"chr19\", length: 58617616},\n    {name: \"chr20\", length: 64444167},\n    {name: \"chr21\", length: 46709983},\n    {name: \"chr22\", length: 50818468}\n], \"hg38\");\n","import React from \"react\"\nimport { GenomicBin} from \"../model/GenomicBin\";\nimport {toCSV} from \"../util\";\nimport spinner from \"../loading-small.gif\";\n\ninterface Props {\n    data : readonly GenomicBin[];\n    logData: any[];\n    fileName: string;\n}\n\ninterface State {\n    loading: boolean;\n}\n\nfunction convertToTsv(data: readonly GenomicBin[]): Promise<string> {\n    return new Promise((resolve, reject) => {\n        let keys = Object.keys(data[0]);\n            \n        const headings = keys.slice(0, keys.length-3);//.join('\\t');\n\n        // iterate over the data\n        const rows : string = toCSV(data, headings, \"\\t\", \" \");\n        let csvContent : any = rows;\n        resolve(csvContent);\n    })  \n}\n\nexport class CSV extends React.Component<Props, State> {\n    private csvLink: any;\n    constructor(props: Props) {\n        super(props);\n        this.csvLink = React.createRef();\n        this.state = {\n            loading: false\n        }\n        this.handleFileDownload = this.handleFileDownload.bind(this);\n    }\n\n    async handleFileDownload() {\n        this.setState({loading: true});\n\n        let csvContent = \"\";\n        try {\n            csvContent = await convertToTsv(this.props.data);\n        } catch(error) {\n            console.error(error);\n            return;\n        }\n        \n        var hiddenElement = document.createElement('a');  \n        hiddenElement.href = 'data:text/tab-separated-values,' + encodeURIComponent(csvContent);  \n        \n        // provide the name for the CSV file to be downloaded\n        // Assume that underscore is not in actual filename (only used to separate datetime)\n        const fileName = this.props.fileName;\n        let nameExt = fileName.split(\".\"); \n        let newFileName = \"\";\n        for(let i = 0; i < nameExt.length-1; i++) {\n            newFileName += nameExt[i];\n            if(i !== nameExt.length - 2) {\n                newFileName += \".\";\n            }\n        }\n\n        let removeDateTime = newFileName.split(\"_\");\n\n        const currentDate = new Date();\n        let month = String(currentDate.getMonth() + 1);\n        if(month.length < 2) {\n            month = \"0\" + month;\n        }\n\n        let day = String(currentDate.getDate());\n        if(day.length < 2) {\n            day = \"0\" + day;\n        }\n\n        let date = currentDate.getFullYear()+ month + day; \n        let hrs = String(currentDate.getHours() )\n        let min = String(currentDate.getMinutes());\n        let sec = String(currentDate.getSeconds());\n        if(hrs.length < 2) {\n            hrs = \"0\" + hrs;\n        }\n        if(min.length < 2) {\n            min = \"0\" + min;\n        }\n        if(sec.length < 2) {\n            sec = \"0\" + sec;\n        }\n        let time = hrs + min + sec;\n        hiddenElement.download = removeDateTime[0] + \"_\" + date + time + \".tsv\";\n        hiddenElement.click();\n        \n        let actions = [];\n        for(let action of this.props.logData) {\n            actions.push(action.action);\n        }\n        let logFileContent = \"\";\n        logFileContent = actions.join(\"\\n\");\n        var hiddenElement2 = document.createElement('a');  \n        hiddenElement2.href = 'data:text/plain,' + encodeURIComponent(logFileContent);\n        hiddenElement2.download = removeDateTime[0] + \"-log_\" + date + \"_\" + time;  \n        hiddenElement2.click();\n\n        this.setState({loading: false})\n    }\n\n    render() {\n        let csvButton = <div>\n                \n            <button type=\"button\" onClick={this.handleFileDownload}>Export</button>\n            {this.state.loading && <div>Reading file... <img src={spinner} alt=\"Loading\" /></div>}\n        </div>\n        return csvButton;\n    }\n}\n","import React, { Component } from \"react\";\nimport { DisplayMode } from \"../App\";\n\nimport \"./toggleButton.css\";\n\ninterface Props {\n    displayMode : DisplayMode;\n    setDisplayMode : () => void;\n}\n\nexport class ToggleButton extends Component<Props> {\n  constructor(props : Props) {\n    super(props);\n    this.state = {};\n  }\n\n  render() {\n    const { displayMode, setDisplayMode } = this.props;\n    return (\n      <div className=\"toggle-container\" onClick={setDisplayMode}>\n        <div className={`dialog-button ${(displayMode === DisplayMode.select || displayMode === DisplayMode.erase)? \"\" : \"disabled\"}`}>\n          {displayMode === DisplayMode.select ? \"Select\" : (displayMode === DisplayMode.erase) ? \"Erase\": \"Zoom\"}\n          \n        </div>\n      </div>\n    );\n  }\n}","import React from \"react\";\nimport \"./Sidebar.css\";\nimport {ClusterTable} from \"./ClusterTable\";\nimport {DisplayMode, ProcessingStatus} from \"../App\";\nimport {CSV} from \"./CSVLink\"\nimport { GenomicBin} from \"../model/GenomicBin\";\nimport {FiArrowLeftCircle, FiArrowRightCircle, FiMousePointer, FiZoomIn } from \"react-icons/fi\";\nimport { ToggleButton } from \"./ToggleButton\";\nimport spinner from \"../loading-small.gif\";\nimport {BsQuestionCircle} from \"react-icons/bs\";\n\ninterface Props {\n    selectedChr : string;\n    onChrSelected : any;\n    chrOptions: any;\n    onAddSample: any;\n    onAssignCluster: any;\n    tableData: any;\n    onClusterRowsChange: any;\n    onClusterColorChange: any;\n    currentClusterFilters: String[];\n    handleClusterAssignmentInput: any;\n    value: string;\n    setDisplayMode: any;\n    currentDisplayMode: DisplayMode;\n    colors: string[];\n    onSidebarChange: any;\n    data: readonly GenomicBin[];\n    logData: any[];\n    onFileChosen: any;\n    onDriverFileChosen: any;\n    chosenFile: string;\n    show: boolean;\n    onToggleLog: () => void;\n    onToggleScatter: () => void;\n    onToggleLinear: () => void;\n    onToggleShowCentroids: () => void;\n    showCentroids: boolean;\n    showScatter: boolean;\n    showLinear: boolean;\n    syncScales: boolean;\n    onToggleSync: () => void;\n    onToggleSilhouttes: () => void;\n    showSilhouttes: ProcessingStatus;\n    onToggleDirections: () => void;\n}\n\n\nfunction Sidebar(props: Props) {\n  const showSidebar = () => {\n    props.onSidebarChange(!props.show)\n  };\n\n  return (\n\n    <div className={props.show ? \"sidebar active\" : \"sidebar\"}>\n      <div className=\"closemenu3\" onClick={() => {\n              props.onToggleDirections();\n          }}><BsQuestionCircle></BsQuestionCircle></div>\n      <div className=\"closemenu\" onClick={showSidebar}>\n          <div> </div>\n          {props.show ? (\n                <div className=\"arrow-container\"> \n                  <FiArrowLeftCircle/>\n                </div>\n              ) : (\n                <div className=\"arrow-container\">\n                  <FiArrowRightCircle/>\n                </div>\n              )\n          }\n      </div>\n\n      {props.currentDisplayMode === DisplayMode.select && <div className=\"closemenu2\" onClick={() => {\n                if(props.currentDisplayMode === DisplayMode.zoom) { \n                  props.setDisplayMode(DisplayMode.select)\n                } else {\n                  props.setDisplayMode(DisplayMode.zoom)\n                }\n              }}><FiMousePointer></FiMousePointer>  </div>}\n      {props.currentDisplayMode === DisplayMode.zoom && <div className=\"closemenu2\" onClick={() => {\n                if(props.currentDisplayMode === DisplayMode.zoom) { \n                  props.setDisplayMode(DisplayMode.select)\n                } else {\n                  props.setDisplayMode(DisplayMode.zoom)\n                }\n              }}><FiZoomIn></FiZoomIn></div>}\n      \n      \n      <div className=\"contents\">\n        <h1>CNA-Viz</h1>\n        <div className=\"title-bar\"></div>\n        <h2>Import/Export</h2>\n          <div className=\"row-contents\" > Chosen File: {props.chosenFile}</div>\n          <div className=\"row-contents\">\n            <label className=\"custom-file-upload\">\n              <input type=\"file\" id=\"fileUpload\" onChange={\n                (event: any) =>\n                props.onFileChosen(event, false)\n              } />\n              Import\n            </label>\n          </div>\n          \n          <div className=\"row-contents\" >\n            <label className=\"custom-file-upload\">\n              <input type=\"file\" id=\"fileUpload\" onChange={\n                (event: any) =>\n                props.onFileChosen(event, true)\n              }/>\n              Import with Clustering\n            </label>\n          </div>\n          \n          <div className=\"row-contents\" >\n            <label className=\"custom-file-upload\">\n              <input type=\"file\" id=\"fileUpload\" onChange={\n                (event: any) =>\n                props.onDriverFileChosen(event, true)\n              }/>\n              Import Driver Genes\n            </label>\n          </div>\n\n          <div className=\"row-contents\">\n            <CSV data={props.data} logData={props.logData} fileName={props.chosenFile}></CSV>\n          </div>\n          \n        <div className=\"title-bar\"></div>\n        <h2 >Display Settings</h2>\n          <div className= \"row-contents\" >\n            <label htmlFor=\"Select Chromosome\"> Select a Chromosome: </label>\n            <select\n                name=\"Select Chromosome\" \n                id=\"Select Chromosome\"\n                value={props.selectedChr}\n                onChange={props.onChrSelected} >\n                    {props.chrOptions}\n            </select>\n          </div>\n        \n          <div className= \"row-contents\" >\n            <label>\n              <span className=\"App-CheckBox-explanation\">Apply log to RD: </span>\n              <input type=\"checkbox\" onClick={props.onToggleLog}/>\n            </label>\n          </div>\n          <div className= \"row-contents\" >\n            <label>\n              <span className=\"App-CheckBox-explanation\">Display Scatterplots: </span>\n              <input type=\"checkbox\" onClick={props.onToggleScatter} checked={props.showScatter} readOnly/>\n            </label>\n            \n          </div>\n          <div className= \"row-contents\" >\n            <label>\n              <span className=\"App-CheckBox-explanation\">Display Linear Plots: </span>\n              <input type=\"checkbox\" onClick={props.onToggleLinear} checked={props.showLinear} readOnly/>\n            </label>\n          </div>\n          <div className= \"row-contents\" >\n            <label>\n              <span className=\"App-CheckBox-explanation\">Show Centroids: </span>\n              <input type=\"checkbox\" onClick={props.onToggleShowCentroids} checked={props.showCentroids} readOnly/>\n            </label>\n          </div>\n           <div className= \"row-contents\" >\n           {/* {(props.showSilhouttes === ProcessingStatus.processing || props.showSilhouttes === ProcessingStatus.done)  && <img src={spinner} alt=\"Loading\" />} */}\n            {(props.showSilhouttes === ProcessingStatus.none ||props.showSilhouttes === ProcessingStatus.done)   && <label>\n              <span className=\"App-CheckBox-explanation\">Show Silhoutte Plot: </span>\n              <input type=\"checkbox\" onChange={props.onToggleSilhouttes} checked={props.showSilhouttes === ProcessingStatus.done} readOnly/>\n            </label>}\n            \n          </div>\n\n          <div className= \"row-contents\" >\n            <ToggleButton\n                displayMode={props.currentDisplayMode}\n                setDisplayMode={() => {\n                  if(props.currentDisplayMode === DisplayMode.zoom) { \n                    // setDisplayMode is what the toggle should should change to when clicked (so whatever displayMode that it isn't currently on)\n                    props.setDisplayMode(DisplayMode.select) \n                  } else {\n                    props.setDisplayMode(DisplayMode.zoom)\n                  }\n                }}\n              />\n          </div>\n\n      </div>\n        <div className=\"contents2\">\n          <ClusterTable \n                data={props.tableData} \n                onClusterRowsChange={props.onClusterRowsChange} \n                onClusterColorChange={props.onClusterColorChange}\n                currentFilters={props.currentClusterFilters}\n                colOneName={\"Cluster ID\"}\n                colTwoName={\"Bins (%)\"}\n                cols={\"\"}\n                expandable={true}\n                selectable={true}\n                colors={props.colors}\n            ></ClusterTable>\n          \n        </div>\n      \n    </div>\n  );\n}\n\nexport default Sidebar;","import React from \"react\"\nimport * as d3 from \"d3\";\nimport \"./BarPlot.css\";\n\n// const margins = {top: 10, right: 40, bottom: 40, left: 40};\nconst margins = {top: 0, right: 0, bottom: 0, left: 0};\n// const margin = { left: 100, top: 50, right: 50, bottom: 30 };\nconst margin = { left: 0, top: 0, right: 0, bottom: 30};\nconst UNCLUSTERED_COLOR = \"#999999\";\n\ntype clusterAvg = {\n    cluster: number,\n    avg: number\n};\n\ninterface Props {\n    data: clusterAvg[];\n    width: number;\n    height: number;\n    colors: string[];\n}\n\n\nexport class BarPlot extends React.Component<Props> {\n\n    private _svg: SVGSVGElement | null;\n\n    constructor(props: Props) {\n        super(props);\n        this._svg = null;\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return true;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.propsDidChange(prevProps, [])) {\n            this.redraw();\n        }\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n\n    componentDidMount() { \n        this.redraw();\n    }\n\n    render() {\n        return (\n            <div id=\"chart-container\">\n            </div>\n        )\n    }\n\n    redraw() {\n        const {width, height, data, colors} = this.props;\n\n        const marginRatio = {\n            left: margins.left / width * 100 + \"%\",//getRatio('left'),\n            top: margins.top / width * 100 + \"%\",\n            right: margins.right / width * 100 + \"%\",\n            bottom: margins.bottom / width * 100 + \"%\"\n        }\n\n        var svg = d3.select('div#chart-container')\n            .append('svg')\n            .style(\n                'padding',\n                    marginRatio.top +\n                    ' ' +\n                    marginRatio.right +\n                    ' ' +\n                    marginRatio.bottom +\n                    ' ' +\n                    marginRatio.left +\n                    ' '\n            )\n        .attr('preserveAspectRatio', 'xMinYMin meet')\n        .attr(\n          'viewBox',\n          '0 0 ' +\n            (width + margin.left + margin.right) +\n            ' ' +\n            (height + margin.top + margin.bottom)\n        )\n\n       \n        // Add X axis\n        var x = d3.scaleLinear()\n        .domain([-1, 1])\n        .range([15, width-10]);\n\n        svg.append(\"g\")\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .call(d3.axisBottom(x))\n            .selectAll(\"text\")\n                .attr(\"transform\", \"translate(-10,0)rotate(-45)\")\n                .style(\"text-anchor\", \"end\");\n\n        // Y axis\n        var y = d3.scaleBand()\n            .range([ 0, height])\n            .domain(data.map(d => String(d.cluster)))\n            .padding(.1);\n        \n\n        //Bars\n        svg.selectAll(\"myRect\")\n            .data(data)\n            .enter()\n            .append(\"rect\")\n            .attr(\"class\", function(d) { return \"bar bar--\" + (d.avg < 0 ? \"negative\" : \"positive\"); })\n            .attr(\"x\", function(d) { return x(Math.min(0, d.avg)) || 0; })\n            .attr(\"y\", function(d) { return y(String(d.cluster)) || 0; })\n            .attr(\"width\", function(d) { return Math.abs((x(d.avg) || 0) - (x(0) || 0)); })\n            .attr(\"height\", y.bandwidth())\n            .attr(\"fill\", row => (row.cluster === -1) ? UNCLUSTERED_COLOR : colors[row.cluster % colors.length]);\n            \n        svg.append(\"g\")\n            .call(d3.axisLeft(y).tickSize(0).tickPadding(6))\n            .attr(\"transform\", \"translate(\" + x(0) + \",0)\")\n    }\n }\n","import React from \"react\";\nimport parse from \"csv-parse\";\nimport _ from \"lodash\";\nimport { ChromosomeInterval } from \"./model/ChromosomeInterval\";\nimport { GenomicBin } from \"./model/GenomicBin\";\nimport { DataWarehouse, reformatBins } from \"./model/DataWarehouse\";\nimport {SampleViz} from \"./components/SampleViz\";\nimport spinner from \"./loading-small.gif\";\nimport \"./App.css\";\nimport {LogTable} from \"./components/LogTable\";\nimport * as d3 from \"d3\";\nimport {Genome} from \"./model/Genome\";\nimport Sidebar from \"./components/Sidebar\";\nimport \"./App.css\";\nimport { ClusterTable } from \"./components/ClusterTable\";\nimport { Gene } from \"./model/Gene\";\nimport { BarPlot } from \"./components/BarPlot\";\nimport {FiX} from \"react-icons/fi\";\nimport {calculateSilhoutteScores} from \"./util\"\n\nfunction getFileContentsAsString(file: File) {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.readAsText(file);\n        reader.onload = function() {\n            resolve(reader.result as string);\n        }\n        reader.onerror = reject;\n        reader.onabort = reject;\n    });\n}\n\nconst CLUSTER_COLORS = [\n    \"#d3fe14\", \"#c9080a\", \"#fec7f8\", \"#0b7b3e\", \"#3957ff\", \"#0bf0e9\", \"#c203c8\", \"#fd9b39\", \n    \"#906407\", \"#98ba7f\", \"#fe6794\", \"#10b0ff\", \"#ac7bff\", \"#fee7c0\", \"#964c63\", \"#1da49c\", \"#0ad811\", \n    \"#bbd9fd\", \"#fe6cfe\", \"#297192\", \"#d1a09c\", \"#78579e\", \"#81ffad\", \"#739400\", \"#ca6949\", \"#d9bf01\", \n    \"#646a58\", \"#d5097e\", \"#bb73a9\", \"#ccf6e9\", \"#9cb4b6\", \"#b6a7d4\", \"#9e8c62\", \"#6e83c8\", \"#01af64\", \n    \"#a71afd\", \"#cfe589\", \"#d4ccd1\", \"#fd4109\", \"#bf8f0e\", \"#2f786e\", \"#4ed1a5\", \"#d8bb7d\", \"#a54509\", \n    \"#6a9276\", \"#a4777a\", \"#fc12c9\", \"#606f15\", \"#3cc4d9\", \"#f31c4e\", \"#73616f\", \"#f097c6\", \"#fc8772\", \n    \"#92a6fe\", \"#875b44\", \"#699ab3\", \"#94bc19\", \"#7d5bf0\", \"#d24dfe\", \"#c85b74\", \"#68ff57\", \"#b62347\", \n    \"#994b91\", \"#646b8c\", \"#977ab4\", \"#d694fd\", \"#c4d5b5\", \"#fdc4bd\", \"#1cae05\", \"#7bd972\", \"#e9700a\", \n    \"#d08f5d\", \"#8bb9e1\", \"#fde945\", \"#a29d98\", \"#1682fb\", \"#9ad9e0\", \"#d6cafe\", \"#8d8328\", \"#b091a7\", \n    \"#647579\", \"#1f8d11\", \"#e7eafd\", \"#b9660b\", \"#a4a644\", \"#fec24c\", \"#b1168c\", \"#188cc1\", \"#7ab297\", \n    \"#4468ae\", \"#c949a6\", \"#d48295\", \"#eb6dc2\", \"#d5b0cb\", \"#ff9ffb\", \"#fdb082\", \"#af4d44\", \"#a759c4\", \n    \"#a9e03a\", \"#0d906b\", \"#9ee3bd\", \"#5b8846\", \"#0d8995\", \"#f25c58\", \"#70ae4f\", \"#847f74\", \"#9094bb\", \n    \"#ffe2f1\", \"#a67149\", \"#936c8e\", \"#d04907\", \"#c3b8a6\", \"#cef8c4\", \"#7a9293\", \"#fda2ab\", \"#2ef6c5\", \n    \"#807242\", \"#cb94cc\", \"#b6bdd0\", \"#b5c75d\", \"#fde189\", \"#b7ff80\", \"#fa2d8e\", \"#839a5f\", \"#28c2b5\", \n    \"#e5e9e1\", \"#bc79d8\", \"#7ed8fe\", \"#9f20c3\", \"#4f7a5b\", \"#f511fd\", \"#09c959\", \"#bcd0ce\", \"#8685fd\", \n    \"#98fcff\", \"#afbff9\", \"#6d69b4\", \"#5f99fd\", \"#aaa87e\", \"#b59dfb\", \"#5d809d\", \"#d9a742\", \"#ac5c86\", \n    \"#9468d5\", \"#a4a2b2\", \"#b1376e\", \"#d43f3d\", \"#05a9d1\", \"#c38375\", \"#24b58e\", \"#6eabaf\", \"#66bf7f\", \n    \"#92cbbb\", \"#ddb1ee\", \"#1be895\", \"#c7ecf9\", \"#a6baa6\", \"#8045cd\", \"#5f70f1\", \"#a9d796\", \"#ce62cb\", \n    \"#0e954d\", \"#a97d2f\", \"#fcb8d3\", \"#9bfee3\", \"#4e8d84\", \"#fc6d3f\", \"#7b9fd4\", \"#8c6165\", \"#72805e\", \n    \"#d53762\", \"#f00a1b\", \"#de5c97\", \"#8ea28b\", \"#fccd95\", \"#ba9c57\", \"#b79a82\", \"#7c5a82\", \"#7d7ca4\", \n    \"#958ad6\", \"#cd8126\", \"#bdb0b7\", \"#10e0f8\", \"#dccc69\", \"#d6de0f\", \"#616d3d\", \"#985a25\", \"#30c7fd\", \n    \"#0aeb65\", \"#e3cdb4\", \"#bd1bee\", \"#ad665d\", \"#d77070\", \"#8ea5b8\", \"#5b5ad0\", \"#76655e\", \"#598100\", \n    \"#86757e\", \"#5ea068\", \"#a590b8\", \"#c1a707\", \"#85c0cd\", \"#e2cde9\", \"#dcd79c\", \"#d8a882\", \"#b256f9\", \n    \"#b13323\", \"#519b3b\", \"#dd80de\", \"#f1884b\", \"#74b2fe\", \"#a0acd2\", \"#d199b0\", \"#f68392\", \"#8ccaa0\", \n    \"#64d6cb\", \"#e0f86a\", \"#42707a\", \"#75671b\", \"#796e87\", \"#6d8075\", \"#9b8a8d\", \"#f04c71\", \"#61bd29\", \n    \"#bcc18f\", \"#fecd0f\", \"#1e7ac9\", \"#927261\", \"#dc27cf\", \"#979605\", \"#ec9c88\", \"#8c48a3\", \"#676769\", \n    \"#546e64\", \"#8f63a2\", \"#b35b2d\", \"#7b8ca2\", \"#b87188\", \"#4a9bda\", \"#eb7dab\", \"#f6a602\", \"#cab3fe\", \n    \"#ddb8bb\", \"#107959\", \"#885973\", \"#5e858e\", \"#b15bad\", \"#e107a7\", \"#2f9dad\", \"#4b9e83\", \"#b992dc\", \n    \"#6bb0cb\", \"#bdb363\", \"#ccd6e4\", \"#a3ee94\", \"#9ef718\", \"#fbe1d9\", \"#a428a5\", \"#93514c\", \"#487434\", \n    \"#e8f1b6\", \"#d00938\", \"#fb50e1\", \"#fa85e1\", \"#7cd40a\", \"#f1ade1\", \"#b1485d\", \"#7f76d6\", \"#d186b3\", \n    \"#90c25e\", \"#b8c813\", \"#a8c9de\", \"#7d30fe\", \"#815f2d\", \"#737f3b\", \"#c84486\", \"#946cfe\", \"#e55432\", \n    \"#a88674\", \"#c17a47\", \"#b98b91\", \"#fc4bb3\", \"#da7f5f\", \"#df920b\", \"#b7bbba\", \"#99e6d9\", \"#a36170\", \n    \"#c742d8\", \"#947f9d\", \"#a37d93\", \"#889072\", \"#9b924c\", \"#23b4bc\", \"#e6a25f\", \"#86df9c\", \"#a7da6c\", \n    \"#3fee03\", \"#eec9d8\", \"#aafdcb\", \"#7b9139\", \"#92979c\", \"#72788a\", \"#994cff\", \"#c85956\", \"#7baa1a\", \n    \"#de72fe\", \"#c7bad8\", \"#85ebfe\", \"#6e6089\", \"#9b4d31\", \"#297a1d\", \"#9052c0\", \"#5c75a5\", \"#698eba\", \n    \"#d46222\", \"#6da095\", \"#b483bb\", \"#04d183\", \"#9bcdfe\", \"#2ffe8c\", \"#9d4279\", \"#c909aa\", \"#826cae\"]\n\nexport let genome : Genome;\n\nfunction parseGenomicBins(data: string, applyLog: boolean, applyClustering: boolean): Promise<GenomicBin[]> {\n    return new Promise((resolve, reject) => {\n        parse(data, {\n            cast: true,\n            columns: true,\n            delimiter: \"\\t\",\n            skip_empty_lines: true,\n        }, (error, parsed) => {\n            if (error) {\n                reject(error);\n                return;\n            }\n\n            \n            let end = 0;\n            let lastChr = parsed[0][\"#CHR\"];\n            let chrNameLength: any = [];\n\n            for (const bin of parsed) {\n                if(!applyClustering) {\n                    bin.CLUSTER = -1;\n                }\n\n                bin.logRD = Math.log2(bin.RD);\n\n                if(lastChr !==  bin[\"#CHR\"]) {\n                    chrNameLength.push({name: lastChr, length: (end - 0)})\n                    lastChr = bin[\"#CHR\"]\n                }\n\n                end = Number(bin.END);\n                bin.reverseBAF = 0.5 - bin.BAF;\n            }\n\n            chrNameLength.push({name: lastChr, length: (end - 0)})\n\n            chrNameLength.sort((a: any, b : any) => {\n                return a.name.localeCompare(b.name, undefined, {\n                    numeric: true,\n                    sensitivity: 'base'\n                })\n            })\n\n            genome = new Genome(chrNameLength);\n            \n            for (const bin of parsed) {\n                bin.genomicPosition = genome.getImplicitCoordinates(new ChromosomeInterval(bin[\"#CHR\"], bin.START, bin.END)).start;\n            }\n\n\n            resolve(parsed);\n        });\n    })\n}\n\nfunction parseDriverGenes(data: string): Promise<Gene[]> {\n    return new Promise((resolve, reject) => {\n        parse(data, {\n            cast: true,\n            columns: true,\n            delimiter: \"\\t\",\n            skip_empty_lines: true,\n            skip_lines_with_error: true\n        }, (error, parsed) => {\n\n            if (error) {\n                reject(error);\n                return;\n            }\n\n            for(const gene of parsed) {\n                const components : string[] = gene[\"Genome Location\"].split(\":\");\n                const start_end = components[1].split(\"-\");\n                let interval : ChromosomeInterval = new ChromosomeInterval(components[0], Number(start_end[0]), Number(start_end[1]));\n                gene.location = interval;\n            }\n\n            resolve(parsed);\n        });\n    })\n}\n\n/**\n * Possible states of processing input data.\n */\nexport enum ProcessingStatus {\n    /** No data input (yet) */\n    none,\n\n    /** Reading data into memory */\n    readingFile,\n\n    /** Reformatting, aggregating, converting, or otherwise analyzing data. */\n    processing,\n\n    /** The results of data processing step are available. */\n    done,\n\n    /** An error happened during any step. */\n    error\n}\n\ninterface State {\n    /** Current status of reading/processing input data */\n    processingStatus: ProcessingStatus;\n\n    /** Indexed data */\n    indexedData: DataWarehouse;\n    \n    /** Current genomic location that the user has selected.  Null if no such location. */\n    hoveredLocation: ChromosomeInterval | null;\n\n    /** Name of the chromosome selected for detailed viewing.  Empty string if no chromosome is selected. */\n    selectedChr: string;\n\n    selectedCluster: string;\n\n    invertAxis: boolean;\n\n    sampleAmount: number;\n\n    color: string;\n\n    colors: string[];\n\n    assignCluster: boolean;\n\n    assigned: boolean;\n    \n    applyLog: boolean;\n\n    applyClustering: boolean;\n\n    inputError: boolean;\n    \n    value: string;\n\n    updatedBins: boolean;\n\n    selectedSample: string;\n\n    displayMode: DisplayMode;\n\n    showComponents: boolean[];\n\n    sidebar: boolean;\n\n    chosenFile: string;\n\n    showLinearPlot: boolean;\n\n    showScatterPlot: boolean;\n\n    showDirections: boolean;\n\n    showLog: boolean;\n\n    showCentroidTable: boolean;\n\n    showCentroids: boolean;\n\n    syncScales: boolean;\n\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n\n    driverGenes: Gene[] | null;\n\n    showSilhouttes: ProcessingStatus;\n\n    silhouttes: {\n        cluster: number;\n        avg: number;\n    }[];\n}\n\n\nexport enum DisplayMode {\n    zoom,\n    select,\n    boxzoom,\n    erase\n};\n\n/**\n * Top-level container.\n * \n * @author Silas Hsu\n */\n\nexport class App extends React.Component<{}, State> {\n    \n    constructor(props: {}) {\n        super(props);\n        \n        this.state = {\n            processingStatus: ProcessingStatus.none,\n            indexedData: new DataWarehouse([]),\n            hoveredLocation: null,\n            selectedChr: DataWarehouse.ALL_CHRS_KEY,\n            selectedCluster: DataWarehouse.ALL_CLUSTERS_KEY,\n            invertAxis: false,\n            sampleAmount: 1,\n            showComponents: [true],\n            color: 'blue',\n            colors:  CLUSTER_COLORS,\n            assignCluster: false,\n            assigned: false,\n            applyLog: false,\n            applyClustering: false,\n            inputError: false,\n            value: \"0\",\n            updatedBins: false,\n            selectedSample: \"\",\n            displayMode: DisplayMode.zoom,  \n            sidebar:  true,\n            chosenFile: \"\",\n            showLinearPlot: true,\n            showScatterPlot: true,\n            showDirections: false,\n            showLog: false,\n            showCentroidTable: false,\n            showCentroids: false,\n            syncScales: false,\n            scales: {xScale: null, yScale: null},\n            driverGenes: null,\n            showSilhouttes: ProcessingStatus.none,\n            silhouttes: []\n        };\n\n        this.handleFileChoosen = this.handleFileChoosen.bind(this);\n        this.handleDriverFileChosen = this.handleDriverFileChosen.bind(this);\n        this.handleChrSelected = this.handleChrSelected.bind(this);\n        this.handleClusterSelected = this.handleClusterSelected.bind(this);\n        this.handleLocationHovered = _.throttle(this.handleLocationHovered.bind(this), 50);\n        this.handleAxisInvert = this.handleAxisInvert.bind(this);\n        this.handleAddSampleClick = this.handleAddSampleClick.bind(this);\n        this.handleColorChange = this.handleColorChange.bind(this);\n        this.handleAssignCluster = this.handleAssignCluster.bind(this);\n        this.handleCallBack = this.handleCallBack.bind(this);\n        this.handleClusterAssignmentInput = this.handleClusterAssignmentInput.bind(this);\n        this.updateBrushedBins = this.updateBrushedBins.bind(this);\n        this.onClusterRowsChange = this.onClusterRowsChange.bind(this);\n        this.onClusterColorChange = this.onClusterColorChange.bind(this);\n        this.onSelectedSample = this.onSelectedSample.bind(this);\n        this.handleRemovePlot = this.handleRemovePlot.bind(this);\n        this.setDisplayMode = this.setDisplayMode.bind(this);\n        this.onSideBarChange = this.onSideBarChange.bind(this);\n        this.toggleLog = this.toggleLog.bind(this);\n        this.onToggleLinear = this.onToggleLinear.bind(this); \n        this.onToggleScatter = this.onToggleScatter.bind(this); \n        this.onToggleSync = this.onToggleSync.bind(this);\n        this.goBackToPreviousCluster = this.goBackToPreviousCluster.bind(this);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.onToggleShowCentroids = this.onToggleShowCentroids.bind(this);\n        this.onToggleSilhoutteBarPlot = this.onToggleSilhoutteBarPlot.bind(this);\n        this.onToggleDirections = this.onToggleDirections.bind(this);\n\n        let self = this;\n        d3.select(\"body\").on(\"keypress\", function(){\n            if (d3.event.key === \"z\") {\n                self.setState({displayMode: DisplayMode.zoom});\n            } else if (d3.event.key === \"b\") {\n                self.setState({displayMode: DisplayMode.select});\n            } else if(d3.event.key === \"a\") {\n                self.setState({displayMode: DisplayMode.boxzoom});\n            } else if(d3.event.key === \"e\") {\n                self.setState({displayMode: DisplayMode.erase});\n            } else if(d3.event.keyCode === 32) {\n                self.onSideBarChange(!self.state.sidebar);\n            } else if(d3.event.key === \"l\") {\n                self.setState({showLog: !self.state.showLog});\n            } else if(d3.event.key === \"c\") {\n                self.setState({showCentroidTable: !self.state.showCentroidTable});\n            } else if(d3.event.key === \"s\") {\n                self.onToggleSilhoutteBarPlot();\n            }\n        })\n\n        d3.select(\"body\").on(\"keydown\", function() {\n            if (self.state.displayMode === DisplayMode.zoom && d3.event.key === \"Shift\") {\n                self.setState({displayMode: DisplayMode.boxzoom})\n            } else if(d3.event.key === \"/\" || d3.event.key === \"?\") {\n                self.setState({showDirections: true})\n            } else if((self.state.displayMode === DisplayMode.zoom ||  self.state.displayMode === DisplayMode.erase) && d3.event.key === \"Meta\") {\n                self.setState({displayMode: DisplayMode.select})\n            } else if((self.state.displayMode === DisplayMode.zoom ||  self.state.displayMode === DisplayMode.select) && d3.event.key === \"Alt\") {\n                self.setState({displayMode: DisplayMode.erase})\n            } \n        })\n\n        d3.select(\"body\").on(\"keyup\", function(){\n            if (self.state.displayMode === DisplayMode.boxzoom && d3.event.key === \"Shift\") {\n                self.setState({displayMode: DisplayMode.zoom})\n            } else if(d3.event.key === \"/\" || d3.event.key === \"?\") {\n                self.setState({showDirections: false})\n            } else if(self.state.displayMode === DisplayMode.select && d3.event.key === \"Meta\") {\n                self.setState({displayMode: DisplayMode.zoom})\n            } else if(self.state.displayMode === DisplayMode.erase && d3.event.key === \"Alt\") {\n                self.setState({displayMode: DisplayMode.zoom})\n            }\n        });\n        \n    }\n\n    async handleFileChoosen(event: React.ChangeEvent<HTMLInputElement>, applyClustering: boolean) {\n        const files = event.target.files;\n        if (!files || !files[0]) {\n            return;\n        }\n\n        this.setState({chosenFile: files[0].name})\n        this.setState({processingStatus: ProcessingStatus.readingFile});\n        let contents = \"\";\n        try {\n            contents = await getFileContentsAsString(files[0]);\n        } catch (error) {\n            console.error(error);\n            this.setState({processingStatus: ProcessingStatus.error});\n            return;\n        }\n\n        this.setState({processingStatus: ProcessingStatus.processing});\n        let indexedData = null;\n        try {\n            const parsed = await parseGenomicBins(contents, this.state.applyLog, applyClustering);\n            indexedData = new DataWarehouse(parsed);\n\n        } catch (error) {\n            console.error(error);\n            this.setState({processingStatus: ProcessingStatus.error});\n            return;\n        }\n\n        this.setState({\n            indexedData: indexedData,\n            processingStatus: ProcessingStatus.done\n        });\n    }\n\n    async handleDriverFileChosen(event: React.ChangeEvent<HTMLInputElement>) {\n        const files = event.target.files;\n        if (!files || !files[0]) {\n            return;\n        }\n\n        let contents = \"\";\n        try {\n            contents = await getFileContentsAsString(files[0]);\n        } catch (error) {\n            console.error(error);\n            return;\n        }\n        \n        let driverGenes = null;\n        try {\n            const parsed = await parseDriverGenes(contents); //parseGenomicBins(contents, this.state.applyLog, );\n            driverGenes = parsed;\n            \n\n        } catch (error) {\n            console.error(error);\n            return;\n        }\n        this.setState({driverGenes: driverGenes});\n    }\n    \n    handleChrSelected(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedChr: event.target.value});\n        this.state.indexedData.setChrFilter(event.target.value);\n    }\n\n    handleClusterSelected(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedCluster: event.target.value});\n        this.state.indexedData.setClusterFilters([event.target.value]);\n    }\n\n    handleLocationHovered(location: ChromosomeInterval | null) {\n        if (!location) {\n            this.setState({hoveredLocation: null});\n            return;\n        }\n\n        this.setState({hoveredLocation: location});\n    }\n\n    handleClusterAssignmentInput(event: any) {\n        this.setState({value: event.target.value})\n    }\n\n    handleCallBack(selectedCluster: string | number) {\n        this.state.indexedData.updateCluster(Number(selectedCluster));\n        this.setState({assignCluster: false});\n        this.state.indexedData.setChrFilter(this.state.selectedChr);\n    }\n\n    updateBrushedBins(brushedBins: GenomicBin[]) {\n        this.state.indexedData.setbrushedBins(brushedBins);\n        this.setState({updatedBins: true});\n    }\n\n    handleAxisInvert() {\n        this.setState({invertAxis: !this.state.invertAxis});\n    }\n\n    handleAddSampleClick() {\n        const newShowComponents = this.state.showComponents.concat([true]);\n        this.setState({showComponents: newShowComponents});\n        this.setState({sampleAmount: this.state.sampleAmount + 1});\n    }\n\n    handleRemovePlot(plotId: number) {\n        let newShowComponents = [...this.state.showComponents];\n        newShowComponents.splice(plotId, 1);\n        this.setState({showComponents: newShowComponents});\n        this.setState({sampleAmount: this.state.sampleAmount - 1});\n    }\n\n    handleAssignCluster() {\n        this.setState({assignCluster: !this.state.assignCluster});\n    }\n\n    handleColorChange(color : any) {\n        this.setState({color: color.hex});\n    }\n\n    getStatusCaption() {\n        switch (this.state.processingStatus) {\n            case ProcessingStatus.readingFile:\n                return <div>Reading file... <img src={spinner} alt=\"Loading\" /></div>;\n            case ProcessingStatus.processing:\n                return <div>Processing data... <img src={spinner} alt=\"Loading\" /></div>;\n            case ProcessingStatus.error:\n                return \"ERROR\";\n            case ProcessingStatus.none:\n            case ProcessingStatus.done:\n            default:\n                return \"\";\n        }\n    }\n\n    onToggleDirections() {\n        this.setState({showDirections: !this.state.showDirections});\n    }\n\n    toggleLog() {\n        this.setState({\n            applyLog: !this.state.applyLog\n        });\n        this.state.indexedData.setShouldRecalculateSilhouttes(true);\n        \n    }\n\n    toggleClustering() {\n        this.setState({\n            applyClustering: !this.state.applyClustering\n        });\n    }\n\n    onClusterRowsChange(state: any) {\n        this.state.indexedData.setClusterFilters( state.selectedRows.map((d:any)  => String(d.key)));\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    onClusterColorChange(colors: string[]) {\n        let newColors = [];\n        for(const col of colors) {\n            newColors.push(col);\n        }\n        this.setState({colors: newColors});\n    }\n\n    onSelectedSample(selectedSample : any) {\n        this.setState({selectedSample : selectedSample});\n    }\n\n    setDisplayMode(mode: DisplayMode) {\n        this.setState({displayMode: mode});\n    }\n\n    onSideBarChange(sidebar: boolean) {\n        this.setState({sidebar: sidebar});\n    }\n\n    onToggleScatter(){\n        this.setState({showScatterPlot: !this.state.showScatterPlot});\n    }\n\n    onToggleLinear(){\n        this.setState({showLinearPlot: !this.state.showLinearPlot});\n    }\n\n    onToggleSync() {\n        this.setState({syncScales: !this.state.syncScales});\n    }\n\n    onToggleShowCentroids() {\n        this.setState({showCentroids: !this.state.showCentroids});\n    }\n\n    goBackToPreviousCluster() {\n        this.state.indexedData.undoClusterUpdate();\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    handleZoom(newScales: any) {\n        this.setState({scales: newScales});\n    }\n\n    async onToggleSilhoutteBarPlot() {\n        if(this.state.showSilhouttes === ProcessingStatus.none) {\n            this.setState({showSilhouttes: ProcessingStatus.processing});\n            this.state.indexedData.recalculateSilhouttes(this.state.applyLog).then((data: {cluster: number, avg: number}[] | undefined) => {\n                if(data !== undefined) {\n                    this.setState({silhouttes: data});\n                    this.setState({showSilhouttes: ProcessingStatus.done});\n                }\n            });\n        } else {\n            this.setState({showSilhouttes: ProcessingStatus.none});\n        }\n    }\n\n\n\n    render() {\n        const {indexedData, selectedChr, selectedCluster, hoveredLocation, invertAxis, color, assignCluster, updatedBins, value, sampleAmount} = this.state;\n        const samples = indexedData.getSampleList();\n        const brushedBins = indexedData.getBrushedBins();\n        const allData = indexedData.getAllRecords();\n        let mainUI = null;\n        let clusterTableData = indexedData.getClusterTableInfo();\n        let chrOptions : JSX.Element[] = [<option key={DataWarehouse.ALL_CHRS_KEY} value={DataWarehouse.ALL_CHRS_KEY}>ALL</option>];\n        let actions = indexedData.getActions();\n        if (this.state.processingStatus === ProcessingStatus.done && !indexedData.isEmpty()) {\n            const clusterTableData = indexedData.getClusterTableInfo();\n            const scatterplotProps = {\n                data: indexedData,\n                hoveredLocation: hoveredLocation || undefined,\n                onLocationHovered: this.handleLocationHovered,\n                invertAxis,\n                chr: selectedChr,\n                cluster: selectedCluster,\n                customColor: color,\n                colors: this.state.colors,\n                assignCluster,\n                onBrushedBinsUpdated: this.updateBrushedBins,\n                parentCallBack: this.handleCallBack,\n                brushedBins: brushedBins,\n                updatedBins: updatedBins,\n                onSelectedSample: this.onSelectedSample,\n                selectedSample: this.state.selectedSample,\n                dispMode: this.state.displayMode,\n                onRemovePlot: this.handleRemovePlot,\n                onAddSample: this.handleAddSampleClick,\n                clusterTableData: clusterTableData,\n                applyLog: this.state.applyLog,\n                onClusterSelected: this.handleClusterSelected,\n                onUndoClick: this.goBackToPreviousCluster,\n                showCentroids: this.state.showCentroids,\n                driverGenes: this.state.driverGenes\n            };\n\n            chrOptions = indexedData.getAllChromosomes().map(chr => <option key={chr} value={chr}>{chr}</option>);\n            chrOptions.push(<option key={DataWarehouse.ALL_CHRS_KEY} value={DataWarehouse.ALL_CHRS_KEY}>ALL</option>);\n\n            const clusterOptions = indexedData.getAllClusters().map((clusterName : string) =>\n                <option key={clusterName} value={clusterName}>{clusterName}</option>\n            );\n            clusterOptions.push(<option key={DataWarehouse.ALL_CLUSTERS_KEY} value={DataWarehouse.ALL_CLUSTERS_KEY}>ALL</option>);\n\n            mainUI = (\n                <div id=\"grid-container\">\n                    \n                    <div className=\"sampleviz-wrapper-row\">\n                            {_.times(sampleAmount, i => samples.length > i \n                            && this.state.showComponents[i] \n                            && <SampleViz \n                                    key={i}\n                                    {...scatterplotProps} \n                                    initialSelectedSample={samples[i]} \n                                    plotId={i}\n                                    showLinearPlot={this.state.showLinearPlot}\n                                    showScatterPlot={this.state.showScatterPlot}\n                                    showSidebar={this.state.sidebar}\n                                    sampleAmount={sampleAmount}\n                                    syncScales={this.state.syncScales}\n                                    handleZoom={this.handleZoom}\n                                    scales={this.state.scales}\n                                ></SampleViz>)}\n                    </div>\n                </div>);\n        }\n        \n        const status = this.getStatusCaption();\n\n        return <div className=\"container-fluid\">\n            <div>\n                <Sidebar \n                    selectedChr={selectedChr} \n                    onChrSelected={this.handleChrSelected} \n                    chrOptions={chrOptions}\n                    onAddSample={this.handleAddSampleClick}\n                    onAssignCluster={this.handleAssignCluster}\n                    tableData={clusterTableData}\n                    onClusterRowsChange={this.onClusterRowsChange}\n                    onClusterColorChange={this.onClusterColorChange}\n                    currentClusterFilters={indexedData.getFilteredClusters()}\n                    handleClusterAssignmentInput={this.handleClusterAssignmentInput}\n                    value={value}\n                    setDisplayMode={this.setDisplayMode}\n                    currentDisplayMode={this.state.displayMode} \n                    colors={this.state.colors}\n                    onSidebarChange={this.onSideBarChange}\n                    data={allData}\n                    onFileChosen={this.handleFileChoosen}\n                    chosenFile={this.state.chosenFile}\n                    show={this.state.sidebar}\n                    onToggleLog = {this.toggleLog}\n                    onToggleLinear={this.onToggleLinear}\n                    onToggleScatter={this.onToggleScatter}\n                    showScatter={this.state.showScatterPlot}\n                    showLinear={this.state.showLinearPlot}\n                    onToggleSync={this.onToggleSync}\n                    syncScales={this.state.syncScales}\n                    logData = {actions}\n                    onToggleShowCentroids= {this.onToggleShowCentroids}\n                    showCentroids= {this.state.showCentroids}\n                    onDriverFileChosen={this.handleDriverFileChosen}\n                    onToggleSilhouttes={this.onToggleSilhoutteBarPlot}\n                    showSilhouttes={this.state.showSilhouttes}\n                    onToggleDirections = {this.onToggleDirections}\n                />\n            </div>\n            \n            <div className={this.state.sidebar ? \"marginContent\" : \"\"}>\n                {status && <div className=\"App-status-pane\">{status}</div>}\n                {mainUI}\n\n                {this.state.showDirections && <div className=\"black_overlay\"></div> }\n                {this.state.showDirections && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\">Directions</h2>\n                        <div className=\"Exit-Popup\" onClick={this.onToggleDirections}> \n                            <FiX/>\n                        </div>\n                        <h5> Selection/Erasing </h5>\n                        <li> Hold down \"Command/Control\" in Zoom mode to temporarily enter Select mode </li>\n                        <li> Hold down \"Alt\" in Zoom mode to temporarily enter Erase mode </li>\n                        <li> To completely clear your selection, click anywhere in the plot while in Select/Erase mode </li>\n                        <li> To stay in Select mode without holding a button, you can click b or switch the toggle button in the sidebar </li>\n                        <li> To stay in Erase mode without holding a button, you can click e </li>\n                        <h5> Zoom Mode </h5>\n                        <li> The default mode is zoom mode</li>\n                        <li> In zoom mode, if you hold down shift, it will act as a bounding box zoom (in the scatterplot) </li>\n                        <h5> Other Key Modifiers </h5>\n                        <li> Click \"l\" to toggle a log of previous actions </li>\n                        <li> Click space to toggle the sidebar </li>\n                        <li> Hold down \"?\" or \"/\" button to open direction panel </li>\n                        <li> Click \"c\" to toggle a table of the centroids of each cluster for each sample </li>\n                        <li> Click \"s\" to toggle a bar plot displaying approximate average silhoutte scores for each cluster </li>\n\n                    </div> }\n\n                {this.state.showLog && <div className=\"black_overlay\"></div> }\n                {this.state.showLog && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\"> Previous Actions </h2>\n                        <div className=\"Exit-Popup\" onClick={()=> this.setState({showLog: !this.state.showLog})}> \n                            <FiX/>\n                        </div>\n                        <LogTable\n                            data={actions}\n                            onClusterColorChange={this.onClusterColorChange}\n                            onClusterRowsChange={this.onClusterRowsChange}\n                            colName={\"Actions (Starting from most recent)\"}\n                        ></LogTable>\n                    </div> }\n\n                {this.state.showCentroidTable && <div className=\"black_overlay\"></div> }\n                {this.state.showCentroidTable && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\"> Centroid Table </h2>\n                        <div className=\"Exit-Popup\" onClick={()=> this.setState({showCentroidTable: !this.state.showCentroidTable})}> \n                            <FiX/>\n                        </div>\n                        <ClusterTable\n                            data={indexedData.getCentroidData()}\n                            onClusterColorChange={this.onClusterColorChange}\n                            onClusterRowsChange={this.onClusterRowsChange}\n                            colors={CLUSTER_COLORS}\n                            currentFilters={[\"\"]}\n                            centroidTable={true}\n                            colOneName={\"Cluster\"}\n                            colTwoName={\"Sample\"}\n                            colThreeName={\"Centroid\"}\n                            cols={[{name: \"Cluster\", type: 'key'}, {name: \"Sample\", type: 'sample'}, {name: \"Centroid\", type: 'centroid'}]}\n                        ></ClusterTable>\n\n                    </div> }\n                \n                {this.state.showSilhouttes === ProcessingStatus.done && <div className=\"black_overlay\"></div> }\n                {this.state.showSilhouttes === ProcessingStatus.done && \n                    <div className=\"Directions2\">\n                        <h2 className=\"pop-up-window-header\"> Approximate Average Sillhoutte Coefficients </h2>\n                        <div className=\"Exit-Popup\" onClick={this.onToggleSilhoutteBarPlot}> \n                            <FiX/>\n                        </div>\n                        <BarPlot\n                            width={700}\n                            height={360}\n                            data={this.state.silhouttes}\n                            colors={CLUSTER_COLORS}\n                        ></BarPlot>\n                    </div> }\n            </div>\n            \n        </div>;\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}