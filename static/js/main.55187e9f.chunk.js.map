{"version":3,"sources":["model/OpenInterval.ts","model/ChromosomeInterval.ts","model/GenomicBin.ts","util.ts","constants.ts","model/DataWarehouse.ts","components/Scatterplot.tsx","components/DivWithBullseye.tsx","components/SampleViz2D.tsx","components/LinearPlot.tsx","components/RdrBafLinearPlots.tsx","components/SampleViz1D.tsx","components/ClusterTable.tsx","components/SampleViz.tsx","loading-small.gif","components/LogTable.tsx","model/Genome.ts","components/CSVLink.tsx","components/Sidebar.tsx","components/SilhouetteBarPlot.tsx","components/ClusterDistancesBarPlot.tsx","components/AnalyticsTab.tsx","components/Toolbox.tsx","components/LogLink.tsx","App.tsx","index.tsx"],"names":["OpenInterval","start","end","RangeError","this","other","Math","max","min","Symbol","iterator","ChromosomeInterval","chr","_interval","getLength","hasOverlap","multiple","floor","ceil","str","regexMatch","match","Number","parseInt","GenomicBinHelpers","toChromosomeInterval","bin","START","END","flattenNestedBins","arr","result","i","length","value","Array","isArray","push","getRelativeCoordinates","event","relativeTo","currentTarget","targetBoundingRect","getBoundingClientRect","x","clientX","left","y","clientY","top","niceBpCount","bases","sigFigs","sub","basesAmnt","rounded","toFixed","calculateEuclideanDist","pointOne","pointTwo","sqrt","Error","currentDiff","webglColor","color","col","d3","rgb","r","g","b","opacity","calculateInterClusterDist2","p","other_cluster","dists","_","mean","calculateIntraClusterDist2","cluster","dist","calculatesilhouettescores","rawData","clusteredData","labels","clusterDistanceMatrix","possible_clusters","keys","clusterToSilhoutte","Map","overall","downSamplePercent","bin1","c","cMap","binsInCluster","get","downSampledBinsInCluster","downSample","a","minB","Infinity","c2","otherCluster","downSampledOtherCluster","set","maxAB","s","has","previoussilhouettes","avg_cluster_silhouettes","val","undefined","avg","overall_sil","console","log","sortBy","data","percent","downSampledData","Set","original_len","new_len","size","random","add","isJsons","array","every","row","jsons2arrays","jsons","headers","headerLabels","from","map","json","Object","reduce","headerKeys","header","label","key","object","getHeaderValue","property","obj","foundValue","replace","split","o","splice","elementOrEmpty","element","joiner","separator","filter","e","column","join","toCSV","enclosingCharacter","jsons2csv","arrays2csv","string2csv","TypeError","DEFAULT_PURITY","CN_STATES","UNCLUSTERED_ID","DELETED_ID","TEMPORARY_COLUMNS","REQUIRED_COLS","REQUIRED_DRIVER_COLS","reformatBins","samples","applyLog","allRecords","Promise","resolve","reject","multiDimData","clusterToData","rdKey","CLUSTER","j","currentBin","reverseBAF","original","DataWarehouse","_rdRanges","_logRdRanges","_locationGroupedData","brushedBins","brushedCrossfilter","brushedClusterDim","_ndx","_sample_dim","_cluster_dim","_chr_dim","_genomic_pos_dim","_samples","_clusters","_chrs","_sampleGroupedData","clusterTableInfo","clusterTableInfo2","clusterTableInfo3","_cluster_filters","_cluster_filters_to","_cluster_filters_from","historyStack","_clusterAmounts","logOfActions","centroids","centroidPts","chrToClusters","centroidDistances","shouldCalculatesilhouettes","currentsilhouettes","overallSilhouette","rdMeans","_updateFractionalCopyNumbers","currentDataKey","sampleToPloidy","sampleToBafTicks","sampleToFractionalTicks","offset","initializeLocationGroupedData","crossfilter","dimension","d","String","groupedBySample","groupBy","entries","sample","binsForSample","groupedByCluster","union","values","binsForCluster","groupedByChr","clus","sampleDict","centroid","calculateCentroid","centroidPt","point","tempMap","centroidStr","centroidTableRow","SAMPLE","genomicPosition","allFiltered","cloneDeep","group","all","currentSampleBins","currentRdRange","minBy","RD","maxBy","currentLogRdRange","logRD","meanBy","getBAFLines","max_cn","getFractionalCNTicks","initializeCentroidDistMatrix","calculateClusterTableInfo","filterRecordsByScales","memoizeOne","memoize","updateFractionalCopyNumbers","args","shouldRecalculate","ploidy","contents","error","clustersilhouettes","sampleSpecificCentroids","getCentroidPoints","cluster1","cluster2","points","yAxis","scaleFactor","setOfClustersInChr","samplePts","clustersAssociatedWithChr","valueOf","copy","forEach","clusterInfo","clusterTable","binLocation","toString","getSampleList","rdRange","purity","startCN","endCN","maxCN","fractionalCNs","fractional_cn","fractionalTick","totalCN","slice","clusters","indexOf","filterAll","chrs","ALL_CHRS_KEY","bins","yAx","ALL_CLUSTERS_KEY","genomeRange","JSON","parse","stringify","brushedTableData","action","currentBAFRange","unshift","locKey","allBins","recalculateCentroids","remove","includes","setClusterFilters","cache","Cache","updateCluster","selectedSample","dataKey","newRecords","pop","allMergedBins","setShouldRecalculatesilhouettes","scalingFactor","sampleGroupedData","bafSeen","BAF_ticks","state","A","B","BAF_Tick","originalLen","new_val","tick","sortedBafLines","sampleAmount","clusterIdToAmount","amountInSelection","clusterTable2","totalBins","selectPerc","binPerc","implicitStart","implicitEnd","xScale","yScale","meanRD","fractionalSampleData","records","record","rd","binSample","fractionalTicks","bafTicks","valuesToCompare","minDist","minState","min_bin_rdr","MAX_VALUE","min_bin_baf","tickPair","bafVal","correspondingFractional","pow","CN_bin","CN_bin_rdr","CN_bin_baf","getCentroidData","sampledict","tokens","substring","centroid_cn","centroid_baf","min_cluster_rdr","min_cluster_baf","CN_cluster","CN_cluster_rdr","CN_cluster_baf","xthresharr","ythresharr","reassign","cluster_a","a_x","a_y","minDistFromCentroid","minCluster","cluster_b","b_x","b_y","xthresh","ythresh","sampleName","abs","reassign_groups","clusterName","cA","cB","groupID","c_index","reassign2","new_reassign_group","clusterTableData","getClusterTableInfo","currmaxcluster","currmaxper","MIN_VALUE","binper","toCluster","setbrushedBins","from_set","to_set","clusters_to","c_from","groupedByBin","binsAcrossSamples","min_x","min_y","to_c","c_x","c_y","underThresh","x_thr","y_thr","binarr","updateCluster_nolog","index","PADDING","UNCLUSTERED_COLOR","DELETED_COLOR","SCALES_CLASS_NAME","CIRCLE_GROUP_CLASS_NAME","nextCircleIdPrefix","Scatterplot","props","_svg","_circleIdPrefix","brushedNodes","previous_brushed_nodes","_canvas","_currXScale","_currYScale","_original_XScale","_original_YScale","_original_transform","_current_transform","scatter","zoom","onBrushedBinsUpdated","computeScales","handleMouseMove","bind","initializeListOfClusters","onZoom","resetZoom","width","height","bafScale","rdrScale","translate","scale","selectedCluster","quadTree","yAxisToPlot","addAll","sort","shift","hoveredRdBaf","invert","baf","domain","radius","onRecordsHovered","find","className","style","position","pointerEvents","hoveredLocation","hoveredRecords","currLoc","range","range2","yLabel","recordLocation","renderTooltipAtRdBaf","Fragment","clusterOptions","ref","node","zIndex","preserveAspectRatio","viewBox","onMouseMove","onClick","renderTooltip","redraw","forceHover","prevProps","some","scales","prevXScale","prevYScale","scalesUpdated","scaleOne","scaleTwo","scalesUpdated2","q","setState","forceUnhover","propsDidChange","isEqual","currentYDomain","newYDomain","log2","newScales","bafRange","useLowerBound","bafScaleRange","rdrScaleRange","rdLowerBound","showPurityPloidy","self","customColor","pointsize","colors","showTetraploid","displayMode","svg","selectAll","append","classed","attr","text","xAx","call","new_BAF_lines","currXDomain","BAF_lines","new_BAF_ticks","cn_pair_i","filteredBAFTicks","ticks","ticksWithoutOverlap","filterBAFTicksNoOverlap","first","tickValues","tickSizeInner","tickFormat","originalTicks","fractionalCNTicks","dom","upperBound","filteredTicks","filteredTicksVals","filterYAxisTicksNoOverlap","previous","gx","gy","z","zoomX","scaleExtent","zoomY","tx","ty","on","t","transform","k","sourceEvent","layerX","layerY","center","doX","doY","DisplayMode","boxzoom","translateBy","scaleBy","xDomain","yDomain","xDomain2","yDomain2","gl","getContext","clearColor","newData","fillColor","fc","col_index","chooseColor","pointSeries","crossValue","mainValue","context","decorate","program","depthFunc","NEVER","disable","DEPTH_TEST","select","erase","brush","keyModifiers","extent","updatePoints","selection","newRdRange","newBafRange","brush_endEvent","clear","COLOR_BUFFER_BIT","xr","rescaleX","yr","rescaleY","showCentroids","enter","type","chooseColor2","brushNodes","rect","uniqBy","toEraseSet","currNode","existingNode","currContains","genomeLocation","getElementsForGenomeLocation","React","Component","defaultProps","onNewCurveState","noop","onRecordHovered","DivWithBullseye","mouseCoordinates","storeMouseCoordinates","clearMouseCoordinates","onMouseLeave","children","otherProps","mergedStyle","assign","Bullseye","where","horizontalLineStyle","willChange","verticalLineStyle","SampleViz2D","handleCallBack","childData","parentCallBack","initialSelectedSample","handleSelectedSampleChanged","handleRecordsHovered","handleUpdatedBrushedBins","onRemovePlot","target","onSelectedSample","location","onLocationHovered","plotId","invertAxis","updatedBins","dispMode","myDisplayClasses","classnames","onClusterSelected","getLeftPadding","purityPloidyMode","LinearPlot","previewDriver","lockedDrivers","getXScale","handleMouseLeave","genome","yMin","yMax","collator","Intl","Collator","numeric","sensitivity","compare","driverGeneUpdate","gene","destination","dataKeyToPlot","delete","handleDriverGenesChange","onLinearPlotZoom","getChrStartMap","driverGenes","chromosomes","getChromosomeList","chrStarts","name","yLabelShift","getName","chrTicks","getChromosomeStarts2","xAxisTicksNoOverlap","filteredChrs","unused","findChrNumber","xAx2","baseNum","filterFractionalTicksNoOverlap","currYDomain","ticks_without_overlap","filterBAFTicks_no_overlap","getImplicitCoordinates","getCenter","mouseover","mouseleave","brushed","startEnd","dest","implicitCoords","boxWidth","backgroundColor","border","mouseX","implicitLocation","getChromosomeLocation","renderLockedDrivers","renderHighlight","shouldAddBack","drivers","label_divs","driver","idx","driverSymbol","symbol","shouldRenderLabel","w","currentCoord","coord","bottom","display","PureComponent","RDLinearPlot","BAFLinearPlot","SampleViz1D","sentDriver","sentGene","visualization","implicitRange","ClusterTable","table_data","handleColorChange","nextProps","hex","tempColors","onClusterColorChange","forceUpdate","updatedClusterTable","colOneName","colTwoName","colThreeName","colFourName","expandable","selectable","ExpandedComponent","onChangeComplete","conditionalRowStyles","when","alignItems","justifyContent","innerWidth","outerWidth","columns","selector","sortable","compact","wrap","right","columns3","centroidTable","colNames","centroidColumns","centroidCol","pagination","dense","paginationPerPage","paginationComponentOptions","rowsPerPageText","selectAllRowsItem","paginationRowsPerPageOptions","noContextMenu","noHeader","selectableRows","onSelectedRowsChange","onClusterRowsChange","selectableRowSelected","currentFilters","expandableRows","expandableRowsComponent","expandableRowDisabled","noDataComponent","padding","SampleViz","handleSelectedSampleChange","handleZoom","handleLinearPlotZoom","onUpdatePurity","onUpdatePloidy","onUpdateOffset","showPurityPloidyInputs","newScale","selected","genomicRange","yscale","reset","setSamplePloidy","syncScales","selectedRecords","getRecords","showLinearPlot","showScatterPlot","samplesShown","getRdRange","sampleOptions","disabled","getMeanRD","getSelectedBins","disableSelectOptions","getBrushedBins","verticalAlign","title","onChange","onChangeSample","onAddSample","nextAvailable","id","step","newPloidy","newPurity","newoffset","cols","LogTable","colName","Genome","_name","_chromosomes","_chrStarts","_length","nameToChr","chromosome","chrName","chrStart","implicit","sortedChrStarts","sortedLastIndex","chrCoordinate","convertToTsv","headings","CSV","csvLink","createRef","loading","handleFileDownload","csvContent","hiddenElement","document","createElement","href","encodeURIComponent","fileName","nameExt","newFileName","removeDateTime","currentDate","Date","month","getMonth","day","getDate","date","getFullYear","hrs","getHours","getMinutes","sec","getSeconds","time","download","click","onExport","src","spinner","alt","SIDEBAR_WIDTH","Sidebar","chosenFile","show","onSidebarChange","onFileChosen","processingStatus","ProcessingStatus","done","onDriverFileChosen","handleDemoDrivers","htmlFor","margin","selectedDemo","onDemoSelected","demoOptions","selectedChr","onChrSelected","chrOptions","selectedColor","onColorSelected","Box","sx","Slider","defaultValue","onChangeCommitted","handleslider","valueLabelDisplay","marks","onToggleLog","onToggleShowCentroids","checked","readOnly","onToggleScatter","showScatter","onToggleLinear","showLinear","onTogglePurityPloidy","onShowTetraploid","onTogglesilhouettes","onToggleShowCentroidTable","onToggleShowAbsorbBins","onTogglePreviousActionLog","onClearClustering","onUndoClick","tableData","currentClusterFilters","margins","SilhouetteBarPlot","showTooltip","tooltipX","tooltipY","renderTooltipContent","sortedData","marginRatio","offsetX","offsetY","bandwidth","tickSize","tickPadding","ClusterDistancesBarPlot","dataObjectArr","item","AnalyticsTab","silhouetteData","clusterDistances","onToggleSilhoutteBarPlot","avgClusterSilhouette","Toolbox","iconElement","currentDisplayMode","label2","setDisplayMode","Tool","Log","actions","logData","logFileContent","hiddenElement2","require","getFileContentsAsString","file","reader","FileReader","readAsText","onload","onerror","onabort","CLUSTER_COLORS","parseGenomicBins","applyClustering","cast","delimiter","skip_empty_lines","parsed","lastChr","chrNameLength","sampleGrouped","BAF","localeCompare","parseDriverGenes","validChromosomes","skip_lines_with_error","genes","components","start_end","interval","App","none","indexedData","absorbThresh_rdr","absorbThresh_baf","mergeThresh_rdr","mergeThresh_baf","mergeValues","assignCluster","assigned","sidebar","showDirections","showAbsorbBins","showLog","showCentroidTable","showSilhouettes","silhouettes","samplesNotShown","handleFileChoosen","handleDemoFileInput","handleDriverFileChosen","handleChrSelected","handleDemoSelected","handleColorSelection","handleAbsorbThresh_rdr","handleAbsorbThresh_baf","handleClusterSelected","handleLocationHovered","throttle","handleAxisInvert","handleAddSampleClick","handleAssignCluster","handleClusterAssignmentInput","updateBrushedBins","onClusterRowsToChange","onClusterColorToChange","onClusterRowsFromChange","onClusterColorFromChange","handleRemovePlot","onSideBarChange","toggleLog","onToggleSync","goBackToPreviousCluster","onToggleDirections","setProcessingStatus","changeDisplayedSamples","keyCode","files","readingFile","processing","initalDisplayedSamples","initalNotDisplayedSamples","url","window","reload","fetch","then","catch","status","getAllChromosomes","setChrFilter","newSample","oldSample","removedSample","getFilteredFromClusters","getFilteredToClusters","is_continue","absorbBins","mergestring","confirm","alert","assignAbsorb","mergeBinsAll","assignMerge","setDataKeyType","selectedRows","setClusterFiltersTo","setClusterFiltersFrom","newColors","mode","undoClusterUpdate","clearClustering","calculateCopyNumbers","calculateCopyNumbers_Cluster","recalculatesilhouettes","samplesDisplayed","allData","getAllRecords","mainUI","visualizeMerge","visualizeAbsorb","clusterTableData2","getClusterTableInfo2","clusterTableData3","getClusterTableInfo3","getActions","isEmpty","scatterplotProps","getAllClusters","times","placeholder","handleMergeThresh_baf","handleMergeThresh_rdr","absorbBinsAll","getStatusCaption","onAbsorbThresh_rdr","onAbsorbThresh_baf","onMergeThresh_rdr","onMergeThresh_baf","onAssignCluster","getFilteredClusters","marginLeft","overflowX","cursor","Provider","getAvgSilhouette","getClusterDistanceMatrix","ReactDOM","render","getElementById"],"mappings":"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AAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC7E,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC7E,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAClE,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC7E,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC7E,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAC7E,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UAAW,UACxF,UAAW,UAAW,UAAW,UAAW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","file":"static/js/main.55187e9f.chunk.js","sourcesContent":["/**\n * A 0-indexed open interval; e.g. [0, 3).  Intervals are iterable, so code can take advantage of the spread operator:\n * `myFunction(...interval)` is equivalent to `myFunction(interval.start, interval.end)`\n * \n * @author Silas Hsu\n */\nexport class OpenInterval {\n    /**\n     * Makes a new instance.  The input should represent a 0-indexed open interval.\n     * \n     * @param start - start of the interval, inclusive\n     * @param end - end of the interval, exclusive\n     * @throws {RangeError} if the end is less than the start\n     */\n    constructor(public readonly start: number, public readonly end: number) {\n        if (end < start) {\n            throw new RangeError(\"End cannot be less than start\");\n        }\n        this.start = start;\n        this.end = end;\n    }\n\n    /**\n     * Enables the spread operator for OpenIntervals.\n     */\n    *[Symbol.iterator] () {\n        yield this.start;\n        yield this.end;\n    }\n\n    /**\n     * @return the length of this interval\n     */\n    getLength(): number {\n        return this.end - this.start;\n    }\n\n    /**\n     * @return the center of this interval\n     */\n    getCenter(): number {\n        return 0.5 * (this.start + this.end);\n    }\n\n    /**\n     * Gets whether this interval overlaps or intersects with another one.\n     * \n     * @param other other OpenInterval with which to check for overlap\n     * @return whether this and the other interval overlap\n     */\n    hasOverlap(other: OpenInterval): boolean {\n        const intersectionStart = Math.max(this.start, other.start);\n        const intersectionEnd = Math.min(this.end, other.end);\n        return intersectionStart < intersectionEnd;\n    }\n\n    /**\n     * @return human-readable representation of this instance\n     */\n    toString(): string {\n        return `[${this.start}, ${this.end})`;\n    }\n}\n","import { OpenInterval } from \"./OpenInterval\";\n\n/**\n * A genomic region or position represented by a chromosome name and an open interval of 0-indexed base numbers.  For\n * example, \"chr1:0-3\" would represent the first, second and third bases of the chromosome called \"chr1\".\n * \n * Note that instances are immutable; they cannot be modified.  Create new instances to \"modify\" them.\n * \n * @author Silas Hsu\n */\nexport class ChromosomeInterval {\n    /** The chromosome's name. */\n    public readonly chr: string;\n\n    /** 0-indexed open interval of base numbers. */\n    private readonly _interval: OpenInterval;\n\n    /**\n     * Parses a string representing a ChromosomeInterval, such as those produced by the toString() method.  Throws an\n     * error if parsing fails.\n     * \n     * @param str interval to parse\n     * @return parsed instance\n     * @throws {RangeError} if parsing fails\n     */\n    static parse(str: string): ChromosomeInterval {\n        const regexMatch = str.match(/([\\w:]+)\\W+(\\d+)\\W+(\\d+)/);\n        if (regexMatch) {\n            const chr = regexMatch[1];\n            const start = Number.parseInt(regexMatch[2], 10);\n            const end = Number.parseInt(regexMatch[3], 10);\n            return new ChromosomeInterval(chr, start, end);\n        } else {\n            throw new RangeError(\"Could not parse interval\");\n        }\n    }\n\n    /**\n     * Makes a new instance.  The input interval should be 0-indexed and open; i.e [start, end)\n     * \n     * @param chr name of the chromosome\n     * @param start start base number of the region, inclusive\n     * @param end end base number of the region, exclusive\n     */\n    constructor(chr: string, start: number, end: number) {\n        if (start < 0) {\n            throw new RangeError(\"Start cannot be negative\");\n        }\n        this.chr = chr;\n        this._interval = new OpenInterval(start, end);\n    }\n\n    /**\n     * @return the start base number of this instance\n     */\n    get start(): number {\n        return this._interval.start;\n    }\n\n    /**\n     * Gets the end base number of this instance.  Since instances are represented as open intervals, note the base\n     * number returned by this method is not actually inside of the genomic region represented by this instance.\n     * \n     * @return the end base number of this instance\n     */\n    get end(): number {\n        return this._interval.end;\n    }\n\n    /**\n     * @return the number of bases represented by this instance\n     */\n    getLength(): number {\n        return this._interval.getLength();\n    }\n\n    /**\n     * Checks if this genomic region overlaps or intersects with another one.\n     * \n     * @param other other ChromosomeInterval with which to check for overlap\n     * @return whether this genomic region overlaps with another one\n     */\n    hasOverlap(other: ChromosomeInterval): boolean {\n        return this.chr === other.chr && this._interval.hasOverlap(other._interval);\n    }\n\n    /**\n     * @return human-readable representation of this instance\n     */\n    toString(): string {\n        return `${this.chr}:${this.start}-${this.end}`;\n    }\n\n    /**\n     * Gets a copy of this instance, with the start coordinate rounded down to the nearest multiple of `multiple` and\n     * the end coordinate rounded up to the nearest multiple of `multiple`.  Used for binning purposes.\n     * \n     * @param multiple - the multiple to round to\n     * @return new instance with rounded end coordinates\n     */\n    endsRoundedToMultiple(multiple: number): ChromosomeInterval {\n        if (multiple <= 0) {\n            throw new RangeError(`Cannot round to a multiple <= 0 (got ${multiple})`);\n        }\n        return new ChromosomeInterval(\n            this.chr,\n            Math.floor(this.start / multiple) * multiple,\n            Math.ceil(this.end / multiple) * multiple\n        );\n    }\n}\n","import { ChromosomeInterval } from \"./ChromosomeInterval\";\n\n/**\n * Represents one data point, or one row from a HATCHet .bbc file.  Called a \"bin\" because during data processing, the\n * genome is binned into equal sized chunks.\n */\nexport interface GenomicBin {\n    readonly \"#CHR\": string; // Despite this key implying that it is a number, it can contain values like \"chr3\"\n    readonly START: number;\n    readonly END: number;\n    readonly SAMPLE: string;\n    /** Read depth ratio */\n    RD: number;\n    readonly logRD: number;\n    readonly \"#SNPS\": number;\n    readonly COV: number;\n    readonly ALPHA: number;\n    readonly BETA: number;\n    \n    /** B allele frequency */\n    readonly BAF: number;\n\n    /** Cluster ID */\n    CLUSTER: number;\n\n    readonly cn_normal: number;\n    readonly u_normal: number;\n    readonly cn_clone1: number;\n    readonly u_clone1: number;\n    readonly cn_clone2: number;\n    readonly u_clone2: number;\n    \n    readonly reverseBAF: number;\n    readonly genomicPosition: number;\n    fractional_cn: number;\n    CN_bin: string;\n    CN_bin_rdr: number;\n    CN_bin_baf: number;\n    CN_cluster: string; \n    CN_cluster_rdr: number;\n    CN_cluster_baf: number; \n}\n\nexport const GenomicBinHelpers = {\n    /**\n     * Converts a GenomicBin to a ChromosomeInterval.\n     * \n     * @param bin the GenomicBin to convert\n     * @return ChromosomeInterval representing the genomic region of the GenomicBin\n     */\n    toChromosomeInterval: function(bin: GenomicBin): ChromosomeInterval {\n        return new ChromosomeInterval(bin[\"#CHR\"], bin.START, bin.END);\n    },\n\n    flattenNestedBins: function(arr : any, result : any[] = []) : any[] {\n        for (let i = 0, length = arr.length; i < length; i++) {\n          const value = arr[i];\n          if (Array.isArray(value)) {\n            this.flattenNestedBins(value, result);\n          } else {\n            result.push(value);\n          }\n        }\n        \n        return result;\n    }\n}\n","import * as d3 from \"d3\";\nimport { GenomicBin } from \"./model/GenomicBin\";\nimport _ from \"lodash\";\n\nexport interface Coordinate {\n    x: number;\n    y: number;\n}\n\ninterface Window {\n    webkitURL?: any;\n}\n\ndeclare var window2: Window;\n\n/**\n * Gets the x and y coordinates of a mouse event *relative to the top left corner of an element*.  By default, the\n * element is the event's `currentTarget`, the element to which the event listener has been attached.\n * \n * For example, if the top left corner of the element is at screen coordinates (10, 10) and the event's screen\n * coordinates are (11, 12), then this function will return `{x: 1, y: 2}`.\n * \n * @param {React.MouseEvent} event - the event for which to get relative coordinates\n * @param {Element} [relativeTo] - calculate coordinates relative to this element.  Default is event.currentTarget.\n * @return {Coordinate} object with props x and y that contain the relative coordinates\n */\nexport function getRelativeCoordinates(event: React.MouseEvent, relativeTo?: Element): Coordinate {\n    if (!relativeTo) {\n        relativeTo = event.currentTarget as Element;\n    }\n    const targetBoundingRect = relativeTo.getBoundingClientRect();\n    return {\n        x: event.clientX - targetBoundingRect.left,\n        y: event.clientY - targetBoundingRect.top\n    };\n}\n\n/**\n * Gets the device's pixel ratio.  Guaranteed to be a number greater than 0.\n * \n * @return {number} this device's pixel ratio\n */\nfunction getPixelRatioSafely(): number {\n    const pixelRatio = window.devicePixelRatio;\n    if (Number.isFinite(pixelRatio) && pixelRatio > 0) {\n        return pixelRatio;\n    } else {\n        return 1;\n    }\n}\n\n/**\n * Applies a fix for Retina (i.e. high pixel density) displays, to prevent a canvas from being blurry.\n * \n * @param {HTMLCanvasElement} canvas - canvas to modify\n */\nexport function applyRetinaFix(canvas: HTMLCanvasElement) {\n    const pixelRatio = getPixelRatioSafely();\n    if (pixelRatio !== 1) {\n        const width = canvas.width;\n        const height = canvas.height;\n\n        canvas.width = width * pixelRatio;\n        canvas.height = height * pixelRatio;\n        canvas.style.width = width + \"px\";\n        canvas.style.height = height + \"px\";\n        const ctx = canvas.getContext('2d')!;\n        ctx.scale(pixelRatio, pixelRatio);\n    }\n}\n\n/**\n * @param {number} bases - number of bases\n * @param {number} [sigFigs] - number of digits after the decimal point.  Default = 1\n * @return {string} human-readable string representing that number of bases\n */\nexport function niceBpCount(bases: number, sigFigs=1, sub?: number) {\n    \n    let basesAmnt = bases;\n    if(sub) {\n        basesAmnt = basesAmnt - sub;\n    }\n\n    if(basesAmnt < 0) {\n      return '';\n    }\n\n    const rounded = Math.floor(basesAmnt);\n    if (rounded >= 750000) {\n        return `${(rounded/1000000).toFixed(sigFigs)} Mb`;\n    } else if (rounded >= 10000) {\n        return `${(rounded/1000).toFixed(sigFigs)} kb`;\n    } else {\n        return `${rounded} bp`;\n    }\n}\n\n/**\n * Finds the object in `searchPoints` that is \"closest\" to `queryPoint`, and returns its index.  Returns -1 if given an\n * empty list. Uses euclidean distance.  Takes any type of object, but the object must contain keys that point to number\n * values.\n * \n * @param {T} queryPoint - the point for which to find the closest point in `searchPoints`\n * @param {T[]} searchPoints - points to search\n * @param {keyof T} xKey - key of the input objects, which should have a number value, to use as a \"x\" coordinate\n * @param {keyof T} yKey - key of the input objects, which should have a number value, to use as a \"y\" coordinate\n * @return {number} the index in `searchPoints` that contains the object closest to `queryPoint`\n */\nexport function getMinDistanceIndex<T>(queryPoint: T, searchPoints: T[], xKey: keyof T, yKey: keyof T): number {\n    let minDistance = Number.MAX_VALUE;\n    let minIndex = -1;\n    for (let i = 0; i < searchPoints.length; i++) {\n        const distance = squaredDistance(searchPoints[i], queryPoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minIndex = i;\n        }\n    }\n    return minIndex;\n\n    function squaredDistance(a: T, b: T) {\n        const xDiff = (a[xKey] as any) - (b[xKey] as any);\n        const yDiff = (a[yKey] as any) - (b[yKey] as any);\n        return xDiff * xDiff + yDiff * yDiff;\n    }\n}\n\nexport function calculateEuclideanDist(pointOne: number[] | string[] | Number[], pointTwo: number[] | string[] | Number[], sqrt?: boolean) : number {\n    if(pointOne.length !== pointTwo.length) {\n      throw Error(\"Calculate Euclidean Distance - pointOne dim does not match pointTwo dim\");\n    }\n\n    let result = 0;\n    for(let i = 0; i < pointOne.length; i++) {\n      const currentDiff = Number(pointOne[i]) - Number(pointTwo[i]);\n      result += currentDiff * currentDiff;\n    }\n\n    return (sqrt === true) ? Math.sqrt(result): result;\n}\n\n\n\n/**\n * Samples `numSamples` items from the input list by selecting equally-spaced elements.  If the list is shorter than the\n * desired number of samples, returns the entire list.  Note that if the input is sorted, the output will be sorted as\n * well.\n * \n * @param {T[]} list - list for which to sample\n * @param {number} numSamples - number of samples\n * @return {T[]} items sampled from the list\n */\nexport function sampleWithEqualSpacing<T>(list: T[], numSamples: number): T[] {\n    if (list.length <= numSamples) {\n        return list;\n    }\n\n    const samples: T[] = [];\n    for (let i = 0; i < numSamples; i++) {\n        const fractionIterated = i / numSamples;\n        const selectedIndex = Math.ceil(fractionIterated * list.length);\n        samples.push(list[selectedIndex]);\n    }\n    return samples;\n}\n\nexport const trunc = (str : string, len : number) =>\n  str.length > len ? str.substr(0, len - 1) + \"...\" : str;\n\nexport const webglColor = (color : string) => {\n    let col = d3.color(color);\n    if(col !== null) {  \n        const { r, g, b, opacity } = col.rgb();\n        return [r / 255, g / 255, b / 255, opacity];\n    }\n\n    return;\n}\n\nexport const iterateElements = (selector : any, fn : any) =>\n  [].forEach.call(document.querySelectorAll(selector), fn);\n\nexport const createNDCoordinate = (coordinates: [number, number][]) => {\n  const ndCoordinate = [];\n  for(const [x, y] of coordinates) {\n    ndCoordinate.push(x);\n    ndCoordinate.push(y);\n  }\n  return ndCoordinate;\n}\n\n\n/**\n * calculates the average Euclidean distance from p to every point in other_cluster\n * @param p point from which distances will be calculated\n * @param other_cluster a cluster that p is NOT a part of\n */\nexport const calculateInterClusterDist1D = (p: GenomicBin, other_cluster: GenomicBin[]) : number => {\n  let pointOne : [number, number] = [p.reverseBAF, p.RD];\n  let dists = [];\n  for(const bin of other_cluster) {\n    dists.push(calculateEuclideanDist(pointOne, [bin.reverseBAF, bin.RD], true));\n  }\n\n  return _.mean(dists);\n}\n\n\n/**\n * calculates the average Euclidean distance from p to every point in other_cluster\n * @param p point from which distances will be calculated\n * @param other_cluster a cluster that p is NOT a part of\n */\n export const calculateInterClusterDist2 = (p: number[] | Number[], other_cluster: number[][] | Number[][]) : number => {\n  let dists = [];\n  for(const bin of other_cluster) {\n    dists.push(calculateEuclideanDist(p, bin, true));\n  }\n\n  return _.mean(dists);\n}\n\n/**\n * calculates the average Euclidean distance from every point in cluster to p\n * @param p a single point within cluster\n * @param cluster cluster from which the distances from p will be calculated\n */\nexport const calculateIntraClusterDist1D = (p: GenomicBin, cluster: GenomicBin[]) => {\n  let pointOne : [number, number] = [p.BAF, p.RD];\n  let dists = [];\n  if(cluster.length === 1) {\n    return 0;\n  }\n\n  for(const bin of cluster) {\n    let pointTwo : [number, number] = [bin.BAF, bin.RD];\n    const dist = calculateEuclideanDist(pointOne, pointTwo, true);\n    if(dist !== 0) {\n      dists.push(dist);\n    }\n  }\n\n  return _.mean(dists)\n}\n\n\n/**\n * calculates the average Euclidean distance from every point in cluster to p\n * @param p a single point within cluster\n * @param cluster cluster from which the distances from p will be calculated\n */\n export const calculateIntraClusterDist2 = (p: number[], cluster: number[][] | Number[][]) => {\n  let dists = [];\n  if(cluster.length === 1) {\n    return 0;\n  }\n\n  for(const bin of cluster) {\n    const dist = calculateEuclideanDist(p, bin, true);\n    if(dist !== 0) {\n      dists.push(dist);\n    }\n  }\n\n  return _.mean(dists)\n}\n\nexport function distanceMatrix(data : any, distanceFn : any) {\n  const result = getMatrix(data.length);\n\n  // Compute upper distance matrix\n  for (let i = 0; i < data.length; i++) {\n    for (let j = 0; j <= i; j++) {\n      const bin1 = [data[i][0], data[i][1]];\n      const bin2 = [data[j][0], data[j][1]];\n      result[i][j] = distanceFn(bin1, bin2, true);\n      result[j][i] = result[i][j];\n    }\n  }\n\n  return result;\n}\n\nfunction getMatrix(size : number) {\n  const matrix = [];\n  for (let i = 0; i < size; i++) {\n    const row : number[] = [];\n    matrix.push(row);\n    for (let j = 0; j < size; j++) {\n      row.push(0);\n    }\n  }\n  return matrix;\n}\n\nexport function calculateoverallSilhouette(clustersilhouettes: {cluster: Number, avg: Number}[]) {\n  return _.meanBy(clustersilhouettes, \"avg\");\n}\n\nexport function calculatesilhouettescores(rawData: number[][], clusteredData: Map<Number, Number[][]>,  labels: number[], clusterDistanceMatrix : Map<number, Map<number, number>>) {\n  let possible_clusters = [...clusteredData.keys()];\n    let clusterToSilhoutte = new Map<number, number[] | undefined>();\n    if(possible_clusters.length === 1) {\n      return [];\n    }\n\n    let overall = 0;\n    // let clusterDistanceMatrix : Map<number, Map<number, number>> = new Map<number, Map<number, number>>();\n    const downSamplePercent = (rawData.length > 0) ? .01 : 1;\n    for(let i = 0; i < rawData.length; i++) {\n\n        const bin1 = rawData[i];\n        const c = labels[i];\n       \n        let cMap : Map<number, number> = new Map<number, number>();\n\n        const binsInCluster = clusteredData.get(c);\n        if(binsInCluster) {\n          if(binsInCluster.length === 1) {\n            if(clusterToSilhoutte.has(c)) {\n              const previoussilhouettes = clusterToSilhoutte.get(c);\n              if(previoussilhouettes) {\n                previoussilhouettes.push(0);\n                clusterToSilhoutte.set(c, previoussilhouettes);\n              }\n            } else {\n              clusterToSilhoutte.set(c, [0]);\n            }\n\n            continue;\n          }\n\n          // downsample both bins_in_clust er and bins_not_in_cluster\n          const downSampledBinsInCluster = downSample(binsInCluster, downSamplePercent);\n\n          const a = calculateIntraClusterDist2(bin1, downSampledBinsInCluster);\n          let minB = Infinity;\n          for(let c2 of possible_clusters) {\n            if(c2 !== c) {\n              const otherCluster = clusteredData.get(c2);\n              if(otherCluster) {\n                const downSampledOtherCluster = downSample(otherCluster, downSamplePercent);\n                const b = calculateInterClusterDist2(bin1, downSampledOtherCluster);\n                // clusterDistanceMatrix.get(c)\n                cMap.set(Number(c2), b);\n\n                if(b < minB) {\n                  minB = b;\n                }\n\n              } else {\n                throw new Error(\"Key error: Cluster not found\");\n              }\n            }\n          }\n\n          let maxAB = _.max([minB, a]);\n          if(maxAB) {\n            const s = (minB - a) / maxAB;\n            overall += s;\n            if(clusterToSilhoutte.has(c)) {\n              const previoussilhouettes = clusterToSilhoutte.get(c);\n              if(previoussilhouettes) {\n                previoussilhouettes.push(s);\n                clusterToSilhoutte.set(c, previoussilhouettes);\n              }\n            } else {\n              clusterToSilhoutte.set(c, [s]);\n            }\n          }\n        } else {\n          throw new Error(\"Key error: Cluster not found\");\n        }\n        clusterDistanceMatrix.set(c, cMap);\n    }\n\n    const avg_cluster_silhouettes = [];\n    for(const c of possible_clusters) {\n      const val = clusterToSilhoutte.get(Number(c));\n      if(val !== undefined) {\n        const avg = {cluster: Number(c), avg : _.mean(val)};\n        avg_cluster_silhouettes.push(avg);\n      }\n    }\n    const overall_sil = overall / rawData.length;\n    console.log(overall_sil);\n    const sorted = _.sortBy(avg_cluster_silhouettes, \"cluster\");\n    return sorted;\n}\n\n\n\n/**\n * Calculate Silhouette Coefficient\n * @param {Array<Array<number>>} data - list of input data samples\n * @param {Array<number>} labels - label values for each sample\n * @returns {number} score - Silhouette Score for input clustering\n */\n export default function silhouetteScore2(data: any, labels : any) {\n  /*\n\tTODO: Check X and Y for consistent length - enforce X to be 2D and Y 1D.\n\t\tThe length of Y should equal the number of rows in X, which in turn\n\t\tshould be non-empty and should contain only finite values - no NaN-s\n\t\tand Inf-s allowed. The same goes for Y. Check that number of labels\n\t\t(number of distinct values in Y) is valid. Valid values are from 2 to\n\t\tdata.length - 1 (inclusive)\".\n \t*/\n  let dist = distanceMatrix(data, calculateEuclideanDist);\n  let result = silhouetteSamples(dist, labels, silhouetteReduce);\n  return result.reduce((p : any, c : any, i : any) => p + (c - p) / (i + 1), 0);\n}\n\n/**\n * Calculate Silhouette for each data sample\n * @param {Array<Array<number>>} data - list of input data samples\n * @param {Array<number>} labels - label values for each sample\n * @param {Function|Mock} reduceFunction - reduce function to apply on samples\n * @returns {Array<number>} arr - Silhouette Coefficient for each sample\n */\nfunction silhouetteSamples(data : any, labels : any, reduceFunction : any) {\n  /*\n\tTODO: Check X and Y for consistent length - enforce X to be 2D and Y 1D.\n\t\tThe length of Y should equal the number of rows in X, which in turn\n\t\tshould be non-empty and should contain only finite values - no NaN-s\n\t\tand Inf-s allowed. The same goes for Y. Check that number of labels\n\t\t(number of distinct values in Y) is valid. Valid values are from 2 to\n\t\tdata.length - 1 (inclusive)\".\n\t */\n  let labelsFreq = countBy(labels); // # of points in each cluster\n  let samples = reduceFunction(data, labels, labelsFreq);\n  let denom = labels.map((val : any) => labelsFreq[val] - 1);\n  let intra = samples.intraDist.map((val : any, ind : any) => val / denom[ind]);\n  let inter = samples.interDist;\n  return inter\n    .map((val : any, ind : any) => val - intra[ind])\n    .map((val : any, ind : any) => val / Math.max(intra[ind], inter[ind]));\n}\n\n/**\n * Count the number of occurrences of each value in array.\n * @param {Array<number>} arr - Array of positive Integer values\n * @return {Array<number>} out - number of occurrences of each value starting from\n * 0 to max(arr).\n */\nfunction countBy(arr : any) {\n  let valid = arr.every((val : any) => {\n    if (typeof val !== 'number') return false;\n    return val >= 0.0 && Math.floor(val) === val && val !== Infinity;\n  });\n  if (!valid) throw new Error('Array must contain only natural numbers');\n\n  let out = Array.from({ length: Math.max(...arr) + 1 }, () => 0);\n  arr.forEach((value : any) => {\n    out[value]++;\n  });\n  return out;\n}\n\nfunction silhouetteReduce(dataChunk : any, labels : any, labelFrequencies : any) {\n  // datachunk: # of data points x # of data points in size\n\n  // clusterDistances is # of data points x # of clusters\n  // gives distance from each data point to every cluster\n  let clusterDistances : number[][] = dataChunk.map((row : any) => {\n      let ar = labelFrequencies.map((_ : any, mInd : any) => // mInd represents cluster we are going to run the function on\n        {\n          let test = labels.reduce(\n            (acc : any, val : any, rInd : any) => {\n              return (val === mInd ? acc + row[rInd] : acc + 0)\n            }, 0\n          )\n          return test;\n        }\n      )\n      return ar;\n    }\n  );\n\n  // Each row in clusterDistances represents a bin and its distances to each cluster\n  // So we for each bin we get the distance of that bin to the cluster that the bin is a part of\n  let intraDist = clusterDistances.map((val : any, ind : any) => val[labels[ind]]);\n\n  let interDist = clusterDistances\n    .map((mVal : any, mInd : any) => {\n      mVal[labels[mInd]] += Infinity; // don't want to pick the cluster that the current bin is a part of when taking the min so add infinity\n      labelFrequencies.forEach((fVal : any, fInd : any) => (mVal[fInd] /= fVal)); // avg distances in the row\n      return mVal;\n    })\n    .map((val : any) => Math.min(...val)); // take the (avg) distance to the closest cluster\n\n  return {\n    intraDist: intraDist,\n    interDist: interDist,\n  };\n}\n\n// function xmur3(str : string) {\n//   for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++) {\n//       h = Math.imul(h ^ str.charCodeAt(i), 3432918353);\n//       h = h << 13 | h >>> 19;\n//   }\n\n//   return function() {\n//       h = Math.imul(h ^ h >>> 16, 2246822507);\n//       h = Math.imul(h ^ h >>> 13, 3266489909);\n//       return (h ^= h >>> 16) >>> 0;\n//   }\n// }\n\n// function mulberry32(a : any) {\n//   return function() {\n//     var t = a += 0x6D2B79F5;\n//     t = Math.imul(t ^ t >>> 15, t | 1);\n//     t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n//     return ((t ^ t >>> 14) >>> 0) / 4294967296;\n//   }\n// }\n\nexport function downSample<T>(data: T[], percent: number) : T[] {\n  let downSampledData = new Set<T>();\n  const original_len = data.length;\n  const new_len = percent * original_len;\n  // var seed = xmur3(\"testseed\");\n  while(downSampledData.size < new_len) {\n    const rand_idx = Math.floor(Math.random() * original_len);\n    // const rand_idx = Math.floor(mulberry32(seed())() * original_len);\n    const bin = data[rand_idx];\n    downSampledData.add(bin);\n  }\n  \n  return [...downSampledData];\n}\n\n\n/**\nMIT License\n\nCopyright (c) 2019 react-csv\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n*/\n  /**\n * Simple safari detection based on user agent test\n */\nexport const isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\nexport const isJsons = ((array: any) => Array.isArray(array) && array.every(\n row => (typeof row === 'object' && !(row instanceof Array))\n));\n\nexport const isArrays = ((array: any) => Array.isArray(array) && array.every(\n row => Array.isArray(row)\n));\n\nexport const jsonsHeaders = ((array: any) => Array.from(\n array.map((json: any) => Object.keys(json))\n .reduce((a: any, b: any) => new Set([...a, ...b]), [])\n));\n\nexport const jsons2arrays = (jsons: any, headers: any) => {\n  headers = headers || jsonsHeaders(jsons);\n\n  // allow headers to have custom labels, defaulting to having the header data key be the label\n  let headerLabels = headers;\n  let headerKeys = headers;\n  if (isJsons(headers)) {\n    headerLabels = headers.map((header: any) => header.label);\n    headerKeys = headers.map((header: any) => header.key);\n  }\n\n  const data = jsons.map((object: any) => headerKeys.map((header: any) => getHeaderValue(header, object)));\n  return [headerLabels, ...data];\n};\n\nexport const getHeaderValue = (property: any, obj: any) => {\n  const foundValue = property\n    .replace(/\\[([^\\]]+)]/g, \".$1\")\n    .split(\".\")\n    .reduce(function(o: any, p: any, i: any, arr: any) {\n      // if at any point the nested keys passed do not exist, splice the array so it doesnt keep reducing\n      if (o[p] === undefined) {\n        arr.splice(1);\n        return null;\n      } else {\n        return o[p];\n      }\n    }, obj);\n  // if at any point the nested keys passed do not exist then looks for key `property` in object obj\n  return (foundValue === undefined) ? ((property in obj) ? obj[property] : '') : foundValue;\n}\n\nexport const elementOrEmpty = (element : any) => {\n  return (typeof element === 'undefined' || element === null) ? '' : element;\n};\n\nexport const joiner = ((data : any, separator = ',', enclosingCharacter = '') => {\n  return data\n    .filter((e : any) => e)\n    .map(\n      (row: any) => row\n        .map((element : any) => elementOrEmpty(element))\n        .map((column: any) => `${column}`)\n        .join(separator)\n    )\n    .join(`\\n`);\n});\n\nexport const arrays2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n joiner(headers ? [headers, ...data] : data, separator, enclosingCharacter)\n);\n\nexport const jsons2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n joiner(jsons2arrays(data, headers), separator, enclosingCharacter)\n);\n\nexport const string2csv = ((data: any, headers: any, separator: any, enclosingCharacter: any) =>\n  (headers) ? `${headers.join(separator)}\\n${data}`: data\n);\n\nexport const toCSV = (data: any, headers: any, separator: any, enclosingCharacter: any) => {\n if (isJsons(data)) return jsons2csv(data, headers, separator, enclosingCharacter);\n if (isArrays(data)) return arrays2csv(data, headers, separator, enclosingCharacter);\n if (typeof data ==='string') return string2csv(data, headers, separator, enclosingCharacter);\n throw new TypeError(`Data should be a \"String\", \"Array of arrays\" OR \"Array of objects\" `);\n};\n\nexport const buildURI = ((data : any, uFEFF: any, headers: any, separator: any, enclosingCharacter: any) => {\n  const csv = toCSV(data, headers, separator, enclosingCharacter);\n  const type = isSafari() ? 'application/csv' : 'text/csv';\n  const blob = new Blob([uFEFF ? '\\uFEFF' : '', csv], {type});\n  const dataURI = `data:${type};charset=utf-8,${uFEFF ? '\\uFEFF' : ''}${csv}`;\n\n  const URL = window.URL || window2.webkitURL;\n\n  return (typeof URL.createObjectURL === 'undefined')\n    ? dataURI\n    : URL.createObjectURL(blob);\n});\n\nexport const scaleRD = (rd: number, ploidy: number | null, meanRD: number | null) => {\n    if (!ploidy || !meanRD) {\n      return rd;\n    }\n\n    return rd * ploidy / meanRD;\n}","export const DEFAULT_PURITY = 0.5\nexport const DEFAULT_PLOIDY = 2\nexport const DEFAULT_OFFSET = 0\n\nexport const CN_STATES : [number, number][] = [[1, 1], [1, 0], [2, 0], [2, 1], [3, 1], [4, 2], [3, 2]];\n\nexport const START_CN = 0;\nexport const END_CN = 6; // highest total copy number from CN_STATES\nexport const UNCLUSTERED_ID = \"-1\";\nexport const DELETED_ID = \"-2\";\nexport const MAX_PLOIDY = 12;\nexport const MIN_PLOIDY = 1;\nexport const MAX_PURITY = 1;\nexport const MIN_PURITY = 0;\nexport const MAX_OFFSET = 1;\nexport const MIN_OFFSET = 0;\n\nexport type cn_pair = {tick: number, state:[number, number]};\nexport type fractional_copy_number = {fractionalTick: number, totalCN: number}\nexport const TEMPORARY_COLUMNS : Set<string> = new Set<string>([\"reverseBAF\", \"genomicPosition\", \"fractional_cn\", \"logRD\"]);\nexport const REQUIRED_COLS : string[] = [\"#CHR\", \"START\", \"END\", \"CLUSTER\", \"SAMPLE\", \"RD\", \"BAF\"]\nexport const REQUIRED_DRIVER_COLS : string[] = [\"symbol\", \"Genome Location\"];\n","import _, {memoize} from \"lodash\";\nimport { GenomicBin, GenomicBinHelpers } from \"./GenomicBin\";\nimport \"crossfilter2\";\nimport crossfilter, { Crossfilter } from \"crossfilter2\";\nimport memoizeOne from \"memoize-one\";\nimport {calculateEuclideanDist, calculatesilhouettescores, calculateoverallSilhouette, createNDCoordinate} from \"../util\"\nimport { DEFAULT_PLOIDY, CN_STATES, cn_pair, DEFAULT_PURITY, fractional_copy_number, START_CN, END_CN} from \"../constants\";\nimport { stringify } from \"querystring\";\n\nexport function reformatBins(samples: string[], applyLog: boolean, allRecords: readonly GenomicBin[]) : Promise<{multiDimData: number[][], clusterToData : Map<Number, Number[][]>, labels: number[]}> {\n    return new Promise<{multiDimData: number[][], clusterToData : Map<Number, Number[][]>, labels: number[]}>((resolve, reject) => {\n        const multiDimData = []; \n        const labels : number[] = [];\n        const clusterToData = new Map<Number, Number[][]>();\n        const rdKey = (applyLog) ? \"logRD\" :  \"RD\";\n\n        // Reformat data into multidimensional format for RDRs and BAFs\n        // Assumption: length of data % number of samples == 0\n        // Every genome range has the same number of samples\n        for(let i = 0; i < allRecords.length; i += samples.length) {\n            const row = [];\n            const c = allRecords[i].CLUSTER;\n            for(let j = i; j < i + samples.length; j++) {\n                if(j < allRecords.length) {\n                    const currentBin = allRecords[j];\n                    if(j === i) {\n                        labels.push(c);\n                    }\n                    row.push(currentBin.reverseBAF);\n                    row.push(currentBin[rdKey]);\n                } else {\n                    throw Error(\"Out of Range Error. There are bins missing in the data (bin must exist across all samples).\")\n                }\n            }\n\n            multiDimData.push(row);\n            if(clusterToData.has(c)) {\n                let original = clusterToData.get(c);\n                if(original !== undefined) {\n                    original.push(row);\n                    clusterToData.set(c, original);\n                }\n            } else {\n                clusterToData.set(c, [row]);\n            }\n        }\n         \n        let returnVal = {multiDimData: multiDimData, clusterToData: clusterToData, labels: labels};\n        resolve(returnVal);\n    });\n}\n\n/**\n * Nested dictionary type.  First level key is the sample name; second level key is cluster in that sample; third level key is the chromosome in the given sample with the given cluster.\n * \n * @typeParam T type of value stored\n */\ntype IndexedBioData<T> = {\n    [sample: string]: {\n        [cluster: string] : {\n            [chr: string]: T\n        }\n    }\n};\n\ntype LocationIndexedData<T> = {\n    [loc : string]: T\n};\n\nexport type ClusterIndexedData<T> = {\n    [cluster: string] : T\n}\n\ntype SampleIndexedData<T> = {\n    [sample: string] : T\n}\n\ntype LogTableRow = {\n    action: string\n}\n\ntype clusterIdMap = {[id: string] : number}\ntype clusterTableRow =  {key: number, value: number}\ntype selectionTableRow =  {key: number, value: number, selectPerc: number, binPerc: number}\ntype centroidPoint = {cluster: number, point: [number, number]}\ntype newCentroidTableRow = {key: string, sample: {[sampleName: string] : string}}\nexport type heatMapElem = {cluster1: number, cluster2: number, dist: number}\n\n/**\n * A container that stores metadata for a list of GenomicBin and allows fast queries first by sample, and then by\n * chromosome.  For applications that want a limited amount of data, pre-aggregates GenomicBin and allows fast queries\n * of that data too.\n * \n * @author Silas Hsu\n */\nexport class DataWarehouse {\n    /** The special chromosome name that signifies a query for the entire genome (all chromosomes). */\n    public static readonly ALL_CHRS_KEY : string = \"\"; \n    public static readonly ALL_CLUSTERS_KEY : string = \"\";\n\n    /** Indexed GenomicBin for supporting fast queries. */\n    //private _indexedData: IndexedBioData<GenomicBin[]>;\n    /** Indexed, pre-aggregated GenomicBin for supporting fast queries. */\n    //private _indexedMergedData: IndexedBioData<MergedGenomicBin[]>;\n    /** The range of read depth ratios represented in this data set.  First number is min, second is max. */\n    private readonly _rdRanges: SampleIndexedData<[number, number]>; // SampleIndexedData is a type we created (above) - map from sample to RD range\n    private readonly _logRdRanges: SampleIndexedData<[number, number]>; // same, but logRD range\n    private _locationGroupedData: LocationIndexedData<GenomicBin[]>; // with a specific location (chrm start end) - get bins across samples for this location range\n    private brushedBins: GenomicBin[]; // bins currently selected\n    private brushedCrossfilter: Crossfilter<GenomicBin>; // helpful for easily filtering across samples (external library) - set dimensions along which you want to filter \n    private brushedClusterDim: crossfilter.Dimension<GenomicBin, number>;\n    private _ndx: Crossfilter<GenomicBin>; // for all the data, n dimensions\n    private _sample_dim: crossfilter.Dimension<GenomicBin, string>; // different dimensions we want to sample across, sample, cluster, chr, genomic_pos\n    private _cluster_dim: crossfilter.Dimension<GenomicBin, number>;\n    private _chr_dim: crossfilter.Dimension<GenomicBin, string>;\n    private _genomic_pos_dim: crossfilter.Dimension<GenomicBin, number>;\n    private _samples: string[]; // list of samples\n    private _clusters: string[]; // list of clusters\n    private _chrs: string[];\n    private _sampleGroupedData: SampleIndexedData<GenomicBin[]>; // map from each sample to each bin that's relevant \n    private clusterTableInfo: clusterTableRow[]; // info on each cluster (type defined above)\n    private clusterTableInfo2: clusterTableRow[]; // info on each cluster (type defined above)\n    private clusterTableInfo3: clusterTableRow[]; // info on each cluster (type defined above)\n    private allRecords: readonly GenomicBin[]; // all the bins without the crossfilter\n    private _cluster_filters: String[]; // current clusters that we're filtering by \n    private _cluster_filters_to: String[]; // current clusters that we're filtering by \n    private _cluster_filters_from: String[]; // current clusters that we're filtering by \n    private historyStack: GenomicBin[][]; // for when we undo \n    private _clusterAmounts: readonly crossfilter.Grouping<crossfilter.NaturallyOrderedValue, unknown>[];//ChrIndexedData<GenomicBin[]>; \n    private logOfActions: LogTableRow[]; // log table that we export\n    private centroids: newCentroidTableRow[]; // one of these is for the centroids table we have\n    private centroidPts: SampleIndexedData<ClusterIndexedData<centroidPoint[]>>; // for the actual points we want to filter by so we can plot it \n    private chrToClusters: {[chr: string] : Set<string>} // mapping chr to clusters\n    private centroidDistances: SampleIndexedData<heatMapElem[]>; \n    private shouldCalculatesilhouettes: boolean;\n    private currentsilhouettes: {cluster: number,  avg: number}[];\n    private overallSilhouette: number;\n    private clusterDistanceMatrix : Map<number, Map<number, number>>;\n    private rdMeans: SampleIndexedData<number>;\n    private _updateFractionalCopyNumbers: any;\n    private currentDataKey: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">; // not sure if still used\n    private sampleToPloidy: SampleIndexedData<number>; // for each sample, there's a specific ploidy whenever user inputs into the box, make a call to this\n    private sampleToBafTicks: SampleIndexedData<cn_pair[]>; // similar ^\n    private sampleToFractionalTicks:  SampleIndexedData<number[]>; // ^\n    private offset: number; \n    // private showtetraploid: boolean; \n\n    // private totalcnToState: CNIndexedData<number[][]>;\n\n    /**\n     * Indexes, pre-aggregates, and gathers metadata for a list of GenomicBin.  Note that doing this inspects the entire\n     * data set, and could be computationally costly if the data set is large.\n     * \n     * @param rawData the data to process\n     * @param merger aggregator to use\n     * @throws {Error} if the data contains chromosome(s) with the reserved name of `DataWarehouse.ALL_CHRS_KEY`\n     */\n    constructor(rawData: GenomicBin[]) {\n        this._locationGroupedData = {};\n        this.initializeLocationGroupedData(rawData);\n        // console.log(this._locationGroupedData)\n        this._sampleGroupedData = {};\n        this._rdRanges = {};\n        this.rdMeans = {};\n        this._logRdRanges = {};\n        this._samples = [];\n        this._chrs = [];\n        this._clusters = [];\n        this.brushedBins = [];\n        this.brushedCrossfilter = crossfilter(this.brushedBins); \n        this.brushedClusterDim = this.brushedCrossfilter.dimension((d:GenomicBin) => d.CLUSTER); // set a dimension along cluster (from left sidebar)\n        this._cluster_filters = []; \n        this._cluster_filters_to = [];\n        this._cluster_filters_from = []; \n        this.historyStack = [];\n        this._ndx = crossfilter(rawData);\n        this.logOfActions = [];\n        this.centroidPts = {}; // used for plotting centroids\n        this.centroids = []; // used for displaying centroids in centroid table\n        this.chrToClusters = {};\n        this.centroidDistances = {};\n        this.shouldCalculatesilhouettes = true;\n        this.currentsilhouettes = [];\n        this.clusterDistanceMatrix = new Map<number, Map<number, number>>();\n        this.overallSilhouette = 0;\n        this.currentDataKey=\"RD\";\n        this.sampleToPloidy = {};\n        this.sampleToBafTicks = {};\n        this.sampleToFractionalTicks = {};\n        this.offset = 0; // gc: add offset to the BAF lines\n        // this.showtetraploid = true; \n\n        for(const d of rawData) {\n            if(this.chrToClusters[d[\"#CHR\"]])\n                this.chrToClusters[d[\"#CHR\"]].add(String(d.CLUSTER));\n            else\n                this.chrToClusters[d[\"#CHR\"]] = new Set([String(d.CLUSTER)]);\n        }\n\n        const groupedBySample = _.groupBy(rawData, \"SAMPLE\");\n        for (const [sample, binsForSample] of Object.entries(groupedBySample)) {\n            this._samples.push(sample);\n            const groupedByCluster = _.groupBy(binsForSample, \"CLUSTER\");\n            this._clusters = _.union(this._clusters, Object.keys(groupedByCluster));\n            for (const binsForCluster of Object.values(groupedByCluster)) {\n                const groupedByChr = _.groupBy(binsForCluster, \"#CHR\");\n                this._chrs = _.union(this._chrs, Object.keys(groupedByChr));\n            }\n        }\n\n        const groupedByCluster = _.groupBy(rawData, \"CLUSTER\");\n        for (const [clus, binsForCluster] of Object.entries(groupedByCluster)) {\n            const groupedBySample = _.groupBy(binsForCluster, \"SAMPLE\");\n            let sampleDict : {[sampleName: string] : string} = {};\n            for(const [sample, binsForSample] of Object.entries(groupedBySample)) {\n                this.sampleToPloidy[sample] = DEFAULT_PLOIDY;\n                \n                const centroid = this.calculateCentroid(binsForSample, this.currentDataKey);\n                let centroidPt : centroidPoint = {cluster: parseInt(clus), point: centroid};\n\n                if(this.centroidPts[sample] && this.centroidPts[clus]) {\n                    this.centroidPts[sample][clus].push(centroidPt);\n                } else if(this.centroidPts[sample]) {\n                    this.centroidPts[sample][clus] = [centroidPt];\n                } else  { \n                    let dataKey : string = clus;\n                    let tempMap : ClusterIndexedData<centroidPoint[]> = {};\n                    tempMap[dataKey] = [centroidPt];\n                    this.centroidPts[sample] = tempMap;\n                }\n\n                let centroidStr = \"(\" + centroid[0].toFixed(2) + \",\" + centroid[1].toFixed(2) + \")\";\n                sampleDict[sample] = centroidStr;\n            }\n\n            let centroidTableRow : newCentroidTableRow = {\n                key: clus,\n                sample: sampleDict\n            };\n            this.centroids.push(centroidTableRow);\n        }\n        \n\n        this._cluster_filters = this._clusters;\n        this._cluster_filters_to = this._clusters;\n        this._cluster_filters_from = this._clusters;\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this._genomic_pos_dim = this._ndx.dimension((d:GenomicBin) => d.genomicPosition);\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        \n\n        if (rawData.length > 0) {\n            for(const sample of this._samples) {\n                let currentSampleBins = this._sampleGroupedData[sample];\n                let currentRdRange : [number, number] = [_.minBy(currentSampleBins, \"RD\")!.RD, _.maxBy(currentSampleBins, \"RD\")!.RD];\n                let currentLogRdRange : [number, number] = [_.minBy(currentSampleBins, \"logRD\")!.logRD, _.maxBy(currentSampleBins, \"logRD\")!.logRD];\n                this.rdMeans[sample] = _.meanBy(currentSampleBins, \"RD\");\n                this._rdRanges[sample] = currentRdRange;\n                this._logRdRanges[sample] = currentLogRdRange;\n                \n            }\n        }\n\n        for (const sample in groupedBySample) {\n            this.getBAFLines(DEFAULT_PURITY, sample, this.offset);\n            const max_cn = ((this._rdRanges[sample][1]+1) * DEFAULT_PLOIDY / this.rdMeans[sample] - 2*(1-DEFAULT_PURITY)) / DEFAULT_PURITY;\n            this.getFractionalCNTicks(DEFAULT_PURITY, START_CN, END_CN, max_cn, sample);\n        }\n\n        this.initializeCentroidDistMatrix();\n        this.allRecords = this._ndx.all();\n        this.clusterTableInfo = this.calculateClusterTableInfo();\n        this.clusterTableInfo2 = this.calculateClusterTableInfo(); // gc\n        this.clusterTableInfo3 = this.calculateClusterTableInfo(); // gc\n\n        this.filterRecordsByScales = memoizeOne(this.filterRecordsByScales);\n        this.getBAFLines = memoizeOne(this.getBAFLines);\n\n        this._updateFractionalCopyNumbers = memoize(this.updateFractionalCopyNumbers, (...args) => {\n            return \"\" + args[0] + \"_\" + args[1] + \"_\" + args[2].length + \"_\" + args[3].join(\".\");\n        });\n    }\n\n    setShouldRecalculatesilhouettes(shouldRecalculate: boolean) {\n        this.shouldCalculatesilhouettes = shouldRecalculate;\n    }\n\n    getClusterDistanceMatrix() {\n        return this.clusterDistanceMatrix;\n    }\n\n    getAvgSilhouette() {\n        return this.overallSilhouette;\n    }\n\n    setSamplePloidy(sample: string, ploidy: number) {\n        this.sampleToPloidy[sample] = ploidy;\n    }\n\n    getSampleToPloidy() {\n        return this.sampleToPloidy;\n    }\n\n    async recalculatesilhouettes(applyLog: boolean) {\n        if(this.shouldCalculatesilhouettes) {\n            let contents = null;\n            try {\n                contents = await reformatBins(this._samples, applyLog, this.allRecords);\n            } catch (error) {\n                console.error(error);\n                return;\n            }\n            \n            const s = calculatesilhouettescores(contents.multiDimData, contents.clusterToData, contents.labels, this.clusterDistanceMatrix);\n            this.overallSilhouette = Number(calculateoverallSilhouette(s).toFixed(3));\n            this.currentsilhouettes = s;\n            this.shouldCalculatesilhouettes = false;\n        }\n        return this.currentsilhouettes;\n    }\n\n    initializeCentroidDistMatrix() {\n        for(const sample of this._samples) {\n            this.centroidDistances[sample] = [];\n            let sampleSpecificCentroids : centroidPoint[] = this.getCentroidPoints(sample);\n            for(const c of sampleSpecificCentroids) {\n                for(const c2 of sampleSpecificCentroids) {\n                    const d : number = calculateEuclideanDist(c.point, c2.point);\n                    this.centroidDistances[sample].push({cluster1: c.cluster, cluster2: c2.cluster, dist: d});\n                }\n            }\n        }\n    }\n\n    getCentroidDistMatrix(sample: string) {\n        return this.centroidDistances[sample];\n    }\n\n    calculateCentroid(points: GenomicBin[], yAxis: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">):  [number, number] {\n        return [_.meanBy(points, d => d.reverseBAF), _.meanBy(points, d => d[yAxis])];\n    }\n\n    getCentroidData() {\n        return this.centroids;\n    }\n\n    getCentroidPoints(sample: string, chr?: string, scaleFactor?: number) {\n        const samplePts = this.centroidPts[sample]; // Get centroids for a specific sample\n        \n        let clustersAssociatedWithChr = this._cluster_filters;\n        let setOfClustersInChr;\n        if(chr) {\n            setOfClustersInChr = this.chrToClusters[chr]; // All clusters that appear when filtered by the given chr\n        } else {\n            setOfClustersInChr = new Set(clustersAssociatedWithChr);\n        }\n       \n        let sampleSpecificCentroids : centroidPoint[] = [];\n        for(const cluster of clustersAssociatedWithChr) { // Go through all filtered clusters\n            if(setOfClustersInChr.has(cluster) && samplePts[cluster.valueOf()]) { // Check that the cluster appears when filtered by chr \n                sampleSpecificCentroids.push(samplePts[cluster.valueOf()][0]);\n            }\n        }\n\n        if(scaleFactor && scaleFactor !== 1) {\n            const copy = _.cloneDeep(sampleSpecificCentroids);\n            copy.forEach(d => d.point[1] = d.point[1] * scaleFactor);\n            return copy;\n        }\n\n        return sampleSpecificCentroids;\n    }\n\n    calculateClusterTableInfo() : clusterTableRow[] {\n        const clusterInfo = this._cluster_dim.group().all();\n        const clusterTable : clusterTableRow[] = [];\n        for(const row of clusterInfo) {\n            let value = Number(((Number(row.value)/this.allRecords.length) * 100).toFixed(2));\n            clusterTable.push(\n            {\n                key: Number(row.key), \n                value: value\n            });\n        }\n        return clusterTable;\n    }\n\n    initializeLocationGroupedData(rawData: GenomicBin[]) {\n        this._locationGroupedData = {};\n        for(const bin of rawData) {\n            const binLocation = GenomicBinHelpers.toChromosomeInterval(bin).toString();\n            if(this._locationGroupedData[binLocation]) {\n                this._locationGroupedData[binLocation].push(bin);\n            } else {\n                this._locationGroupedData[binLocation] = [bin];\n            }\n        }\n    }\n\n    /**\n     * @return whether this instance stores any data\n     */\n    isEmpty(): boolean {\n        return this.getSampleList().length === 0;\n    }\n\n    /**\n     * Gets the range of read depth ratios represented in this data set.  Returns the result as a 2-tuple; the first\n     * number is the min, and the second is the max.\n     * \n     * @return the range of read depth ratios represented in this data set\n     */\n    getRdRange(sample : string, log?: boolean, ploidy?: number): [number, number] {\n        const rdRange = (log) ? this._logRdRanges[sample] : this._rdRanges[sample];\n        const scaleFactor = 1;//(ploidy && !log) ?  ploidy / this.rdMeans[sample] : 1;\n        return [rdRange[0] * scaleFactor, rdRange[1] * scaleFactor];\n    }\n\n    getFractionCNRange(purity: number, startCN: number, endCN: number) : [number, number] {\n        return [purity * (startCN) + 2*(1 - purity),  purity * (endCN) + 2*(1 - purity)]\n    }\n\n    getFractionalCNTicks(purity: number, startCN: number, endCN: number, maxCN: number, sample: string) : fractional_copy_number[] {\n        const fractionalCNs : fractional_copy_number[] = [];\n        \n        for(let i = startCN; i <= endCN; i++) {\n            if (startCN === endCN) {\n                const fractional_cn = {fractionalTick: purity * (i) + 2*(1 - purity), totalCN: Number(\"x\")}\n                fractionalCNs.push(fractional_cn);\n            } else {\n                const fractional_cn = {fractionalTick: purity * (i) + 2*(1 - purity), totalCN: i}\n                fractionalCNs.push(fractional_cn);\n            }\n        }\n        \n        \n        this.sampleToFractionalTicks[sample] = fractionalCNs.map(d => d.fractionalTick);\n        // console.log(fractionalCNs.length);\n        if(endCN === maxCN) {\n            return fractionalCNs;\n        } else if(endCN < maxCN) {\n            for(let i = endCN+1; i <= maxCN; i++) {\n                if (endCN === maxCN) {\n                    const fractional_cn = {fractionalTick: purity * (i) + 2*(1 - purity), totalCN: Number(\"x\")}\n                    fractionalCNs.push(fractional_cn);\n                } else {\n                    const fractional_cn = {fractionalTick: purity * (i) + 2*(1 - purity), totalCN: i}\n                    fractionalCNs.push(fractional_cn);\n                }\n            }\n            return fractionalCNs;\n        } else {\n            return fractionalCNs.slice(0, maxCN+1);\n        }\n    }\n    /**\n     * @return a list of sample names represented in this data set\n     */\n    getSampleList(): string[] {\n        return this._samples;\n    }\n\n    /**\n     * @return a list of chromosome names represented in this data set\n     */\n    getAllChromosomes(): string[] {\n        return this._chrs;\n    }\n\n    getAllClusters(): string[] {\n        return this._clusters;\n    }\n\n    setFilters(sample?: string, chr?: string, clusters?: string[]) {\n        if(chr) { this._chr_dim.filter(d => d === chr); }\n\n        if(clusters) {\n            this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        }\n    }\n\n    setChrFilter(chr?: string) {\n        if(chr) {\n            this._chr_dim.filterAll();\n            this._chr_dim.filter(d => String(d) === String(chr));\n        } else {\n            this._chr_dim.filterAll();\n        }\n        \n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    setChrFilters(chrs?: string[]) {\n        if(chrs && ((chrs.length === 1 && chrs[0] === DataWarehouse.ALL_CHRS_KEY))) {\n            this._chr_dim.filterAll();\n        } else if(chrs) {\n            this._chr_dim.filterAll();\n            this._chr_dim.filter(d => chrs.indexOf(String(d)) === -1 ? false : true);\n        }\n    }\n\n    recalculateCentroids(key: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">, data?: GenomicBin[]) {\n        // console.log(\"Recalculating Centroids...\");\n        this.centroids = [];\n        this.centroidPts = {};\n        const bins = (data) ? data : this.allRecords\n        const groupedByCluster = _.groupBy(bins, \"CLUSTER\");\n        for (const [clus, binsForCluster] of Object.entries(groupedByCluster)) {\n            const groupedBySample = _.groupBy(binsForCluster, \"SAMPLE\");\n            let sampleDict : {[sampleName: string] : string} = {};\n            for(const [sample, binsForSample] of Object.entries(groupedBySample)) {\n                let yAx = (key === \"fractional_cn\") ? \"RD\" : key;\n                const centroid = this.calculateCentroid(binsForSample, yAx);\n                \n                let centroidPt : centroidPoint = {cluster: parseInt(clus), point: centroid};\n\n                if(this.centroidPts[sample] && this.centroidPts[clus]) {\n                    this.centroidPts[sample][clus].push(centroidPt);\n                } else if(this.centroidPts[sample]) {\n                    this.centroidPts[sample][clus] = [centroidPt];\n                } else  { \n                    let dataKey : string = clus;\n                    let tempMap : ClusterIndexedData<centroidPoint[]> = {};\n                    tempMap[dataKey] = [centroidPt];\n                    this.centroidPts[sample] = tempMap;\n                }\n                let centroidStr = \"(\" + centroid[0].toFixed(2) + \",\" + centroid[1].toFixed(2) + \")\";\n                sampleDict[sample] = centroidStr;\n            }\n\n            let centroidTableRow : newCentroidTableRow = {\n                key: clus,\n                sample: sampleDict\n            };\n            this.centroids.push(centroidTableRow);\n        }\n    }\n\n    setClusterFilters(clusters?: String[]) {\n        if(clusters && ((clusters.length === 1 && clusters[0] === DataWarehouse.ALL_CLUSTERS_KEY))) {\n            this._cluster_dim.filterAll();\n        } else if(clusters) {\n            this._cluster_dim.filterAll();\n            this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        }\n        if(clusters) {\n            this._cluster_filters = clusters;\n        }\n        \n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n    setClusterFiltersTo(clusters?: String[]) {\n        // console.log(\"setClustersFiltersTo\", clusters);            \n        if(clusters) {\n            this._cluster_filters_to = clusters;\n        }\n        // if(clusters && ((clusters.length === 1 && clusters[0] === DataWarehouse.ALL_CLUSTERS_KEY))) {\n        //     this._cluster_dim.filterAll();\n        // } else if(clusters) {\n        //     this._cluster_dim.filterAll();\n        //     this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        // }\n        // if(clusters) {\n        //     this._cluster_filters = clusters;\n        // }\n        \n        // this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n    setClusterFiltersFrom(clusters?: String[]) {\n        // console.log(\"setClustersFiltersFrom\", clusters);\n        if(clusters) {\n            this._cluster_filters_from = clusters;\n        }\n        // if(clusters && ((clusters.length === 1 && clusters[0] === DataWarehouse.ALL_CLUSTERS_KEY))) {\n        //     this._cluster_dim.filterAll();\n        // } else if(clusters) {\n        //     this._cluster_dim.filterAll();\n        //     this._cluster_dim.filter(d => clusters.indexOf(String(d)) === -1 ? false : true);\n        // }\n        // if(clusters) {\n        //     this._cluster_filters = clusters;\n        // }\n        \n        // this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    setGenomicPositionFilter(genomeRange: [number, number]) {\n        this._genomic_pos_dim.filterAll();\n        this._genomic_pos_dim.filter(d => d > genomeRange[0] && d < genomeRange[1]);\n\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    clearAllFilters() {\n        this._sample_dim.filterAll();\n        this._cluster_dim.filterAll();\n        this._chr_dim.filterAll();\n        this._sampleGroupedData = _.groupBy(this._ndx.allFiltered(), \"SAMPLE\");\n    }\n\n    getActions() {\n        return this.logOfActions;\n    }\n\n    updateCluster(cluster: number) {\n        if(!this.brushedBins || this.brushedBins.length === 0) {\n            return;\n        }\n        // console.log(\"Updating cluster to\", cluster); \n\n        this.historyStack.push(JSON.parse(JSON.stringify(this.brushedBins)));\n        let brushedTableData  = this.brushedTableData();\n        \n        // Create a description of the cluster update and store it\n        let action = \"Assigned to cluster \" + cluster + \" | \";\n        action += \"Clusters selected: \";\n        for(const row of brushedTableData) {\n            action += String(row.key) + \" (\" + String(row.value) + \"%), \";\n        }\n        action += \" | \"\n        let currentRdRange : [number, number] = [_.minBy(this.brushedBins, this.currentDataKey)![this.currentDataKey], _.maxBy(this.brushedBins, this.currentDataKey)![this.currentDataKey]];\n        let currentBAFRange : [number, number] = [_.minBy(this.brushedBins, \"reverseBAF\")!.reverseBAF, _.maxBy(this.brushedBins, \"reverseBAF\")!.reverseBAF];\n        \n        action += this.currentDataKey + \" Range of Selected: [\" + currentRdRange[0].toFixed(2) + \", \"+currentRdRange[1].toFixed(2) + \"] | \";\n        action += \"Allelic Imbalance Range of Selected: [\" + currentBAFRange[0].toFixed(2) + \", \"+currentBAFRange[1].toFixed(2) + \"]\";\n        this.logOfActions.unshift({action: action});\n        \n        // For each bin that was selected, update the cluster of that bin in every sample\n        for(let i = 0; i < this.brushedBins.length; i++) {\n            let locKey = GenomicBinHelpers.toChromosomeInterval(this.brushedBins[i]).toString();\n            if(this._locationGroupedData[locKey]) {\n                for(let j = 0; j < this._locationGroupedData[locKey].length; j++) {\n                    this._locationGroupedData[locKey][j].CLUSTER = cluster;\n                }\n            }\n        }\n\n        const allBins : GenomicBin[][] = Object.values(this._locationGroupedData);\n        let flattenNestedBins : GenomicBin[] = GenomicBinHelpers.flattenNestedBins(allBins);\n\n        this.centroids = [];\n        this.centroidPts = {};\n\n        // Update the clusters that correspond to each chromosome\n        this.chrToClusters = {};\n        for(const d of flattenNestedBins) {\n            if(this.chrToClusters[d[\"#CHR\"]]) {\n                this.chrToClusters[d[\"#CHR\"]].add(String(d.CLUSTER));\n                \n            } else {\n                this.chrToClusters[d[\"#CHR\"]] = new Set([String(d.CLUSTER)]); \n            }   \n        }\n\n        \n        // Steps to find centroids (in a format that can be displayed in the table properly)\n        // 1. group by cluster\n        // 2. Get each group of points with all matching cluster\n        // 3. Group by sample\n        // 4. Find centroid for that group of points\n        // 5. Create a Sample dictionary with each sample name mapped to centroid\n        // 6. Add dictionary to table row\n        // 7. Push table row into list of table rows\n        // 8. Move on to next cluster and repeat\n\n        this.recalculateCentroids(this.currentDataKey, flattenNestedBins);\n\n        this.initializeCentroidDistMatrix();\n\n        this._ndx.remove();\n        this._ndx = crossfilter(flattenNestedBins);\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this.brushedBins = [];\n        this.brushedCrossfilter.remove();\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        this.allRecords =  this._ndx.all(); \n        this.clusterTableInfo = this.calculateClusterTableInfo();\n        this.clusterTableInfo2 = this.calculateClusterTableInfo();\n        this.clusterTableInfo3 = this.calculateClusterTableInfo();\n        this.allRecords = this.allRecords.filter((d: GenomicBin) => d.CLUSTER !== -2);\n\n        if(!this._cluster_filters.includes(String(cluster))) {\n            this._cluster_filters.push(String(cluster));\n        }\n\n        // if(!this._cluster_filters_to.includes(String(cluster))) { // gc\n        //     this._cluster_filters_to.push(String(cluster));\n        // }\n        \n        // if(!this._cluster_filters_from.includes(String(cluster))) { // gc\n        //     this._cluster_filters_from.push(String(cluster));\n        // }\n\n        this.setClusterFilters(this._cluster_filters);\n        this.shouldCalculatesilhouettes = true;\n\n        this._updateFractionalCopyNumbers.cache = new _.memoize.Cache()\n    }\n\n    updateCluster_nolog(cluster: number) {\n        if(!this.brushedBins || this.brushedBins.length === 0) {\n            return;\n        }\n        // console.log(\"Updating cluster to\", cluster); \n\n        let brushedTableData  = this.brushedTableData();\n        \n        // Create a description of the cluster update and store it\n        let action = \"Assigned to cluster \" + cluster + \" | \";\n        action += \"Clusters selected: \";\n        for(const row of brushedTableData) {\n            action += String(row.key) + \" (\" + String(row.value) + \"%), \";\n        }\n        action += \" | \"\n        let currentRdRange : [number, number] = [_.minBy(this.brushedBins, this.currentDataKey)![this.currentDataKey], _.maxBy(this.brushedBins, this.currentDataKey)![this.currentDataKey]];\n        let currentBAFRange : [number, number] = [_.minBy(this.brushedBins, \"reverseBAF\")!.reverseBAF, _.maxBy(this.brushedBins, \"reverseBAF\")!.reverseBAF];\n        \n        action += this.currentDataKey + \" Range of Selected: [\" + currentRdRange[0].toFixed(2) + \", \"+currentRdRange[1].toFixed(2) + \"] | \";\n        action += \"Allelic Imbalance Range of Selected: [\" + currentBAFRange[0].toFixed(2) + \", \"+currentBAFRange[1].toFixed(2) + \"]\";\n        this.logOfActions.unshift({action: action});\n        \n        // For each bin that was selected, update the cluster of that bin in every sample\n        for(let i = 0; i < this.brushedBins.length; i++) {\n            let locKey = GenomicBinHelpers.toChromosomeInterval(this.brushedBins[i]).toString();\n            if(this._locationGroupedData[locKey]) {\n                for(let j = 0; j < this._locationGroupedData[locKey].length; j++) {\n                    this._locationGroupedData[locKey][j].CLUSTER = cluster;\n                }\n            }\n        }\n\n        const allBins : GenomicBin[][] = Object.values(this._locationGroupedData);\n        let flattenNestedBins : GenomicBin[] = GenomicBinHelpers.flattenNestedBins(allBins);\n\n        this.centroids = [];\n        this.centroidPts = {};\n\n        // Update the clusters that correspond to each chromosome\n        this.chrToClusters = {};\n        for(const d of flattenNestedBins) {\n            if(this.chrToClusters[d[\"#CHR\"]]) {\n                this.chrToClusters[d[\"#CHR\"]].add(String(d.CLUSTER));\n                \n            } else {\n                this.chrToClusters[d[\"#CHR\"]] = new Set([String(d.CLUSTER)]); \n            }   \n        }\n\n        \n        // Steps to find centroids (in a format that can be displayed in the table properly)\n        // 1. group by cluster\n        // 2. Get each group of points with all matching cluster\n        // 3. Group by sample\n        // 4. Find centroid for that group of points\n        // 5. Create a Sample dictionary with each sample name mapped to centroid\n        // 6. Add dictionary to table row\n        // 7. Push table row into list of table rows\n        // 8. Move on to next cluster and repeat\n\n        this.recalculateCentroids(this.currentDataKey, flattenNestedBins);\n\n        this.initializeCentroidDistMatrix();\n\n        this._ndx.remove();\n        this._ndx = crossfilter(flattenNestedBins);\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this.brushedBins = [];\n        this.brushedCrossfilter.remove();\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        this.allRecords =  this._ndx.all(); \n        this.clusterTableInfo = this.calculateClusterTableInfo();\n        this.clusterTableInfo2 = this.calculateClusterTableInfo();\n        this.clusterTableInfo3 = this.calculateClusterTableInfo();\n        this.allRecords = this.allRecords.filter((d: GenomicBin) => d.CLUSTER !== -2);\n\n        if(!this._cluster_filters.includes(String(cluster))) {\n            this._cluster_filters.push(String(cluster));\n        }\n\n        // if(!this._cluster_filters_to.includes(String(cluster))) { // gc\n        //     this._cluster_filters_to.push(String(cluster));\n        // }\n        \n        // if(!this._cluster_filters_from.includes(String(cluster))) { // gc\n        //     this._cluster_filters_from.push(String(cluster));\n        // }\n\n        this.setClusterFilters(this._cluster_filters);\n        this.shouldCalculatesilhouettes = true;\n\n        this._updateFractionalCopyNumbers.cache = new _.memoize.Cache()\n    }\n\n    clearClustering() {\n        this.brushedBins = [...this.allRecords];\n        this.updateCluster(-1);\n    }\n\n    getMeanRD(selectedSample: string) {\n        return this.rdMeans[selectedSample];\n    }\n\n    setDataKeyType(dataKey: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">) {\n        this.currentDataKey = dataKey;\n    }\n\n    undoClusterUpdate() {\n        if(this.historyStack.length === 0) {\n            return;\n        }\n\n        let newRecords = this.historyStack[this.historyStack.length-1];  \n        this.historyStack.pop();\n        for(let i = 0; i < newRecords.length; i++) {\n            let currentBin = newRecords[i];\n            let locKey = GenomicBinHelpers.toChromosomeInterval(currentBin).toString();\n            let cluster = currentBin.CLUSTER;\n\n            if(!this._cluster_filters.includes(String(cluster))) {\n                this._cluster_filters.push(String(cluster));\n            }\n\n            if(this._locationGroupedData[locKey]) {\n                for(let j = 0; j < this._locationGroupedData[locKey].length; j++) {\n                    this._locationGroupedData[locKey][j].CLUSTER = cluster;\n                }\n            }\n        }\n\n        const allMergedBins : GenomicBin[][] = Object.values(this._locationGroupedData);\n        let flattenNestedBins : GenomicBin[] = GenomicBinHelpers.flattenNestedBins(allMergedBins);\n\n        this.initializeCentroidDistMatrix();\n        this._ndx.remove();\n        this._ndx = crossfilter(flattenNestedBins);\n        this._sample_dim = this._ndx.dimension((d:GenomicBin) => d.SAMPLE);\n        this._cluster_dim = this._ndx.dimension((d:GenomicBin) => d.CLUSTER);\n        this._chr_dim = this._ndx.dimension((d:GenomicBin) => d[\"#CHR\"]);\n        this.brushedBins = [];\n        this.brushedCrossfilter.remove();\n        this._clusterAmounts = _.cloneDeep(this._cluster_dim.group().all());\n        this.allRecords =  this._ndx.all();\n        this.clusterTableInfo = this.calculateClusterTableInfo();\n        this.allRecords = this.allRecords.filter((d: GenomicBin) => d.CLUSTER !== -2);\n        \n        \n        this.setClusterFilters(this._cluster_filters);\n        this.setShouldRecalculatesilhouettes(true);\n    }\n\n    \n    // Note clusters isn't used but is needed for the memoize to realize that the filters have changed\n    updateFractionalCopyNumbers(ploidy: number, sample: string, data: GenomicBin[], clusters: String[]) { \n        const meanRD = this.rdMeans[sample];\n        const scalingFactor = ploidy / meanRD;\n        let sampleGroupedData = _.cloneDeep(data);\n        sampleGroupedData.forEach(d => d.fractional_cn = d.RD * scalingFactor);\n        // this.recalculateCentroids(\"fractional_cn\");\n        return sampleGroupedData;\n    }\n\n    getBAFLines(purity: number, sample: string, offset: number) { //}, showtetraploid: boolean) {  // gc: add offset as a parameter\n        const bafSeen = new Set<number>();\n        const BAF_ticks : cn_pair[] = [];\n\n        for(const state of CN_STATES) { // each CN state\n            const A = state[0]; \n            const B = state[1];\n            \n            if (A === 1 && B === 1) {\n                // console.log(\"INSIDE IF\");\n                const BAF_Tick = 0.5-(B * purity + 1 * (1 - purity)) / ((A + B) * purity + 2 * (1 - purity)) + offset; // gc: add offset\n                const originalLen = bafSeen.size;\n                bafSeen.add(BAF_Tick);\n                if(bafSeen.size !== originalLen) {\n                    const new_val : cn_pair = {tick: BAF_Tick, state: state};\n                    BAF_ticks.push(new_val);\n                }\n            } else {\n                const BAF_Tick = 0.5-(B * purity + 1 * (1 - purity)) / ((A + B) * purity + 2 * (1 - purity));\n                // console.log(\"BAF_Tick\", BAF_Tick, \"state\", state); \n                //if (B != 2 && showtetraploid) {\n                    const originalLen = bafSeen.size;\n                    bafSeen.add(BAF_Tick);\n                    if(bafSeen.size !== originalLen) {\n                        const new_val : cn_pair = {tick: BAF_Tick, state: state};\n                        BAF_ticks.push(new_val);\n                    }          \n                //}  \n            }\n        }\n\n        const sortedBafLines = _.sortBy(BAF_ticks, \"tick\");\n        this.sampleToBafTicks[sample] = sortedBafLines;\n        return sortedBafLines;\n    }\n\n    brushedTableData() {\n        \n        const sampleAmount = this._samples.length;\n        const clusterInfo = this._clusterAmounts;\n        // map each cluster to the amount of points in a single sample \n        // (Each sample contains the same amount of points so we divide by total amount of samples)\n        let clusterIdToAmount : clusterIdMap = {};\n        clusterInfo.forEach(row => clusterIdToAmount[Number(row.key)] = Number(row.value)/sampleAmount);\n        const amountInSelection = this.brushedBins.length;\n        const clusterTable = this.brushedClusterDim.group().all();\n\n        const clusterTable2 : selectionTableRow[] = [];\n        const totalBins = this._ndx.all().length;\n        for(const row of clusterTable) {\n            clusterTable2.push(\n            {\n                key: Number(row.key), \n                value: Number((Number(row.value)/Number(clusterIdToAmount[Number(row.key)]) * 100).toFixed(2)),\n                selectPerc: Number((Number(row.value)/Number(amountInSelection) * 100).toFixed(2)),\n                binPerc: Number((Number(row.value)/Number(totalBins / sampleAmount) * 100).toFixed(2))\n            });\n        }\n\n        \n        return clusterTable2;\n    }\n\n    /**\n     * Performs a query for records matching a sample and a chromosome.  To get all records matching a sample,\n     * regardless of chromosome, use the special chromosome name `DataWarehouse.ALL_CHRS_KEY`.  If either sample or\n     * chromosome are not present in the data, returns an empty list.\n     * \n     * @param sample sample name for which to find matching records\n     * @param chr chromosome name for which to find matching records\n     * @return a list of matching records\n     */\n    getRecords(sample: string, dataKey: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">, implicitStart: number | null, implicitEnd: number | null, xScale: [number, number] | null, yScale: [number, number] | null, meanRD: number, ploidy: number): GenomicBin[] {\n        if(sample in this._sampleGroupedData) {\n            if(dataKey === \"fractional_cn\") {\n                let fractionalSampleData = this._updateFractionalCopyNumbers(ploidy, sample, this._sampleGroupedData[sample], this._cluster_filters);\n                return this.filterRecordsByScales(fractionalSampleData, dataKey, implicitStart, implicitEnd, xScale, yScale, meanRD, ploidy);\n                \n            } else {\n                return this.filterRecordsByScales(this._sampleGroupedData[sample], dataKey, implicitStart, implicitEnd, xScale, yScale, meanRD, ploidy);\n            }\n        }\n        return [];\n    }\n\n    filterRecordsByScales(records: GenomicBin[], dataKey: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">, implicitStart: number | null, implicitEnd: number | null, xScale: [number, number] | null, yScale: [number, number] | null, meanRD: number, ploidy: number) : GenomicBin[] {\n        if((implicitStart && implicitEnd) && xScale && yScale) {\n            return records.filter(record => record.genomicPosition > implicitStart \n                && record.genomicPosition < implicitEnd \n                && record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n        } else if((implicitStart && implicitEnd) && xScale) {\n            return records.filter(record => record.genomicPosition > implicitStart \n                && record.genomicPosition < implicitEnd \n                && record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                )\n        } else if((implicitStart && implicitEnd) && yScale) {\n             return records.filter(record => record.genomicPosition > implicitStart \n                 && record.genomicPosition < implicitEnd \n                 && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                 )\n         } else if(xScale && yScale) {\n            return records.filter(record => \n                record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                && record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n         } else if (xScale) {\n            return records.filter(record => \n                record.reverseBAF > xScale[0] \n                && record.reverseBAF < xScale[1]\n                )\n        } else if(yScale) {\n            return records.filter(record => \n                record[dataKey] > yScale[0] \n                && record[dataKey] < yScale[1]\n                )\n        }\n\n        return records;\n        \n    }\n\n    getAllRecords() {\n        return this.allRecords;\n    }\n\n    getClusterTableInfo() {\n        return this.clusterTableInfo;\n    }\n\n    getClusterTableInfo2() {\n        return this.clusterTableInfo2;\n    }\n    getClusterTableInfo3() {\n        return this.clusterTableInfo3;\n    }\n\n    getFilteredClusters() {\n        return this._cluster_filters;\n    }\n\n    getFilteredFromClusters() {\n        return this._cluster_filters_from;\n    }\n\n    getFilteredToClusters() {\n        return this._cluster_filters_to;\n    }\n\n    setbrushedBins(brushedBins: GenomicBin[]) {\n        this.brushedBins = [];\n        this.brushedBins = brushedBins;\n        this.brushedCrossfilter.remove();\n        this.brushedCrossfilter = crossfilter(brushedBins);\n        this.brushedClusterDim = this.brushedCrossfilter.dimension((d:GenomicBin) => d.CLUSTER);\n    }\n\n    getBrushedBins() {\n        return this.brushedBins;\n    }\n\n    getClusterDim() {\n        console.log(\"cluster dimensions:\", this._cluster_dim);\n        return this._cluster_dim;\n    }\n\n    calculateCopyNumbers() {\n        for(let i = 0; i < this.allRecords.length; i++) { // loop over all bins\n            const sample = this.allRecords[i].SAMPLE; \n            const ploidy = this.sampleToPloidy[sample]; // sample ploidy\n            const meanRD = this.rdMeans[sample]; // average sample read depth\n            const rd = this.allRecords[i].RD; // cluster centroid read depth\n            this.allRecords[i].fractional_cn = rd * ploidy / meanRD; // fractional CN per bin\n        }   \n\n        for(let i = 0; i < this.allRecords.length; i++) {\n            const bin = this.allRecords[i];\n            const binSample = bin.SAMPLE;\n            const fractionalTicks = this.sampleToFractionalTicks[binSample];\n            const bafTicks = this.sampleToBafTicks[binSample];\n            const x = Number(bin.reverseBAF) + this.offset; // want this from cluster centroid\n            const y = bin.fractional_cn; // cluster's fractional CN\n            const valuesToCompare : [number, number][] = [];\n            let minDist : number = Infinity;\n            let minState : [number, number] = [-1, -1];\n\n            let min_bin_rdr : number = Number.MAX_VALUE; \n            let min_bin_baf : number = Number.MAX_VALUE;\n\n            for(let j=0; j < bafTicks.length; j++) {\n                const tickPair = bafTicks[j];\n                const state = tickPair.state;\n                const bafVal = tickPair.tick; // output the baf value \n                const totalCN = state[0] + state[1];\n                const correspondingFractional = fractionalTicks[totalCN]; // back calculate the cn\n                // * meanRD / ploidy\n                \n                valuesToCompare.push([bafVal, correspondingFractional]);\n                const dist = Math.pow(x - bafVal, 2) + Math.pow(y - correspondingFractional, 2);\n                if(dist < minDist) {\n                    minDist = dist;\n                    minState = state; // take the minimum, report the min BAF and min CN state RDR values\n                    min_bin_baf = bafVal; \n\n                    const meanRD = this.rdMeans[bin.SAMPLE];\n                    const ploidy = this.sampleToPloidy[bin.SAMPLE];\n                    min_bin_rdr = correspondingFractional * meanRD / ploidy;  // is this correct?\n                }\n            }\n            // add two columns for BAF and RDR\n            this.allRecords[i].CN_bin = \"(\"+minState[0]+\",\"+minState[1]+\")\";\n            this.allRecords[i].CN_bin_rdr = min_bin_rdr ; \n            this.allRecords[i].CN_bin_baf = min_bin_baf; \n        }\n\n    }\n\n    calculateCopyNumbers_Cluster() {\n        console.log(\"calculateCopyNumbers_Cluster()\");\n\n        let centroids = this.getCentroidData(); \n\n        for (var s of this._samples) {\n            console.log(\"sample\", s); \n\n            for (var centroid of Array.from(centroids)) {\n                \n                let key = centroid['key'];\n                let sampledict = centroid['sample'];\n\n                let coord = String(sampledict[s].substring(1).slice(0, -1)); \n                let tokens = coord.split(','); \n                let centroid_cn = tokens.pop();\n                let centroid_baf = Number(tokens.pop()) + this.offset; \n                // console.log(\"centroid\", coord); \n                // console.log(\"x: \" + String(centroid_baf) + \" y: \" + String(centroid_cn)); \n\n                const fractionalTicks = this.sampleToFractionalTicks[s]; \n                const bafTicks = this.sampleToBafTicks[s]; \n                const x = Number(centroid_baf); \n                const y = Number(centroid_cn);  \n                const valuesToCompare : [number, number][] = [];\n\n                let minDist : number = Infinity;\n                let minState : [number, number] = [-1, -1];\n                let min_cluster_rdr : number = Number.MAX_VALUE; \n                let min_cluster_baf : number = Number.MAX_VALUE;\n\n                // iterating over all bafTicks, calculate the minimum distance copy number for this centroid\n                for(let j=0; j < bafTicks.length; j++) {\n                    const tickPair = bafTicks[j];\n                    const state = tickPair.state;\n                    const bafVal = Number(tickPair.tick); // output the baf value \n                    const totalCN = state[0] + state[1];\n                    const correspondingFractional = Number(fractionalTicks[totalCN]); // back calculate the cn\n                    // * meanRD / ploidy\n                    // console.log(\"state: \" + String(state) + \" bafVal: \" + bafVal + \" corrFrac: \" + correspondingFractional);\n                    \n                    valuesToCompare.push([bafVal, correspondingFractional]);\n                    // console.log(\"x - bafVal \" + String(x - bafVal)); \n                    // console.log(\"y - correspondingFractional\" + String(y - correspondingFractional)); \n                    const dist = Math.pow(x - bafVal, 2) + Math.pow(y - correspondingFractional, 2);\n                    // console.log(\"dist\" + String(dist)); \n                    \n                    if(dist < minDist) {\n                        minDist = dist;\n                        minState = state; // take the minimum, report the min BAF and min CN state RDR values\n                        min_cluster_baf = bafVal; \n\n                        const meanRD = this.rdMeans[s];\n                        const ploidy = this.sampleToPloidy[s];\n                        min_cluster_rdr = correspondingFractional * meanRD / ploidy;  \n                        \n                    }\n                }\n                \n                for(let i = 0; i < this.allRecords.length; i++) {\n                    if ((this.allRecords[i].SAMPLE == s) && (this.allRecords[i].CLUSTER == Number(key))) {\n                        this.allRecords[i].CN_cluster = \"(\"+minState[0] +\",\"+minState[1]+\")\";\n                        this.allRecords[i].CN_cluster_rdr = min_cluster_rdr;\n                        this.allRecords[i].CN_cluster_baf = min_cluster_baf; \n                    } \n                }\n                console.log(\"(\" + minState[0] + \",\" + minState[1]+\")\", min_cluster_rdr, min_cluster_baf); \n\n            }\n        }\n    }\n\n    mergeBinsAll(sample: string, xthresharr: Map<String, number>, ythresharr: Map<String, number>) {\n        console.log(\"inside mergeBins()... with\", xthresharr, ythresharr); \n        const reassign = new Map();\n        const bins = this.allRecords;\n\n        // Get centroids for a specific sample\n        const samplePts = this.centroidPts[sample]; \n        // iterate over all clusters centroids \n        this.getCentroidPoints(sample);\n        for (var cluster_a of Array.from(this._clusters.values())) {            \n            // console.log(\"samplePts[c_bin]\", samplePts[String(cluster_a)]);\n            // console.log(\"centroid:\", centroid);\n            if (String(cluster_a) in samplePts) { // this will throw error if cluster_b no longer exists\n                let centroid = samplePts[String(cluster_a)][0]; \n                let a_x : number = centroid.point[0];\n                let a_y : number = centroid.point[1]; \n                // console.log(\"c_x:\", c_x, \"c_y:\", c_y);\n\n                let minDistFromCentroid : number = Number.MAX_VALUE; \n                let minCluster : number = -2;\n                let min_x : number = Number.MAX_VALUE;\n                let min_y : number = Number.MAX_VALUE; \n\n                // iterate over all clusters' centroids\n                for (var cluster_b of Array.from(this._clusters.values())) {\n                    if (cluster_b != cluster_a && (String(cluster_b) in samplePts)) {\n                        // console.log(\"samplePts\", samplePts, \"cluster_b\", String(cluster_b)); \n                        let centroid = samplePts[String(cluster_b)][0]; // this will throw error if cluster_b no longer exists\n                        let b_x : number = centroid.point[0];\n                        let b_y : number = centroid.point[1]; \n        \n                        // calculate distance between centroids \n                        let xthresh : number = Number.MAX_VALUE;\n                        let ythresh : number = Number.MAX_VALUE; \n                        const dist = Math.sqrt((a_x - b_x)**2 + (a_y - b_y)**2);\n                        if (dist < minDistFromCentroid) {\n                            // console.log(\"xdistance\", Math.abs(a_x - b_x), \"xthresh\", xthresh, \"ythresh\", ythresh); \n                            for (let i = 0; i < this.getSampleList().length; i++) {\n                                let sampleName = String(this.getSampleList()[i]);\n                                xthresh = Number(xthresharr.get(sampleName));\n                                ythresh = Number(ythresharr.get(sampleName)); \n                                if (Math.abs(a_x - b_x) <= xthresh && Math.abs(a_y - b_y) <= ythresh) {\n                                    minCluster = Number(cluster_b); \n                                    minDistFromCentroid = dist;\n                                    min_x = Math.abs(a_x-b_x);\n                                    min_y = Math.abs(a_y-b_y);  \n                                    console.log(\"Closest Centroid Updated.\", String(cluster_b)); \n                                } else {\n                                    console.log(\"Not within threshold.\"); \n                                }\n                            }\n                        }\n                    }\n                }\n\n                // const dist = Math.sqrt((a_x - b_x)**2 + (a_y - b_y)**2);\n                if (minCluster != -2) {\n                    // map cluster to cluster\n                    reassign.set(String(minCluster), String(cluster_a)); // pick the larger cluster to absorb it into\n                }\n            }\n        }\n        const groupedByCluster = _.groupBy(bins, \"CLUSTER\");\n        console.log(\"Building sets of clusters\", reassign); \n\n        // build sets of clusters\n        const reassign_groups = new Map(); // maps every groupID to a set of related clusters\n        let index = 0; \n        for (var clusterName of Array.from(reassign.keys())) {\n            const cA = clusterName;\n            const cB = reassign.get(clusterName);\n            \n            let groupID = index; \n            // find which cluster they belong in\n            for (var c_index of Array.from(reassign_groups.keys())) {\n                if (reassign_groups.get(c_index).has(cA) || reassign_groups.get(c_index).has(cB)) {\n                    groupID = c_index; \n                }\n            }\n            // if it's an existing group\n            if (reassign_groups.has(groupID)) {\n                reassign_groups.get(groupID).add(cA);\n                reassign_groups.get(groupID).add(cB);\n            } else {\n                // it's a new group\n                const reassign2 = new Set();\n                reassign2.add(cA);\n                reassign2.add(cB); \n                reassign_groups.set(groupID, reassign2);\n            }\n        }\n\n        // find the largest cluster in each reassign_group\n        let new_reassign_group = new Map(); \n        // const clusterTable = this.brushedClusterDim.group().all();\n        let clusterTableData = this.getClusterTableInfo();\n        for (var groupID of Array.from(reassign_groups.keys())) {\n            const reassign2 = reassign_groups.get(groupID); \n            let currmaxcluster = ''; \n            let currmaxper = Number.MIN_VALUE;\n            console.log(\"groupID\", groupID); \n            for (const row of clusterTableData) {\n                if (reassign2.has(String(row.key))) { \n                    let binper = row.value; \n                    if (binper > currmaxper) {\n                        currmaxper = binper; \n                        currmaxcluster = String(row.key);\n                    }\n                }\n            }\n            console.log(\"Max Cluster\", currmaxcluster, currmaxper);\n            new_reassign_group.set(currmaxcluster, reassign_groups.get(groupID)); \n            console.log(new_reassign_group.get(currmaxcluster)); \n        }\n\n        return new_reassign_group; \n    }\n\n    mergeBins(sample: string, xthresh: number, ythresh: number) {\n        console.log(\"inside mergeBins()... with\", xthresh, ythresh); \n        const reassign = new Map();\n        const bins = this.allRecords;\n\n        // Get centroids for a specific sample\n        const samplePts = this.centroidPts[sample]; \n        // iterate over all clusters centroids \n        this.getCentroidPoints(sample);\n        for (var cluster_a of Array.from(this._clusters.values())) {            \n            // console.log(\"samplePts[c_bin]\", samplePts[String(cluster_a)]);\n            // console.log(\"centroid:\", centroid);\n            if (String(cluster_a) in samplePts) { // this will throw error if cluster_b no longer exists\n                let centroid = samplePts[String(cluster_a)][0]; \n                let a_x : number = centroid.point[0];\n                let a_y : number = centroid.point[1]; \n                // console.log(\"c_x:\", c_x, \"c_y:\", c_y);\n\n                let minDistFromCentroid : number = Number.MAX_VALUE; \n                let minCluster : number = -2;\n                let min_x : number = Number.MAX_VALUE;\n                let min_y : number = Number.MAX_VALUE; \n\n                // iterate over all clusters' centroids\n                for (var cluster_b of Array.from(this._clusters.values())) {\n                    if (cluster_b != cluster_a && (String(cluster_b) in samplePts)) {\n                        // console.log(\"samplePts\", samplePts, \"cluster_b\", String(cluster_b)); \n                        let centroid = samplePts[String(cluster_b)][0]; // this will throw error if cluster_b no longer exists\n                        let b_x : number = centroid.point[0];\n                        let b_y : number = centroid.point[1]; \n        \n                        // calculate distance between centroids \n                        const dist = Math.sqrt((a_x - b_x)**2 + (a_y - b_y)**2);\n                        if (dist < minDistFromCentroid) {\n                            // console.log(\"xdistance\", Math.abs(a_x - b_x), \"xthresh\", xthresh, \"ythresh\", ythresh); \n                            if (Math.abs(a_x - b_x) <= xthresh && Math.abs(a_y - b_y) <= ythresh) {\n                                minCluster = Number(cluster_b); \n                                minDistFromCentroid = dist;\n                                min_x = Math.abs(a_x-b_x);\n                                min_y = Math.abs(a_y-b_y);  \n                                console.log(\"Closest Centroid Updated.\", String(cluster_b)); \n                            } else {\n                                console.log(\"Not within threshold.\"); \n                            }\n                        }\n                    }\n                }\n\n                // const dist = Math.sqrt((a_x - b_x)**2 + (a_y - b_y)**2);\n                if (minCluster != -2) {\n                    // map cluster to cluster\n                    reassign.set(String(minCluster), String(cluster_a)); // pick the larger cluster to absorb it into\n                }\n            }\n        }\n        const groupedByCluster = _.groupBy(bins, \"CLUSTER\");\n        console.log(\"Building sets of clusters\", reassign); \n\n        // build sets of clusters\n        const reassign_groups = new Map(); // maps every groupID to a set of related clusters\n        let index = 0; \n        for (var clusterName of Array.from(reassign.keys())) {\n            const cA = clusterName;\n            const cB = reassign.get(clusterName);\n            \n            let groupID = index; \n            // find which cluster they belong in\n            for (var c_index of Array.from(reassign_groups.keys())) {\n                if (reassign_groups.get(c_index).has(cA) || reassign_groups.get(c_index).has(cB)) {\n                    groupID = c_index; \n                }\n            }\n            // if it's an existing group\n            if (reassign_groups.has(groupID)) {\n                reassign_groups.get(groupID).add(cA);\n                reassign_groups.get(groupID).add(cB);\n            } else {\n                // it's a new group\n                const reassign2 = new Set();\n                reassign2.add(cA);\n                reassign2.add(cB); \n                reassign_groups.set(groupID, reassign2);\n            }\n        }\n\n        // find the largest cluster in each reassign_group\n        let new_reassign_group = new Map(); \n        // const clusterTable = this.brushedClusterDim.group().all();\n        let clusterTableData = this.getClusterTableInfo();\n        for (var groupID of Array.from(reassign_groups.keys())) {\n            const reassign2 = reassign_groups.get(groupID); \n            let currmaxcluster = ''; \n            let currmaxper = Number.MIN_VALUE;\n            console.log(\"groupID\", groupID); \n            for (const row of clusterTableData) {\n                if (reassign2.has(String(row.key))) { \n                    let binper = row.value; \n                    if (binper > currmaxper) {\n                        currmaxper = binper; \n                        currmaxcluster = String(row.key);\n                    }\n                }\n            }\n            console.log(\"Max Cluster\", currmaxcluster, currmaxper);\n            new_reassign_group.set(currmaxcluster, reassign_groups.get(groupID)); \n            console.log(new_reassign_group.get(currmaxcluster)); \n        }\n\n        return new_reassign_group; \n    }\n\n    assignMerge(sample: string, new_reassign_group: any) {\n        // reassign\n        const groupedByCluster = _.groupBy(this.allRecords, \"CLUSTER\"); // rawdata\n        for (var clusterName of Array.from(new_reassign_group.keys())) {\n            for (var toCluster of Array.from(new_reassign_group.get(clusterName))) {\n                const groupedBySample = _.groupBy(groupedByCluster[String(toCluster)], \"SAMPLE\");\n                const binsForSample = groupedBySample[String(sample)];\n                this.setbrushedBins(binsForSample);\n                console.log(\"Reassigning\", clusterName, \"to\", toCluster);\n                this.updateCluster(Number(clusterName)); \n                console.log(\"Pushing mergeBins() operation to history stack.\");\n                this.historyStack.push(JSON.parse(JSON.stringify(binsForSample)));\n            }\n        }\n    }\n\n\n    absorbBins(from_set: String[], to_set: String[], xthresh: Map<String, number>, ythresh: Map<String, number>) {\n\n        // for loop through all records in from_set!!\n        let clusters_from = new Set(this._cluster_filters_from);\n        let clusters_to = new Set(this._cluster_filters_to);\n        console.log(\"inside absorbBins()...\");\n        console.log(\"_cluster_filters_from\", this._cluster_filters_from);\n        console.log(\"_cluster_filters_to\", this._cluster_filters_to); \n\n        let print_once = true; \n        const reassign = new Map(); \n        // for each from cluster \n        for (let c_from of Array.from(this._cluster_filters_from)) {\n            // pull up all bins from this cluster\n            const bins = this.allRecords; \n            const groupedByCluster = _.groupBy(bins, \"CLUSTER\");\n            for (const [clus, binsForCluster] of Object.entries(groupedByCluster)) {\n                const groupedBySample = _.groupBy(binsForCluster, \"SAMPLE\");\n                // console.log(\"clus\", clus, \"binsForCluster\", binsForCluster); \n                const groupedByBin = _.groupBy(binsForCluster, \"genomicPosition\"); \n                // for every bin identified by genomic position\n                if (clus === c_from) {\n                    // console.log(\"clus from:\", clus); \n                    for (const [genomicPos, binsAcrossSamples] of Object.entries(groupedByBin)) {\n                        // calculate minimum centroid\n                        let minDistFromCentroid : number = Number.MAX_VALUE; \n                        let minCluster : number = -2; \n                        let min_x : number = Number.MAX_VALUE; \n                        let min_y : number = Number.MAX_VALUE; \n\n                        // console.log(\"binsAcrossSamples\", binsAcrossSamples);\n                        const groupedBySample = _.groupBy(binsAcrossSamples, \"SAMPLE\"); \n                        // console.log(\"groupedBySample\", groupedBySample);\n                        for (const [sample, bin] of Object.entries(groupedBySample)) {\n                            // if (print_once) {\n                            // console.log(\"sample\", sample); \n                            // console.log(\"bin\", bin[0]); \n                            let x : number = bin[0][\"reverseBAF\"];\n                            let y : number = bin[0][\"fractional_cn\"]; \n                            const samplePts = this.centroidPts[sample];\n                            // console.log(\"samplePts\", samplePts); \n                            // console.log(\"centroids to\", clusters_to); \n                            for (var to_c of Array.from(clusters_to.values())) {\n                                let centroid = samplePts[String(to_c)][0];\n                                    // console.log(\"centroid\", centroid);\n                                    let c_x : number = centroid.point[0];\n                                    let c_y : number = centroid.point[1]; \n                                    // console.log(\"c_x\", c_x, \"c_y\", c_y);\n                                    // console.log(\"x\", x, \"y\", y); \n                                    print_once = false;  \n                                    const dist = Math.sqrt((c_x - x)**2 + (c_y - y)**2);\n                                    // console.log(\"dist\", dist);  \n                                    if (dist < minDistFromCentroid) {\n                                        minCluster = Number(to_c); \n                                        minDistFromCentroid = dist;\n                                        min_x = Math.abs(c_x-x);\n                                        min_y = Math.abs(c_y-y);  \n                                    } \n                            // }\n                            }\n                        }\n                        // with minimum centroid across all clusters and across all samples\n                        // check whether it falls below the threshold in each sample\n                        let underThresh : boolean = true; \n                        for (const [sample, bin] of Object.entries(groupedBySample)) {\n                            let x_thr : number = xthresh[sample]; \n                            let y_thr : number = ythresh[sample];\n                            if (min_x > x_thr || min_y > y_thr) {\n                                underThresh = underThresh && false; \n                            } \n                        }\n                        // let s, b = Object.entries(groupedBySample)[0];\n                        if (minCluster != -2 && underThresh) {\n                            // console.log(\"minCluster\", minCluster); \n                            for (const [sample, bin] of Object.entries(groupedBySample)) {\n                                if (reassign.has(String(minCluster))) {\n                                    var arr = reassign.get(String(minCluster)); \n                                    if (arr != undefined) {\n                                        // arr.push(b[\"genomicPosition\"]);\n                                        arr.push(bin[0]);\n                                        reassign.set(String(minCluster), arr);\n                                    } else {\n                                        console.log(\"Arr is undefined??\"); \n                                    }\n                                } else {\n                                    // reassign.set(String(minCluster), [b[\"genomicPosition\"]]); \n                                    let binarr : GenomicBin[] = [bin[0]]; \n                                    reassign.set(String(minCluster), binarr); \n                                }\n                            }   \n                        }\n                    }\n                }\n            }\n\n        }\n        // console.log(reassign); \n        return reassign; \n    }\n\n\n    // const groupedByCluster = _.groupBy(this.allRecords, \"CLUSTER\"); // rawdata\n    // for (var clusterName of Array.from(new_reassign_group.keys())) {\n    //     for (var toCluster of Array.from(new_reassign_group.get(clusterName))) {\n    //         const groupedBySample = _.groupBy(groupedByCluster[String(toCluster)], \"SAMPLE\");\n    //         const binsForSample = groupedBySample[String(sample)];\n    //         this.setbrushedBins(binsForSample);\n\n    assignAbsorb(reassign: any) {       \n        // console.log(\"reassign\", reassign);      \n        const bins = this.allRecords; \n        //const groupedByPos = _.groupBy(bins, \"genomicPosition\"); \n        // assign bin to closest centroid if closer than threshold\n        for (var clusterName of Array.from(reassign.keys())) {\n            let binarr = reassign.get(clusterName); \n            this.setbrushedBins(binarr);\n            this.updateCluster_nolog(Number(clusterName)); \n            // console.log(\"binarr\", binarr[0]); \n            // for (let i=0; i < binarr.length; i++) {\n            //     this.setbrushedBins(binarr[i]);\n            //     this.updateCluster_nolog(Number(clusterName)); \n            // }\n        } \n    }\n\n\n    /**\n     * Helper function for performing queries.\n     * \n     * @typeParam T type of value stored in the index\n     * @param index the index to query\n     * @param sample sample name for which to find matching records\n     * @param chr chromosome name for which to find matching records\n     * @return a list of matching records\n     */\n    private _getData<T>(index: IndexedBioData<T[]>, sample: string, chr: string, cluster: string): T[] {\n        const dataForSample = index[sample][cluster] || {};\n        return dataForSample[chr] || [];\n    }\n}\n","import React from \"react\";\nimport * as d3 from \"d3\";\n// @ts-ignore: Unreachable code error\nimport * as fc from \"d3fc\";\nimport _ from \"lodash\";\nimport memoizeOne from \"memoize-one\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {GenomicBin, GenomicBinHelpers} from \"../model/GenomicBin\";\nimport {webglColor, getRelativeCoordinates, niceBpCount } from \"../util\";\nimport \"./Scatterplot.css\";\nimport {DisplayMode} from \"../App\"\nimport { cn_pair, fractional_copy_number } from \"../constants\";\nimport { scaleBand } from \"d3\";\n\nconst PADDING = { // For the SVG\n    left: 70,\n    right: 20,\n    top: 35,\n    bottom: 60,\n};\n\nconst UNCLUSTERED_COLOR = \"#999999\";\nconst DELETED_COLOR = \"rgba(232, 232, 232, 1)\";\nconst UNCLUSTERED_ID = \"-1\";\nconst DELETED_ID = \"-2\";\nconst SCALES_CLASS_NAME = \"scatterplot-scale\";\nconst CIRCLE_GROUP_CLASS_NAME = \"circles\";\nconst CIRCLE_R = 1;\nconst TOOLTIP_OFFSET = 10; // Pixels\nlet nextCircleIdPrefix = 0;\n\ninterface Props {\n    pointsize: number; \n    parentCallBack: any;\n    data: GenomicBin[];\n    rdRange: [number, number];\n    yAxisToPlot: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\">;\n    hoveredLocation?: ChromosomeInterval;\n    width: number;\n    height: number;\n    invertAxis: boolean;\n    onRecordsHovered: (record: GenomicBin | null) => void;\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    customColor: string;\n    col: string;\n    colors: string[];\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    displayMode: DisplayMode;\n    onZoom: (newScales: any) => void;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    scales: any;\n    centroidPts: {cluster: number, point: [number, number]}[];\n    showCentroids: boolean;\n    purity: number;\n    ploidy: number;\n    offset: number; \n    meanRD: number;\n    fractionalCNTicks: fractional_copy_number[];\n    showPurityPloidy: boolean;\n    showTetraploid: boolean; \n    BAF_lines: cn_pair[];\n    max_cn: number;\n}\n\ninterface State {\n    selectedCluster: string;\n    quadTree: d3.Quadtree<GenomicBin>;\n}\n\nexport class Scatterplot extends React.Component<Props, State> {\n    static defaultProps = {\n        width: 400,\n        height: 302,\n        onNewCurveState: _.noop,\n        onRecordHovered: _.noop,\n    };\n\n    private _svg: SVGSVGElement | null;\n    private _circleIdPrefix: number;\n    private _clusters : string[];\n    private brushedNodes: Set<GenomicBin>;\n    private previous_brushed_nodes: Set<string>;\n    // private quadTree: d3.Quadtree<GenomicBin>;\n    private _canvas: HTMLCanvasElement | null;\n    // private _canvas2: HTMLCanvasElement | null;\n    private _currXScale: d3.ScaleLinear<number, number>;\n    private _currYScale: d3.ScaleLinear<number, number>;\n    private _original_XScale: d3.ScaleLinear<number, number>;\n    private _original_YScale: d3.ScaleLinear<number, number>;\n\n    private _original_transform: any;\n    private _current_transform: any;\n    private scatter: any;\n    private zoom: any;\n\n    constructor(props: Props) {\n        super(props);   \n        this._svg = null;\n        this._canvas = null;\n        this.scatter = null;\n        // this._canvas2 = null;\n        this._circleIdPrefix = nextCircleIdPrefix;\n        nextCircleIdPrefix++;\n        this.computeScales = memoizeOne(this.computeScales);\n        this.handleMouseMove = this.handleMouseMove.bind(this);\n        this.onBrushedBinsUpdated = this.onBrushedBinsUpdated.bind(this);\n        this._clusters = this.initializeListOfClusters();\n        \n        this.brushedNodes = new Set();\n        this.previous_brushed_nodes = new Set();\n        this.onZoom = this.onZoom.bind(this);\n        this.resetZoom = this.resetZoom.bind(this);\n        this.zoom = null;\n       \n        const {bafScale, rdrScale} = this.computeScales(this.props.rdRange, props.width, props.height);\n        this._currXScale = bafScale;\n        this._currYScale = rdrScale;\n        this._original_XScale = this._currXScale;\n        this._original_YScale = this._currYScale;\n\n        let data : GenomicBin[] = props.data;\n\n        this._original_transform = d3.zoomIdentity.translate(0, 0).scale(1);\n        this._current_transform = this._original_transform;\n        this.state = {\n            selectedCluster: (this._clusters.length > 0) ? this._clusters[0] : UNCLUSTERED_ID,\n            quadTree: d3.quadtree<GenomicBin>()\n            .x((d : GenomicBin) => d.reverseBAF)\n            .y((d : GenomicBin)  => d[props.yAxisToPlot])\n            .addAll(data)\n        }\n    }\n\n    initializeListOfClusters() : string[] {\n        let clusterTableData = this.props.clusterTableData;\n        clusterTableData.sort((a : any, b : any) => {\n            if (a.key > b.key) return 1;\n            if (a.key < b.key) return -1;\n            return 0;\n        })\n\n        this._clusters = [];\n        for(const obj of clusterTableData) {\n            this._clusters.push(obj.key);\n        }\n\n        while(this._clusters.length > 0 \n            && (this._clusters[0] === UNCLUSTERED_ID \n            || this._clusters[0] === DELETED_ID)) {\n            this._clusters.shift();\n        }\n\n        return this._clusters;\n    }\n\n    handleMouseMove(event: React.MouseEvent<SVGSVGElement>) {\n        // const {rdRange, width, height, curveState, onNewCurveState, invertAxis} = this.props;\n        const {x, y} = getRelativeCoordinates(event);\n        const hoveredRdBaf = {\n            rd: this._currYScale.invert(y),\n            baf: this._currXScale.invert(x)\n        };\n\n        if( hoveredRdBaf.baf > this._currXScale.domain()[0] && hoveredRdBaf.baf < this._currXScale.domain()[1] \n            && hoveredRdBaf.rd > this._currYScale.domain()[0] && hoveredRdBaf.rd < this._currYScale.domain()[1] ) {\n            \n            const radius = Math.abs(this._currXScale.invert(x) - this._currXScale.invert(x - 20));\n            this.props.onRecordsHovered(this.state.quadTree.find(hoveredRdBaf.baf, hoveredRdBaf.rd, radius) || null);\n        } else {\n            this.props.onRecordsHovered(null);\n        }\n    }\n\n    renderTooltipAtRdBaf(rd: number, baf: number, contents: JSX.Element | null) {\n        if (!contents) {\n            return null;\n        }\n\n        const top =  (this._currYScale(rd) || 0);\n        const left = ((this._currXScale(baf) || 0) + TOOLTIP_OFFSET);\n        const tooltipHeight = 150;\n        const tooltipWidth = 275;\n        \n        return <div\n            className=\"Scatterplot-tooltip\"\n            style={{\n                position: \"absolute\",\n                top: top - tooltipHeight, // Alternatively, this could be 0.5 - baf\n                left:  left,\n                width: tooltipWidth,\n                height: tooltipHeight,\n                pointerEvents: \"none\"\n            }}\n        >\n            {contents}\n        </div>;\n    }\n\n    renderTooltip() {\n        const {data, hoveredLocation, yAxisToPlot} = this.props;\n\n        if (!hoveredLocation) {\n            return null;\n        }\n        let hoveredRecords : GenomicBin[] = [];\n        hoveredRecords = data.filter(record => {\n            let currLoc = GenomicBinHelpers.toChromosomeInterval(record);\n            return (hoveredLocation.chr === currLoc.chr\n            && hoveredLocation.start === currLoc.start \n            && hoveredLocation.end === currLoc.end)}) //record.location.hasOverlap(hoveredLocation));\n\n        if(hoveredRecords.length === 0) {\n            hoveredRecords = data.filter(record => GenomicBinHelpers.toChromosomeInterval(record).hasOverlap(hoveredLocation))\n        }\n        if(hoveredRecords[0]) {\n            const x = this._currXScale(hoveredRecords[0].reverseBAF);\n            const y = this._currYScale(hoveredRecords[0][yAxisToPlot]);\n            \n            let range = this._currXScale.range();\n            let range2 = this._currYScale.range();\n            let yLabel = \"RDR: \";\n            if (yAxisToPlot === \"fractional_cn\") {\n                yLabel = \"Fractional CN: \";\n            } else if (yAxisToPlot === \"logRD\") {\n                yLabel = \"Log RDR: \";\n            }\n            \n            if (hoveredRecords.length === 1 && x && y && x > range[0] && x < range[1] && y < range2[0] && y > range2[1]) {\n                const record = hoveredRecords[0];\n                const recordLocation = GenomicBinHelpers.toChromosomeInterval(record);\n                return this.renderTooltipAtRdBaf(record[yAxisToPlot], record.reverseBAF, <React.Fragment>\n                    <p>\n                        <b>{recordLocation.toString()}</b><br/>\n                        ({niceBpCount(recordLocation.getLength())})\n                    </p>\n                    <div> {yLabel + record[yAxisToPlot].toFixed(2)}</div>\n                    <div> 0.5 - BAF: {record.reverseBAF.toFixed(2)}</div>\n                    <div> Cluster ID: {record.CLUSTER}</div>\n                    \n                </React.Fragment>);\n            } \n        }\n\n        return null;\n    }\n\n    render() {\n        \n        const {width, height} = this.props;\n\n        let clusterOptions = this._clusters.map(clusterName =>\n            <option key={clusterName} value={clusterName} >{clusterName}</option>\n        );\n        \n        clusterOptions.unshift(<option key={UNCLUSTERED_ID} value={UNCLUSTERED_ID} >{UNCLUSTERED_ID}</option>);\n        clusterOptions.unshift(<option key={DELETED_ID} value={DELETED_ID} >{DELETED_ID}</option>);\n        \n        let scatterUI = <div ref={node => this.scatter= node} className=\"Scatterplot\" style={{width: width, height: height}}>\n                            <canvas\n                                ref={node => this._canvas = node}\n                                width={width}\n                                height={height}\n                                className={\"canvas\"}\n                                style={{position: \"absolute\", \n                                        top: PADDING.top, \n                                        zIndex: -4, \n                                        left: PADDING.left, \n                                        width: width-PADDING.left - PADDING.right, \n                                        height: height-PADDING.top-PADDING.bottom}}\n                            />\n\n                            <svg\n                                ref={node => this._svg = node}\n                                style={{zIndex: 100}}\n                                preserveAspectRatio={'xMinYMin meet'}\n                                viewBox={'0 0 ' + (width) + ' ' + (height)}\n                                onMouseMove={this.handleMouseMove}\n                            ></svg>\n                            <div className=\"Scatterplot-tools\">\n                                <button className=\"custom-button\" onClick={this.resetZoom}>Reset View</button>\n                            </div>\n\n                            {this.renderTooltip()}\n                        </div>;\n        return scatterUI;\n    }\n\n    resetZoom() {\n        if(!this._svg) { return; }\n        this._currXScale = this._original_XScale;\n        this._currYScale = this._original_YScale;\n        const newScales = {xScale: null, yScale: null}\n        this.props.onZoom(newScales);\n        this.redraw();\n    }\n\n    componentDidMount() { \n        this.redraw();\n        this.forceHover(this.props.hoveredLocation);\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        const xScale = this.props.scales.xScale\n        const yScale =  this.props.scales.yScale\n        const prevXScale = prevProps.scales.xScale\n        const prevYScale = prevProps.scales.yScale\n\n        function scalesUpdated(scaleOne: any, scaleTwo:any) {\n            if(scaleOne && !scaleTwo) {\n                return true;\n            }\n            if(scaleOne && scaleTwo) {\n                if((scaleOne[0] !== scaleTwo[0] || scaleOne[1] !== scaleTwo[1])) {\n                    \n                    return true;\n                }\n            }\n            return false;\n        }\n\n        function scalesUpdated2(scaleOne: number[] | null, scaleTwo: number[] | null) {\n            if(scaleOne && !scaleTwo) {\n                return true;\n            }\n            if(scaleOne && scaleTwo) {\n                if((Math.abs(scaleOne[0]-scaleTwo[0]) > .0001) || (Math.abs(scaleOne[1]-scaleTwo[1]) > .0001)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        if(!xScale && !yScale && prevXScale && prevYScale) {\n            // Scales prop is not passed if we are at the original zoom, \n            // so when previously we had scales passed, but now we don't we must reset the zoom\n            this.resetZoom();\n        } else if(scalesUpdated(xScale, prevXScale) || scalesUpdated(yScale, prevYScale)) {\n                // If either scale was changed, then update scales \n                // and update the quadtree so that tooltip stays in accurate\n                // Then rerender points with the updated scales\n\n                if(xScale) {\n                    this._currXScale.domain(xScale);\n                }\n\n                if(yScale) {\n                    this._currYScale.domain(yScale);\n                }\n\n                let data : GenomicBin[] = this.props.data;\n\n                let q = d3\n                    .quadtree<GenomicBin>()\n                    .x((d : GenomicBin) => d.reverseBAF)\n                    .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                    .addAll(data);\n\n                this.setState({quadTree: q});\n                this.redraw();\n\n        } if (this.props.hoveredLocation !== prevProps.hoveredLocation) {\n            this.forceUnhover();\n            this.forceHover(this.props.hoveredLocation); \n        } else if (this.propsDidChange(prevProps, [\"purity\", \"ploidy\", \"offset\"])) {\n            let data : GenomicBin[] = this.props.data;\n            const rdrScale = this.computeScales(this.props.rdRange, this.props.width, this.props.height).rdrScale;\n            this._currYScale = rdrScale;\n            this._original_YScale = rdrScale;\n\n            // Update quadtree so that when hovering works on new points that appear \n            // (when assigning to an existing cluster - all the points in that cluster show up even if it has been filtered out)\n\n            let q = d3\n                .quadtree<GenomicBin>()\n                .x((d : GenomicBin) => d.reverseBAF)\n                .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                .addAll(data)\n            \n            this.setState({quadTree: q});\n            this.redraw();\n        } else if (this.propsDidChange(prevProps, [\"showCentroids\", \"displayMode\", \"colors\", \"brushedBins\", \"width\", \"height\", \"customColor\", \"pointsize\", \"showTetraploid\"])) { // gc added customColor, redraws scatterplot on change\n            // console.log(\"propsDidChange: calling this.redraw()\");\n            // console.log(\"recognizing showTetraploid change\", this.props.showTetraploid); \n\n            let data : GenomicBin[] = this.props.data;\n            // Update quadtree so that when hovering works on new points that appear \n            // (when assigning to an existing cluster - all the points in that cluster show up even if it has been filtered out)\n\n            let q = d3\n                .quadtree<GenomicBin>()\n                .x((d : GenomicBin) => d.reverseBAF)\n                .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                .addAll(data);\n            \n            this.setState({quadTree: q});\n            this.redraw();\n            this.forceHover(this.props.hoveredLocation);\n        } else if((!(_.isEqual(this.props[\"data\"], prevProps[\"data\"])) || this.props.yAxisToPlot !== prevProps.yAxisToPlot)) { \n            const {bafScale, rdrScale} = this.computeScales(this.props.rdRange, this.props.width, this.props.height);\n\n            if(!scalesUpdated2(this._currXScale.domain(), this._original_XScale.domain()) \n            && !scalesUpdated2(this._currYScale.domain(), this._original_YScale.domain())) { // zoom not applied\n                // When the sample filter changes, the y-axis max will also change so must recaculate the scales\n                // Original scales saves the scales to which we should reset the view\n                this._currXScale = bafScale;\n                this._currYScale = rdrScale;\n                this._original_XScale = this._currXScale;\n                this._original_YScale = this._currYScale;\n            } else { // If zoom is applied, then update original scales but don't change current zoom\n                if(this.props.yAxisToPlot !== prevProps.yAxisToPlot){ // When changing to log scale\n                    let currentYDomain = this._currYScale.domain();\n                    if (this.props.yAxisToPlot=== \"logRD\") {   // previous was RD\n                        if(currentYDomain[0] <= 0) { currentYDomain[0] = 0.1; }\n                        if(currentYDomain[1] <= 0) { currentYDomain[1] = 0.1; }\n                        const newYDomain = [Math.log2(currentYDomain[0]), Math.log2(currentYDomain[1])];\n                        this._currYScale.domain(newYDomain).range(this._currYScale.range());\n                    } else if(this.props.yAxisToPlot === \"fractional_cn\"){ // Switched to fractional_cn from RD\n                        const newYDomain = [currentYDomain[0] * this.props.ploidy / this.props.meanRD, currentYDomain[1] * this.props.ploidy / this.props.meanRD]\n                        this._currYScale.domain(newYDomain).range(this._currYScale.range());\n                    } else if(prevProps.yAxisToPlot=== \"logRD\"){ // Switched to RD from logRD\n                        const newYDomain = [Math.pow(2, currentYDomain[0]), Math.pow(2, currentYDomain[1])];\n                        this._currYScale.domain(newYDomain).range(this._currYScale.range());\n                    } else if(prevProps.yAxisToPlot === \"fractional_cn\") {\n                        const newYDomain = [currentYDomain[0] * this.props.meanRD / this.props.ploidy, currentYDomain[1] * this.props.meanRD / this.props.ploidy]\n                        this._currYScale.domain(newYDomain).range(this._currYScale.range());\n                    }\n                }\n\n                this._original_XScale = bafScale;\n                this._original_YScale = rdrScale;\n            }\n            \n            \n            // Rebuild quadtree since scale changed (when going to log scale, sample change, etc)\n            let data : GenomicBin[] = this.props.data;\n            let q = d3\n                .quadtree<GenomicBin>()\n                .x((d : GenomicBin) => d.reverseBAF)\n                .y((d : GenomicBin)  => d[this.props.yAxisToPlot])\n                .addAll(data);\n            \n            this.setState({quadTree: q});\n\n            let newScales = {xScale: this._currXScale.domain(), yScale: this._currYScale.domain()}\n            this.props.onZoom(newScales);\n            this.redraw();\n            this.forceHover(this.props.hoveredLocation);\n        } \n\n        if(this.props.clusterTableData !== prevProps.clusterTableData) {\n            this.initializeListOfClusters();\n        }\n    }\n\n    computeScales(rdRange: [number, number], width: number, height: number, \n                    bafRange?: [number, number], useLowerBound?: boolean) {\n        let bafScaleRange = [PADDING.left, width - PADDING.right];\n        let rdrScaleRange = [height - PADDING.bottom, PADDING.top];\n        let rdLowerBound = (useLowerBound) ? rdRange[0] :((this.props.applyLog) ? -2 : 0);\n\n        if(this.props.showPurityPloidy) {\n            rdLowerBound = rdRange[0];\n        }\n\n        let baf = bafRange ? bafRange : [-.01, 0.51] // .0001 allows for points exactly on the axis to still be seen\n        \n        return {\n            bafScale: d3.scaleLinear()\n                .domain(baf)\n                .range(bafScaleRange),\n            rdrScale: d3.scaleLinear()\n                .domain([rdLowerBound, rdRange[1]])\n                .range(rdrScaleRange)\n        };\n    }\n\n    onBrushedBinsUpdated = (brushedNodes: GenomicBin[]) => {\n        this.props.onBrushedBinsUpdated(brushedNodes);\n    }\n\n    onZoom(newScales: any) {\n        this.props.onZoom(newScales);\n    }\n\n    // filterFractionalCNTicks() {\n    //     let currDomain = this._currYScale.domain();\n    //     const {rdRange, max_cn} = this.props;\n    //     // console.log(\"CurrDomain: \", currDomain);\n    //     // console.log(\"Original Ticks: \", this.props.fractionalCNTicks);\n    //     // console.log(\"Max Cn: \", max_cn);\n    //     return this.props.fractionalCNTicks.filter(value => value > currDomain[0] && value <= max_cn && value < currDomain[1]);\n    // }\n\n\n    redraw() {\n        // console.log(\"Beginning redraw().\");\n        if (!this._svg || !this._canvas || !this.scatter) {\n            return;\n        }\n        \n        let self = this;\n        const {width, height, customColor, pointsize, brushedBins, data, colors, yAxisToPlot, centroidPts, showPurityPloidy, showTetraploid} = this.props;\n\n        let {displayMode} = this.props;\n        let xScale = this._currXScale;\n        let yScale = this._currYScale;\n        let xLabel = \"Allelic Imbalance (0.5 - BAF)\";\n        let yLabel = yAxisToPlot === \"RD\" ? \"RDR\" : ((yAxisToPlot === \"fractional_cn\") ? \"Copy Number\" : \"log RDR\");\n        \n        const svg = d3.select(this._svg);\n\n        // Remove any previous scales\n        svg.selectAll(\".\" + SCALES_CLASS_NAME).remove();\n\n        // X axis stuff\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"x\", _.mean(this._currXScale.range()))\n            .attr(\"y\", height - PADDING.bottom + 40)\n            .style(\"text-anchor\", \"middle\")\n            .text(xLabel);\n\n        // Y axis stuff\n        svg.append(\"text\")\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"y\", 20)\n            .attr(\"x\", 0-_.mean(this._currYScale.range()))\n            .attr(\"transform\", `rotate(-90)`)\n            .style(\"text-anchor\", \"middle\")\n            .text(yLabel);\n        \n        let xAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale))\n            .selectAll('text')\n            .style(\"text-anchor\", \"end\")\n            .attr(\"dx\", \"-.8em\")\n            .attr(\"dy\", \".15em\")\n            .attr('transform', 'rotate(-30)')\n\n        let new_BAF_lines : cn_pair[] = []; \n        if(showPurityPloidy) {\n            const currXDomain = this._currXScale.domain();\n            // console.log(\"[Scatterplot render() -> showTetraploid\", showTetraploid);\n            if (!showTetraploid) {\n                const new_BAF_ticks : cn_pair[] = [];\n                // filter BAF lines\n                // console.log(\"BAF_lines\", this.props.BAF_lines); \n                for(const cn_pair_i of this.props.BAF_lines) {\n                    // console.log(cn_pair_i); \n                    // if (cn_pair_i.state[1] != 2) {\n                    if ((cn_pair_i.state[0] + cn_pair_i.state[1]) < 4) {\n                        new_BAF_ticks.push(cn_pair_i); \n                    }\n                }\n                new_BAF_lines = new_BAF_ticks; \n            } else {\n                new_BAF_lines = this.props.BAF_lines; \n            }\n            \n            const filteredBAFTicks = new_BAF_lines.filter(value => value.tick > currXDomain[0] && value.tick < currXDomain[1]);\n            const ticks = filteredBAFTicks.map(d => d.tick);\n            const ticksWithoutOverlap : number[] = []\n            const filterBAFTicksNoOverlap : cn_pair[] = []\n\n            if(ticks.length > 0) {\n                ticksWithoutOverlap.push(ticks[0])\n                filterBAFTicksNoOverlap.push(filteredBAFTicks[0])\n            }\n\n            for(let i = 1; i < ticks.length; i++) {\n                // console.log(ticks[i])\n                let first = xScale(ticksWithoutOverlap[ticksWithoutOverlap.length-1]) || 0;\n                let second = xScale(ticks[i]) || 0;\n                let pixelDist = second - first;\n\n                if(pixelDist > 12) {\n                    ticksWithoutOverlap.push(ticks[i]);\n                    filterBAFTicksNoOverlap.push(filteredBAFTicks[i])\n                }\n            }\n            \n\n            // console.log(\"Test: \", dist_test)\n\n\n            // console.log(\"filteredBAFTicks[i]\", filteredBAFTicks); \n            // xAx = (g : any, scale : any) => g\n            // .classed(SCALES_CLASS_NAME, true)\n            // .attr(\"id\", \"Grid\")\n            // .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            // .call(d3.axisBottom(scale).tickValues(ticks).tickSizeInner(-height + PADDING.top + PADDING.bottom).tickFormat((d, i) =>ticks[i].toFixed(2) + \" (\"+filteredBAFTicks[i].state[0]+\",\"+filteredBAFTicks[i].state[1]+\")\"))\n            // .selectAll('text')\n            // .style(\"text-anchor\", \"end\")\n            // .attr(\"dx\", \"-.8em\")\n            // .attr(\"dy\", \".15em\")\n            // .attr('transform', 'rotate(-30)')\n            xAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"id\", \"Grid\")\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            // .call(d3.axisBottom(scale).tickValues(ticks).tickSizeInner(-height + PADDING.top + PADDING.bottom).tickFormat((d, i) => ((filteredBAFTicks[i].state[0] != filteredBAFTicks[i].state[1]) || (filteredBAFTicks[i].state[1] != 2)) ? ticks[i].toFixed(2) + \" (\"+filteredBAFTicks[i].state[0]+\",\"+filteredBAFTicks[i].state[1]+\")\" : ((filteredBAFTicks[i].state[1] != 2) ? ticks[i].toFixed(2) + \"(x,x)\" : \"\")))\n            .call(d3.axisBottom(scale).tickValues(ticksWithoutOverlap).tickSizeInner(-height + PADDING.top + PADDING.bottom).tickFormat((d, i) => (filterBAFTicksNoOverlap[i].state[0] != filterBAFTicksNoOverlap[i].state[1]) ? ticksWithoutOverlap[i].toFixed(2) + \" (\"+filterBAFTicksNoOverlap[i].state[0]+\",\"+filterBAFTicksNoOverlap[i].state[1]+\")\" : ticksWithoutOverlap[i].toFixed(2) + \" (x,x)\"))\n            .selectAll('text')\n            .style(\"text-anchor\", \"end\")\n            .attr(\"dx\", \"-.8em\")\n            .attr(\"dy\", \".15em\")\n            .attr('transform', 'rotate(-30)')\n\n        }\n        \n        let yAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"id\", \"Grid\")\n            .attr(\"transform\", `translate(${PADDING.left}, 0)`)\n            .call(d3.axisLeft(scale));\n\n        if(showPurityPloidy) {\n            const originalTicks = this.props.fractionalCNTicks;\n            const dom = this._currYScale.domain();\n            const {max_cn} = this.props;\n            const upperBound = (max_cn > dom[1]) ? max_cn : dom[1]; \n            const filteredTicks = originalTicks.filter(value => value.fractionalTick > dom[0] && value.fractionalTick < upperBound && value.fractionalTick < dom[1]);\n            const filteredTicksVals = filteredTicks.map(d => d.fractionalTick);\n            \n            const ticksWithoutOverlap : number[] = []\n            const filterYAxisTicksNoOverlap : fractional_copy_number[] = []\n\n            // yAx = (g : any, scale : any) => g\n            //     .classed(SCALES_CLASS_NAME, true)\n            //     .attr(\"id\", \"Grid\")\n            //     .attr(\"transform\", `translate(${PADDING.left}, 0)`)\n            //     .call(d3.axisLeft(scale).tickValues(filteredTicksVals).tickSizeInner(-width + 80).tickFormat((d, i) => filteredTicks[i].totalCN + \"(x,x)\"));\n            if(filteredTicks.length > 0) {\n                ticksWithoutOverlap.push(filteredTicksVals[0])\n                filterYAxisTicksNoOverlap.push(filteredTicks[0])\n            }\n\n            for(let i = 1; i < filteredTicksVals.length; i++) {\n                console.log(filteredTicksVals[i])\n                let first = yScale(ticksWithoutOverlap[ticksWithoutOverlap.length-1]) || 0;\n                let second = yScale(filteredTicksVals[i]) || 0;\n                let pixelDist = first - second;\n                if(pixelDist > 10) {\n                    ticksWithoutOverlap.push(filteredTicksVals[i]);\n                    filterYAxisTicksNoOverlap.push(filteredTicks[i])\n                }\n            }\n\n            yAx = (g : any, scale : any) => g\n                .classed(SCALES_CLASS_NAME, true)\n                .attr(\"id\", \"Grid\")\n                .attr(\"transform\", `translate(${PADDING.left}, 0)`)\n                .call(d3.axisLeft(scale).tickValues(ticksWithoutOverlap).tickSizeInner(-width + 80).tickFormat((d, i) => filterYAxisTicksNoOverlap[i].totalCN + \" (\"+Number(d.valueOf()).toFixed(2)+\")\"));\n        }\n        \n        \n\n        let previous : string[] = [];\n        \n        brushedBins.forEach(d => previous.push(GenomicBinHelpers.toChromosomeInterval(d).toString()))\n        this.previous_brushed_nodes = new Set(previous);\n        \n        const previous_brushed_nodes = this.previous_brushed_nodes;\n\n        const gx = svg.append(\"g\");\n        const gy = svg.append(\"g\");\n        let z = d3.zoomIdentity;\n        const zoomX : any = d3.zoom().scaleExtent([0, 100]);\n        const zoomY : any = d3.zoom().scaleExtent([0, 100]);\n        const tx = () => d3.zoomTransform(gx.node() as Element);\n        const ty = () => d3.zoomTransform(gy.node() as Element);\n        gx.call(zoomX).attr(\"pointer-events\", \"none\");\n        gy.call(zoomY).attr(\"pointer-events\", \"none\");\n        \n        const zoom : any = d3.zoom().on(\"zoom\", () => {\n            try {\n                const t = d3.event.transform;\n                const k = t.k / z.k;\n                const point = center(d3.event);\n\n                // is it on an axis?\n                const doX = point[0] > xScale.range()[0];\n                const doY = point[1] < yScale.range()[0];\n                if(displayMode === DisplayMode.zoom || !(doX && doY) || displayMode === DisplayMode.boxzoom) {\n                    if (k === 1) {\n                        // pure translation?\n                        doX && zoomX && k && point && gx && gx.call(zoomX.translateBy, (t.x - z.x) / tx().k, 0);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.translateBy, 0, (t.y - z.y) / ty().k);\n                    } else {\n                        // if not, we're zooming on a fixed point\n                        doX && zoomX && k && point && gx && gx.call(zoomX.scaleBy, k, point);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.scaleBy, k, point);\n                    }\n                }\n            \n                z = t;\n                redraw();\n            } catch(error) {\n                console.log(\"Error: \", error);\n            }\n          }).on(\"end\", () => {\n                const xDomain = self._currXScale.domain();\n                const yDomain = self._currYScale.domain();\n                const xDomain2 = self._original_XScale.domain();\n                const yDomain2 = self._original_YScale.domain();\n                if(xDomain[0] !== xDomain2[0] || xDomain[1] !== xDomain2[1] || yDomain[0] !== yDomain2[0] || yDomain[1] !== yDomain2[1]) {\n                    let newScales = {xScale: self._currXScale.domain(), yScale: self._currYScale.domain()}\n                    self.props.onZoom(newScales);\n                }\n            }\n        );\n        \n        function center(event : any) {\n            if (event.sourceEvent) {\n                return [event.sourceEvent.layerX, event.sourceEvent.layerY];\n            }\n            return [width / 2, height / 2];\n        }\n\n        const gl = this._canvas.getContext(\"webgl\")!;\n        gl.clearColor(0,0,0,1);\n\n        let languageFill = (d:any) => {\n            return webglColor(chooseColor(d));\n        };\n        \n        let newData :GenomicBin[]= [];\n        for(const d of data) {\n            if(!previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                newData.push(d);\n            }\n        }\n\n        for(const d of data) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                newData.push(d);\n            }\n        }\n        \n        let fillColor = fc.webglFillColor().value(languageFill).data(newData);\n        // console.log(\"Scatterplot.tsx\", this.props.pointsize);\n        let pointSeries = fc // plotting points in webgl - d3fc library within js/ts for using webgl\n            .seriesWebglPoint()\n            .xScale(self._currXScale)\n            .yScale(self._currYScale)\n            // .size(3)\n            .crossValue((d : any) => d.reverseBAF) // x 0.5 - BAF\n            .mainValue((d : any) => d[yAxisToPlot]) // y CN\n            .context(gl)\n            .size(this.props.pointsize);\n            // .sizes((new Float32Array(data.length)).fill(this.props.pointsize)); \n            // .attr(\"r\", this.props.pointsize); // gc\n        \n        pointSeries.decorate((program:any) => {\n                fillColor(program)\n                gl.depthFunc(gl.NEVER);\n                gl.disable(gl.DEPTH_TEST);\n                \n        });\n\n\n        svg\n        .append(\"clipPath\")\n        .attr(\"id\", \"clip\")\n        .append(\"rect\")\n            .attr(\"x\", PADDING.left)\n            .attr(\"y\", PADDING.top)\n            .attr(\"width\", width - PADDING.right - PADDING.left)\n            .attr(\"height\", height - PADDING.bottom - PADDING.top);\n\n        // Create event-rect that allows for svg points to be overlayed under mouse pointer\n        svg\n            .append(\"g\")\n            .classed(\"eventrect\", true)\n            .append(\"rect\")\n                .attr(\"x\", PADDING.left)\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width - PADDING.right - PADDING.left)\n                .attr(\"height\", height - PADDING.bottom - PADDING.top)\n                .style(\"fill\", \"none\")\n                .style(\"pointer-events\", \"all\")\n                .attr(\"clip-path\", \"url(#clip)\");\n         \n       \n\n        function redraw() {\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.clearColor(255,255,255,1);\n            const xr = tx().rescaleX(xScale);\n            const yr = ty().rescaleY(yScale);\n        \n            gx.call(xAx , xr);\n            gy.call(yAx, yr);\n            \n            self._currXScale = xr;\n            self._currYScale = yr;\n\n            if(self._canvas) {\n                pointSeries\n                    .xScale(self._currXScale)\n                    .yScale(self._currYScale)\n                pointSeries(newData);\n            }\n            \n            svg.select(\".Centroids\").remove();\n            if(self.props.showCentroids) {\n                svg.select(\".eventrect\")\n                    .append(\"g\")\n                    .attr(\"clip-path\", \"url(#clip)\")\n                    .classed(\"Centroids\", true)\n                    .selectAll(\"path\")\n                    .data(centroidPts)\n                    .enter()\n                    .append(\"path\")\n                    .attr(\"class\", \"point\")\n                    .attr(\"d\", d3.symbol().type(d3.symbolCross))\n                    .attr(\"fill\", d => chooseColor2(d.cluster))\n                    .attr(\"fill-opacity\", 1)\n                    .attr(\"stroke-width\", 2)\n                    .attr(\"stroke\", \"black\") \n                    .attr(\"transform\", function(d) {\n                        return \"translate(\" + self._currXScale(d.point[0]) + \",\" + self._currYScale(d.point[1]) + \")\"; \n                    });\n            }\n        }\n        \n        this._canvas.width = width;\n        this._canvas.height = height;\n\n        redraw();\n\n        if(displayMode === DisplayMode.select || displayMode === DisplayMode.erase) {\n            const brush = d3.brush()\n            .keyModifiers(false)\n            .extent([[PADDING.left - 2*CIRCLE_R, PADDING.top - 2*CIRCLE_R], \n                    [this.props.width - PADDING.right + 2*CIRCLE_R , this.props.height - PADDING.bottom + 2*CIRCLE_R]])\n                    .on(\"end\", () => {\n                        this.updatePoints(d3.event)\n                        svg.selectAll(\".brush\").remove();\n                        this.onBrushedBinsUpdated([...this.brushedNodes]);\n                    });\n            \n              \n            // attach the brush to the chart\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n\n        } else if(displayMode === DisplayMode.zoom) {\n            svg.selectAll(\".brush\").remove();\n        } else if(displayMode === DisplayMode.boxzoom) {\n            const brush = d3.brush()\n            .keyModifiers(false)\n            .extent([[PADDING.left - 2*CIRCLE_R, PADDING.top - 2*CIRCLE_R], \n                    [this.props.width - PADDING.right + 2*CIRCLE_R , this.props.height - PADDING.bottom + 2*CIRCLE_R]])\n                    .on(\"start brush\", () => this.updatePoints(d3.event))\n                    .on(\"end\", () => {\n                        svg.selectAll(\".brush\").remove();\n                        brush_endEvent();\n                });\n               \n            // attach the brush to the chart\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n        }\n\n        svg.call(zoom).call(zoom.transform, d3.zoomIdentity.scale(1.0));\n\n        function brush_endEvent() {\n            if(!self._svg) {return;}\n            const {data} = self.props;\n            if (data) {\n                const { selection } = d3.event;\n                if(selection) { \n                    let newRdRange : [number, number] = [Number(self._currYScale.invert(selection[1][1])), \n                                                        Number(self._currYScale.invert(selection[0][1]))];\n                    let newBafRange : [number, number] = [Number(self._currXScale.invert(selection[0][0])), \n                                                            Number(self._currXScale.invert(selection[1][0]))];\n                    const {bafScale, rdrScale} = self.computeScales(newRdRange, width, height, newBafRange, true);\n                    self._currXScale = bafScale;\n                    self._currYScale = rdrScale;\n                    \n                    self.redraw();\n\n                    let newScales = {xScale: self._currXScale.domain(), yScale: self._currYScale.domain()}\n                    self.props.onZoom(newScales);\n                }\n            }\n        }\n        \n        function chooseColor(d: GenomicBin) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                return customColor;\n            } else if (d.CLUSTER === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(d.CLUSTER === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = d.CLUSTER;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n\n        function chooseColor2(c: number) {\n            if (c === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(c === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = c;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n        // console.log(\"Done redrawing.\");\n    }\n\n     updatePoints(event : any) {\n        if(!this._svg) {return;}\n        const {brushedBins, data, yAxisToPlot, displayMode} = this.props;\n        if (data) {\n            const { selection } = d3.event\n            if(selection) {   \n\n                function rectContains(rect : any, point : any) {\n                    const X = 0;\n                    const Y = 1;\n                    const TOP_LEFT = 0;\n                    const BOTTOM_RIGHT = 1;\n                    return rect[TOP_LEFT][X] <= point[X] && point[X] <= rect[BOTTOM_RIGHT][X] &&\n                           rect[TOP_LEFT][Y] <= point[Y] && point[Y] <= rect[BOTTOM_RIGHT][Y];\n                }\n\n                function currContains(currNode: any, toEraseSet: any) {\n                    let existingNode = (currNode[\"#CHR\"], currNode[\"START\"], currNode[\"END\"], currNode[\"genomicPosition\"]);\n                    if (toEraseSet.has(existingNode)) { // if existing node is one to delete\n                        return false; // filter out the existing node\n                    } else { // if existing node is not one to delete\n                        return true; // keep this existing node \n                    }\n                }\n\n                let brushNodes = data.filter(d => rectContains(selection, [this._currXScale(d.reverseBAF), this._currYScale(d[yAxisToPlot])]));\n                \n                if (brushNodes) {\n                    console.log(brushNodes); \n                    if(displayMode === DisplayMode.select) {\n                        brushNodes = _.uniqBy(_.union(brushNodes, brushedBins), element => element[\"#CHR\"] + \"_\" + element.START);\n                    } else if(displayMode === DisplayMode.erase) {\n                        let toEraseSet = new Set(); \n                        for(let i = 0; i < brushNodes.length; i++) {\n                            toEraseSet.add((brushNodes[i][\"#CHR\"], brushNodes[i][\"START\"], brushNodes[i][\"END\"], brushNodes[i][\"genomicPosition\"]));\n                        }\n                        brushNodes = brushedBins.filter(d => currContains(d, toEraseSet)); \n                    }\n\n                    this.brushedNodes = new Set(brushNodes);                  \n                } \n            } else {\n                this.brushedNodes = new Set([]);\n            }\n        }\n    }\n\n    getElementsForGenomeLocation(hoveredLocation?: ChromosomeInterval) {\n        if (!this._svg || !hoveredLocation || !this._canvas) {\n            return [];\n        }\n        \n        const {data, yAxisToPlot} = this.props;\n\n        let hoveredRecords : GenomicBin[] = [];\n        hoveredRecords = data.filter(record => {\n            let currLoc = GenomicBinHelpers.toChromosomeInterval(record);\n            return (hoveredLocation.chr === currLoc.chr\n            && hoveredLocation.start === currLoc.start \n            && hoveredLocation.end === currLoc.end)\n        })\n        \n        let range = this._currXScale.range();\n        let range2 = this._currYScale.range();\n        if(hoveredRecords.length === 0) {\n            \n            hoveredRecords = data.filter(record => GenomicBinHelpers.toChromosomeInterval(record).hasOverlap(hoveredLocation))\n            hoveredRecords = hoveredRecords.filter(record => {\n                const x = this._currXScale(record.reverseBAF);\n                const y = this._currYScale(record[yAxisToPlot]);\n                return x && y && x > range[0] && x < range[1] && y < range2[0] && y > range2[1]\n            })\n        }\n    \n        let svg = d3.select(this._svg);\n        svg.select(\".\" + CIRCLE_GROUP_CLASS_NAME).remove();\n        svg.select(\".eventrect\")\n            .append(\"g\")\n            .classed(CIRCLE_GROUP_CLASS_NAME, true)\n            .selectAll(\"circle\")\n                .data(hoveredRecords)\n                .enter()\n                .append(\"circle\")\n                    .attr(\"id\", d => this._circleIdPrefix + GenomicBinHelpers.toChromosomeInterval(d).toString())\n                    .attr(\"cx\", d => this._currXScale(d.reverseBAF) || 0)\n                    .attr(\"cy\", d => this._currYScale(d[yAxisToPlot]) || 0) // Alternatively, this could be 0.5 - baf\n                    .attr(\"r\", 3)\n                    .attr(\"fill\", d => {\n                        if(this.previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                            return this.props.customColor;\n                        } else if (d.CLUSTER === -1){\n                            return UNCLUSTERED_COLOR;\n                        } else if(d.CLUSTER === -2){\n                            return DELETED_COLOR;\n                        } else {\n                            const cluster = d.CLUSTER;\n                            const col_index = cluster % this.props.colors.length;\n                            return this.props.colors[col_index];\n                        }\n                        \n                    })\n                    .attr(\"fill-opacity\", 1)\n                    .attr(\"stroke-width\", 2)\n                    .attr(\"stroke\", \"black\");\n\n    }\n\n    forceHover(genomeLocation?: ChromosomeInterval) {\n        this.getElementsForGenomeLocation(genomeLocation);\n    }\n\n    forceUnhover() {\n        if(this._svg) {\n            d3.select(this._svg).select(\".\" + CIRCLE_GROUP_CLASS_NAME).remove();\n        }\n    }\n}","import React from 'react';\nimport { Coordinate, getRelativeCoordinates } from '../util';\n\nimport './DivWithBullseye.css';\n\ninterface State {\n    mouseCoordinates: Coordinate | null;\n}\n\n/**\n * Like a <div> in every way, except it has \"bullseye\", dotted lines that track where the mouse is.\n * \n * @author Silas Hsu\n */\nexport class DivWithBullseye extends React.Component<React.HTMLAttributes<HTMLDivElement>, State> {\n    constructor(props: React.HTMLAttributes<HTMLDivElement>) {\n        super(props);\n        this.state = {\n            mouseCoordinates: null\n        };\n\n        this.storeMouseCoordinates = this.storeMouseCoordinates.bind(this);\n        this.clearMouseCoordinates = this.clearMouseCoordinates.bind(this);\n    }\n\n    /**\n     * Stores a mouse event's coordinates in state.\n     * \n     * @param {MouseEvent} event - mousemove event whose coordinates to store\n     */\n    storeMouseCoordinates(event: React.MouseEvent<HTMLDivElement>) {\n        this.setState({mouseCoordinates: getRelativeCoordinates(event)});\n        if (this.props.onMouseMove) {\n            this.props.onMouseMove(event);\n        }\n    }\n\n    /**\n     * Clears stored mouse event coordinates.\n     * \n     * @param {MouseEvent} event - mouseleave event that triggered this callback\n     */\n    clearMouseCoordinates(event: React.MouseEvent<HTMLDivElement>) {\n        this.setState({mouseCoordinates: null});\n        if (this.props.onMouseLeave) {\n            this.props.onMouseLeave(event);\n        }\n    }\n\n    /**\n     * @inheritdoc\n     */\n    render() {\n        const {onMouseMove, onMouseLeave, style, children, ...otherProps} = this.props;\n        // Default `position: relative` so the bullseye looks right\n        const mergedStyle = Object.assign({position: 'relative'}, style);\n        return (\n        <div\n            onMouseMove={this.storeMouseCoordinates}\n            onMouseLeave={this.clearMouseCoordinates}\n            style={mergedStyle}\n            {...otherProps}\n        >\n            {children}\n            {this.state.mouseCoordinates && <Bullseye where={this.state.mouseCoordinates} />}\n        </div>\n        );\n    }\n}\n\n/**\n * The actual intersecting lines that form the bullseye.  Uses prop `where`, an object with props `x` and `y`.\n * \n * @param {Object} props - props as specified by React\n * @return {JSX.Element} - element to render\n */\nfunction Bullseye(props: {where: Coordinate}) {\n    const {x, y} = props.where;\n    const horizontalLineStyle = {\n        top: y - 1,\n        willChange: \"top\",\n    };\n    const verticalLineStyle = {\n        left: x - 1,\n        willChange: \"left\",\n    };\n    return (\n        <React.Fragment>\n            <div className=\"Bullseye-horizontal-line\" style={horizontalLineStyle} />\n            <div className=\"Bullseye-vertical-line\" style={verticalLineStyle} />\n        </React.Fragment>\n    );\n}\n","import React from \"react\";\nimport _ from \"lodash\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { Scatterplot } from \"./Scatterplot\";\nimport { DivWithBullseye } from \"./DivWithBullseye\";\nimport \"./SampleViz.css\";\nimport {DisplayMode} from \"../App\"\nimport { GenomicBin, GenomicBinHelpers } from \"../model/GenomicBin\";\nimport { cn_pair, fractional_copy_number } from \"../constants\";\nimport classnames from 'classnames'; \n\ninterface Props {\n    pointsize: number; \n    parentCallBack: any;\n    data: GenomicBin[];\n    chr: string;\n    cluster: string;\n    initialSelectedSample: string;\n    initialSelectedCluster?: string;\n    width?: number;\n    height?: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null, record?: GenomicBin | null) => void;\n    selectedSample: string;\n    onSelectedSample: any;\n    invertAxis?: boolean;\n    customColor: string;\n    colors: string[];\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    dispMode: DisplayMode;\n    onZoom: (newScales: any) => void;\n    onRemovePlot: any;\n    rdRange: [number, number];\n    plotId: number;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    implicitRange: [number, number] | null;\n    scales: any;\n    centroidPts: {cluster: number, point: [number, number]}[]\n    showCentroids: boolean;\n    purity: number;\n    ploidy: number;\n    offset: number; // gc: required because Scatterplot needs to watch for prop changes.\n    meanRD: number;\n    fractionalCNTicks: fractional_copy_number[];\n    showPurityPloidy: boolean;\n    showTetraploid: boolean; \n    BAF_lines: cn_pair[];\n    max_cn: number;\n}\n\ninterface State {\n    selectedSample: string;\n}\n\nexport class SampleViz2D extends React.Component<Props, State> {\n    \n    static defaultProps = {\n        onLocationHovered: _.noop,\n        invertAxis: false,\n        customColor: \"#1b9e77\"\n    };\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            selectedSample: props.initialSelectedSample\n        };\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleRecordsHovered = this.handleRecordsHovered.bind(this);\n        this.handleCallBack = this.handleCallBack.bind(this);\n        this.handleUpdatedBrushedBins = this.handleUpdatedBrushedBins.bind(this);\n        this.onRemovePlot = this.onRemovePlot.bind(this);\n    }\n\n    handleSelectedSampleChanged(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedSample: event.target.value});\n        this.props.onSelectedSample(event.target.value);\n    }\n\n    handleRecordsHovered(record: GenomicBin | null) {\n        const location = record ? GenomicBinHelpers.toChromosomeInterval(record) : null;\n        this.props.onLocationHovered(location);\n    }\n\n    handleCallBack = (childData : GenomicBin[]) => {\n        this.props.parentCallBack(childData);\n    }\n\n    handleUpdatedBrushedBins(brushedBins: GenomicBin[]) {\n        this.props.onBrushedBinsUpdated(brushedBins);\n    }\n\n    onRemovePlot() {\n        this.props.onRemovePlot(this.props.plotId);\n    }\n    \n    render() {\n        const {data, width, height, pointsize, hoveredLocation, invertAxis, customColor,\n                brushedBins, updatedBins, dispMode, onZoom, rdRange, clusterTableData, \n                applyLog, scales, centroidPts, showCentroids, purity, ploidy, offset, meanRD, fractionalCNTicks, showPurityPloidy, showTetraploid, BAF_lines, max_cn} = this.props;\n        const myDisplayClasses = classnames ({\n            'is-pan' : dispMode === DisplayMode.zoom,\n            'is-zoom' : dispMode === DisplayMode.boxzoom, \n            'is-select' : dispMode === DisplayMode.select, \n            'is-erase' : dispMode === DisplayMode.erase\n        })\n\n        return <div className=\"SampleViz-scatter\"> \n            <DivWithBullseye className={myDisplayClasses}> \n                <Scatterplot\n                    pointsize={pointsize}\n                    parentCallBack = {this.handleCallBack}\n                    data={data}\n                    rdRange={rdRange}\n                    width={width}\n                    height={height}\n                    hoveredLocation={hoveredLocation}\n                    onRecordsHovered={this.handleRecordsHovered}\n                    invertAxis= {invertAxis || false} \n                    customColor= {customColor}\n                    colors = {this.props.colors}\n                    col = {this.props.colors[0]}\n                    onBrushedBinsUpdated= {this.handleUpdatedBrushedBins}\n                    brushedBins= {brushedBins}\n                    updatedBins= {updatedBins}\n                    displayMode = {dispMode}\n                    onZoom = {onZoom}\n                    clusterTableData = {clusterTableData}\n                    applyLog = {applyLog}\n                    yAxisToPlot = {(applyLog) ? \"logRD\" : ((showPurityPloidy) ? \"fractional_cn\" : \"RD\")}\n                    onClusterSelected ={this.props.onClusterSelected}\n                    scales={scales}\n                    centroidPts={centroidPts}\n                    showCentroids={showCentroids}\n                    purity={purity}\n                    ploidy={ploidy}\n                    offset={offset}\n                    meanRD={meanRD}\n                    fractionalCNTicks={fractionalCNTicks}\n                    showPurityPloidy={showPurityPloidy}\n                    showTetraploid={showTetraploid}\n                    BAF_lines={BAF_lines}\n                    max_cn={max_cn}\n                    />\n            </DivWithBullseye>\n        </div>;\n    }\n}\n","import React from \"react\";\nimport * as d3 from \"d3\";\n// @ts-ignore: Unreachable code error\nimport * as fc from \"d3fc\";\nimport _ from \"lodash\";\nimport memoizeOne from \"memoize-one\";\nimport { GenomicBin, GenomicBinHelpers } from \"../model/GenomicBin\";\nimport { Genome, Chromosome } from \"../model/Genome\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {webglColor, getRelativeCoordinates, niceBpCount } from \"../util\";\nimport { DisplayMode } from \"../App\";\nimport \"./LinearPlot.css\";\nimport { Gene } from \"../model/Gene\";\nimport { cn_pair, fractional_copy_number } from \"../constants\";\n\nconst SCALES_CLASS_NAME = \"linearplot-scale\";\nconst UNCLUSTERED_COLOR = \"#999999\";\nconst DELETED_COLOR = \"rgba(232, 232, 232, 1)\";\nconst DRIVER_LABEL_WIDTH = 40;\n\nconst PADDING = { // For the SVG\n    left: 50,\n    right: 10,\n    top: 10,\n    bottom: 35,\n};\n\nfunction getLeftPadding(purityPloidyMode: boolean) {\n    if(!purityPloidyMode) {\n        return PADDING.left;\n    } else {\n        \n        return PADDING.left + 20;\n    }\n}\n\nfunction findChrNumber(chr: string) {\n    \n    const match = String(chr).match(/\\d+/);\n    if (!match) {\n        return chr;\n    } else {\n        return match[0];\n    }\n}\n\ninterface Props {\n    pointsize: number; \n    data: GenomicBin[];\n    chr: string;\n    dataKeyToPlot: keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"reverseBAF\" | \"BAF\" | \"fractional_cn\">;\n    applyLog: boolean;\n    width: number;\n    height: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null) => void;\n    brushedBins: GenomicBin[];\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    genome: Genome;\n    yLabel?: string;\n    yMin: number;\n    yMax: number;\n    implicitStart : number | null;\n    implicitEnd : number | null;\n    customColor: string;\n    colors: string[];\n    clusterTableData: any;\n    displayMode: DisplayMode;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    onZoom: (newScales: any) => void;\n    driverGenes: Gene[] | null;\n    handleDriverGenesChange: (sentGene: {gene: Gene | null, destination: string | null}) => void;\n    driverGeneUpdate: {gene: Gene | null, destination: string | null};\n    purity: number;\n    ploidy: number;\n    meanRD: number;\n    fractionalCNTicks: fractional_copy_number[];\n    showPurityPloidy: boolean;\n    showTetraploid: boolean; \n    BAF_lines: cn_pair[];\n}\n\nexport class LinearPlot extends React.PureComponent<Props> {\n    static defaultProps = {\n        width: 600,\n        height: 150,\n        onLocationHovered: _.noop\n    };\n\n    private _svg: SVGSVGElement | null;\n    private _canvas: HTMLCanvasElement | null;\n    private _clusters: string[];\n    private brushedNodes: Set<GenomicBin>;\n    private _currXScale: d3.ScaleLinear<number, number>;\n    private _currYScale: d3.ScaleLinear<number, number>;\n    private _original_XScale: d3.ScaleLinear<number, number>;\n    private _original_YScale: d3.ScaleLinear<number, number>;\n    private previewDriver: Gene | null;\n    private lockedDrivers: Set<Gene>;\n\n    constructor(props: Props) {\n        super(props);\n        this._svg = null;\n        this._canvas = null;\n        this.getXScale = memoizeOne(this.getXScale);\n        this.handleMouseMove = this.handleMouseMove.bind(this);\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\n        this._clusters = this.initializeListOfClusters();\n        this.brushedNodes = new Set();\n        this._currXScale = this.getXScale(props.width, props.genome, props.chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy);\n        this._currYScale = d3.scaleLinear()\n            .domain([this.props.yMin, this.props.yMax])\n            .range([this.props.height - PADDING.bottom, PADDING.top]);\n\n        this._original_XScale = this._currXScale;\n        this._original_YScale = this._currYScale;\n        this.previewDriver = null;\n        this.lockedDrivers = new Set();\n    } \n\n    initializeListOfClusters() : string[] {\n        let collator = new Intl.Collator(undefined, {numeric: true, sensitivity: 'base'});\n        let clusters = [...new Set(this.props.data.map(d => String(d.CLUSTER)))].sort(collator.compare);\n        if(clusters[0] === \"-2\") {\n            clusters.shift();\n        }\n        if(clusters[0] === \"-1\") {\n            clusters.shift();\n        }\n        return clusters;  \n    }\n\n    componentDidMount() {\n        this.redraw();\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.driverGeneUpdate.gene !== null) {\n            if(this.props.driverGeneUpdate.destination === this.props.dataKeyToPlot) {\n                if(this.lockedDrivers.has(this.props.driverGeneUpdate.gene)) {\n                    this.lockedDrivers.delete(this.props.driverGeneUpdate.gene);\n                } else {\n                    this.lockedDrivers.add(this.props.driverGeneUpdate.gene);\n                }\n                this.props.handleDriverGenesChange({gene: null, destination: null});\n            }\n        }\n\n        if(this.propsDidChange(prevProps, [\"chr\"])) {\n            if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\" || this.props[\"dataKeyToPlot\"] === \"fractional_cn\") {\n                this.props.onLinearPlotZoom(null, null, true);\n            } else {\n                this.props.onLinearPlotZoom(null, null, false);\n            }\n        } else if (this.propsDidChange(prevProps, [\"driverGenes\", \"displayMode\", \"implicitEnd\", \"implicitStart\", \"yMin\", \"yMax\", \"colors\", \"brushedBins\", \"width\", \"height\", \"chr\", \"purity\", \"ploidy\", \"pointsize\", \"showTetraploid\"])) {\n            if(this.props[\"brushedBins\"].length === 0)\n                this._clusters = this.initializeListOfClusters();\n            this.redraw();\n        } else if(!(_.isEqual(this.props[\"data\"], prevProps[\"data\"])) || this.props[\"dataKeyToPlot\"] !== prevProps[\"dataKeyToPlot\"]) {\n            this.redraw();\n        }\n    }\n\n    getXScale(width: number, genome: Genome, chr?: string, implicitStart ?: number | null, implicitEnd ?: number | null, showPurityPloidy?: boolean) {\n        let domain = [0, 0];\n        if(implicitStart != null && implicitEnd != null) {\n            domain[0] = implicitStart;\n            domain[1] = implicitEnd;\n        } else if (!chr) { // No chromosome specified: X domain is entire genome\n            domain[1] = genome.getLength();\n        } else { // Chromosome specified: X domain is length of one chromosome\n            domain[0] = genome.getChrStartMap()[chr];\n            domain[1] = domain[0] + genome.getLength(chr);\n        }\n        // const leftPadding = (showPurityPloidy) ? PAD\n        // ;\n\n        return d3.scaleLinear()\n            .domain(domain)\n            .range([getLeftPadding(this.props.showPurityPloidy), width - PADDING.right]);\n    }\n\n    getScaledYScale(height: number, purity: number) {\n        return d3.scaleLinear().domain([2*(1 - purity), purity * 10 + 2*(1-purity)]).range([height - PADDING.bottom, PADDING.top])\n    }\n\n    createNewBrush() {\n        const svg = d3.select(this._svg);\n        const brush = d3.brush()\n        .keyModifiers(true)\n        .extent([[getLeftPadding(this.props.showPurityPloidy), PADDING.top], \n                [this.props.width - PADDING.right, this.props.height - PADDING.bottom]])\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    \n                });\n                \n        // attach the brush to the chart\n        svg.append('g')\n            .attr('class', 'brush')\n            .call(brush);\n    }\n\n    filterFractionalCNTicks(ticks: number[], domain: number[]) {\n        return ticks.filter((value, i) => value > domain[0] && value < domain[1]);\n    }\n\n    redraw() {\n        if (!this._svg) {\n            return;\n        }\n\n        \n\n        let self = this;\n        const {data, width, height, genome, chr, dataKeyToPlot, \n            yMin, yMax, yLabel, customColor, brushedBins, colors, displayMode, driverGenes} = this.props;\n        \n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy); // Full genome implicit scale\n        const yScale = d3.scaleLinear()\n            .domain([yMin, yMax])\n            .range([height - PADDING.bottom, PADDING.top]);\n\n        // Stores all chrs that are within the xscale bounds\n        const chromosomes = genome.getChromosomeList();\n        let chrs: Chromosome[]= [];\n        let chrStarts = genome.getChrStartMap();\n\n        for(let chr of chromosomes) {\n            let start = chrStarts[chr.name];\n            if(start >= xScale.domain()[0] && start <= xScale.domain()[1]) {\n                chrs.push(chr);\n            }\n        }\n\n        const yLabelShift = (this.props.showPurityPloidy) ? 10 : 0\n        const svg = d3.select(this._svg);\n        svg.selectAll(\".\" + SCALES_CLASS_NAME).remove(); // Remove any previous scales\n        svg.append(\"text\")       // X axis text\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"font-size\", 11)\n            .attr(\"x\", _.mean(xScale.range()))\n            .attr(\"y\", height - PADDING.bottom + 30)\n            .text(chr || genome.getName());\n        svg.append(\"text\")      // Y axis Text\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `rotate(-90, ${getLeftPadding(this.props.showPurityPloidy)}, ${_.mean(yScale.range())})`)\n            .text(yLabel || dataKeyToPlot)\n            .attr(\"x\", (height - PADDING.bottom - PADDING.top) / 2 - 1 + yLabelShift)\n            .attr(\"y\", (this.props.showPurityPloidy) ? 10 : getLeftPadding(this.props.showPurityPloidy)/2 + 5)\n            .attr(\"text-anchor\", \"middle\");\n        \n        const chrTicks = genome.getChromosomeStarts2(chrs)\n        const xAxisTicksNoOverlap : number[] = []\n        const filteredChrs : Chromosome[] = []\n        if (chrTicks.length > 0) {\n            xAxisTicksNoOverlap.push(chrTicks[0])\n            filteredChrs.push(chrs[0])\n        }\n\n        for(let i = 1; i < chrTicks.length; i++) {\n            let first = xScale(xAxisTicksNoOverlap[xAxisTicksNoOverlap.length-1]) || 0;\n            let second = xScale(chrTicks[i]) || 0;\n            let pixelDist = second - first;\n\n            if(pixelDist > 8) {\n                xAxisTicksNoOverlap.push(chrTicks[i]);\n                filteredChrs.push(chrs[i]);\n            }\n        }\n\n        let xAx = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale)\n                    .tickValues(xAxisTicksNoOverlap)\n                    .tickFormat((unused, i) => findChrNumber(filteredChrs[i].name)))\n        \n        let xAx2 = (g : any, scale : any) => g\n            .classed(SCALES_CLASS_NAME, true)\n            .attr(\"transform\", `translate(0, ${height - PADDING.bottom})`)\n            .call(d3.axisBottom(scale)\n                    .tickFormat(baseNum => {\n                        return niceBpCount(Number(baseNum.valueOf()), 0, chrStarts[chr])\n                    }))\n        \n        \n        let yAx = (g : any, scale : any) => g\n                    .classed(SCALES_CLASS_NAME, true)\n                    .attr(\"transform\", `translate(${getLeftPadding(this.props.showPurityPloidy)}, 0)`)\n                    .call(d3.axisLeft(scale).ticks((scale.range()[0] - scale.range()[1]) / 15))\n        \n        \n        if(this.props.dataKeyToPlot === \"fractional_cn\") {\n            const ticks  = this.props.fractionalCNTicks;\n            const domain = yScale.domain();\n\n            const filteredTicks = ticks.filter(d => d.fractionalTick > domain[0] && d.fractionalTick < domain[1]) // this.filterFractionalCNTicks(ticks, yScale.domain())\n            const filteredTicksVals = filteredTicks.map(d => d.fractionalTick);\n            \n            const ticksWithoutOverlap : number[] = []\n            const filterFractionalTicksNoOverlap : fractional_copy_number[] = []\n\n            if(filteredTicks.length > 0) {\n                ticksWithoutOverlap.push(filteredTicksVals[0])\n                filterFractionalTicksNoOverlap.push(filteredTicks[0])\n            }\n\n            for(let i = 1; i < filteredTicks.length; i++) {\n                let first = yScale(ticksWithoutOverlap[ticksWithoutOverlap.length-1]) || 0;\n                let second = yScale(filteredTicksVals[i]) || 0;\n                let pixelDist = first - second;\n\n                if(pixelDist > 8) {\n                    ticksWithoutOverlap.push(filteredTicksVals[i]);\n                    filterFractionalTicksNoOverlap.push(filteredTicks[i])\n                }\n            }\n            \n            yAx = (g : any, scale : any) => g\n                .classed(SCALES_CLASS_NAME, true)\n                .attr(\"id\", \"Grid\")\n                .attr(\"transform\", `translate(${getLeftPadding(this.props.showPurityPloidy)}, 0)`)\n                .call(d3.axisLeft(scale).tickValues(ticksWithoutOverlap).tickSizeInner(-width + 60).tickFormat((d, i) => filterFractionalTicksNoOverlap[i].totalCN + \" (\"+  Number(d.valueOf()).toFixed(2)+\")\"))\n\n        } else if(this.props.showPurityPloidy) {\n            const currYDomain = yScale.domain();\n\n            let new_BAF_lines : cn_pair[] = [];  // gc\n            const currXDomain = this._currXScale.domain();\n            // console.log(\"[Scatterplot render() -> showTetraploid\", this.props.showTetraploid);\n            if (!this.props.showTetraploid) {\n                const new_BAF_ticks : cn_pair[] = [];\n                // filter BAF lines\n                for(const cn_pair_i of this.props.BAF_lines) {\n                    if ((cn_pair_i.state[0] + cn_pair_i.state[1]) < 4) {\n                        new_BAF_ticks.push(cn_pair_i); \n                    }\n                }\n                new_BAF_lines = new_BAF_ticks; \n            } else {\n                new_BAF_lines = this.props.BAF_lines; \n            }\n\n            const filteredBAFTicks = new_BAF_lines.filter(value => value.tick > currYDomain[0] && value.tick < currYDomain[1])\n            const ticks = filteredBAFTicks.map(d => d.tick);\n            const ticks_without_overlap : number[] = []\n            const filterBAFTicks_no_overlap : cn_pair[] = []\n\n            if(ticks.length > 0) {\n                ticks_without_overlap.push(ticks[0])\n                filterBAFTicks_no_overlap.push(filteredBAFTicks[0])\n            }\n\n            for(let i = 1; i < ticks.length; i++) {\n                // console.log(ticks[i])\n                let first = yScale(ticks_without_overlap[ticks_without_overlap.length-1]) || 0;\n                let second = yScale(ticks[i]) || 0;\n                let dist_test = first - second;\n\n                if(dist_test > 8) {\n                    ticks_without_overlap.push(ticks[i]);\n                    filterBAFTicks_no_overlap.push(filteredBAFTicks[i])\n                }\n            }\n\n            yAx = (g : any, scale : any) => g\n                .classed(SCALES_CLASS_NAME, true)\n                .attr(\"id\", \"Grid\")\n                .attr(\"transform\", `translate(${getLeftPadding(this.props.showPurityPloidy)}, 0)`)\n                .call(d3.axisLeft(scale).tickValues(ticks_without_overlap).tickSizeInner(-width + getLeftPadding(this.props.showPurityPloidy) + PADDING.right).tickFormat((d, i) =>  (filterBAFTicks_no_overlap[i].state[0] == filterBAFTicks_no_overlap[i].state[1]) ? ticks_without_overlap[i].toFixed(2) + \" (x,x)\" : ticks_without_overlap[i].toFixed(2) + \" (\"+filterBAFTicks_no_overlap[i].state[0]+\",\"+filterBAFTicks_no_overlap[i].state[1]+\")\"))\n                //.call(d3.axisLeft(scale).tickValues(ticks_without_overlap).tickSizeInner(-width + getLeftPadding(this.props.showPurityPloidy) + PADDING.right).tickFormat((d, i) =>  ticks_without_overlap[i].toFixed(2) + \" (\"+filterBAFTicks_no_overlap[i].state[0]+\",\"+filterBAFTicks_no_overlap[i].state[1]+\")\"))\n                //.call(d3.axisLeft(scale).tickValues(ticksWithoutOverlap).tickSizeInner(-width + 60).tickFormat((d, i) => (Number(d.valueOf()).toFixed(2) != Number(d.valueOf()).toFixed(2)) ? filterFractionalTicksNoOverlap[i].totalCN + \" (\"+  Number(d.valueOf()).toFixed(2)+\")\" : filterFractionalTicksNoOverlap[i].totalCN + \" (x,x)\"));\n\n        }\n\n\n        // Zooming along each individual axis\n        const gx = svg.append(\"g\");\n        const gy = svg.append(\"g\");\n        let z = d3.zoomIdentity;\n        const zoomX : any = d3.zoom().scaleExtent([0, 100]);\n        const zoomY : any = d3.zoom().scaleExtent([0, 100]);\n        const tx = () => d3.zoomTransform(gx.node() as Element);\n        const ty = () => d3.zoomTransform(gy.node() as Element);\n        gx.call(zoomX).attr(\"pointer-events\", \"none\");\n        gy.call(zoomY).attr(\"pointer-events\", \"none\");\n\n        const zoom : any = d3.zoom().on(\"zoom\", () => {\n            try {\n                const t = d3.event.transform;\n                const k = t.k / z.k;\n                const point = (d3.event.sourceEvent) ? [d3.event.sourceEvent.layerX, d3.event.sourceEvent.layerY] : [width / 2, height / 2];\n\n                // is it on an axis?\n                const doX = point[0] > xScale.range()[0];\n                const doY = point[1] < yScale.range()[0];\n\n                if(displayMode === DisplayMode.zoom || !(doX && doY)) {\n                    if (k === 1) {\n                        // pure translation?\n                        doX && zoomX && k && point && gx && gx.call(zoomX.translateBy, (t.x - z.x) / tx().k, 0);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.translateBy, 0, (t.y - z.y) / ty().k);\n                    } else {\n                        // if not, we're zooming on a fixed point\n                        doX && zoomX && k && point && gx && gx.call(zoomX.scaleBy, k, point);\n                        doY && zoomY && k && point && gy && gy.call(zoomY.scaleBy, k, point);\n                    }\n                }\n                z = t;\n                redraw();\n            } catch(error) {\n                console.log(\"Error: \", error);\n            }\n          }).on(\"end\", () => {  // After finishing zoom event, send information to other plots about the new scales -> Keeps plots in sync with each other\n              \n                if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\" || this.props[\"dataKeyToPlot\"] === \"fractional_cn\") {\n                    self.props.onLinearPlotZoom([self._currXScale.domain()[0], self._currXScale.domain()[1]], [self._currYScale.domain()[0], self._currYScale.domain()[1]], true);\n                } else {\n                    self.props.onLinearPlotZoom([self._currXScale.domain()[0], self._currXScale.domain()[1]], [self._currYScale.domain()[0], self._currYScale.domain()[1]], false);\n                }\n            }\n\n        );\n\n        if (!this._canvas) {\n            return;\n        }\n\n        this._canvas.width = 800;\n        this._canvas.height = 150;\n        let previous : string[] = [];\n        brushedBins.forEach(d => previous.push(GenomicBinHelpers.toChromosomeInterval(d).toString()));\n        let previous_brushed_nodes = new Set(previous);\n        \n        const gl = this._canvas.getContext(\"webgl\")!;\n        gl.clearColor(0,0,0,1);\n        let colorFill = (d:any) => {\n            return webglColor(chooseColor(d));\n        };\n\n        let fillColor = fc.webglFillColor().value(colorFill).data(data);\n        let pointSeries = fc\n                .seriesWebglPoint()\n                // .size(3)\n                .crossValue((d : any) => genome.getImplicitCoordinates(GenomicBinHelpers.toChromosomeInterval(d)).getCenter())\n                .mainValue((d : any) => d[dataKeyToPlot])\n                .context(gl)\n                .size(this.props.pointsize);\n        pointSeries.decorate((program:any) => fillColor(program));\n\n        svg\n            .append(\"clipPath\")\n            .attr(\"id\", \"clip2\")\n            .append(\"rect\")\n                .attr(\"x\", getLeftPadding(this.props.showPurityPloidy))\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width)\n                .attr(\"height\", height)\n                .attr(\"fill\", \"red\");\n\n        // Create event-rect that allows for svg points to be overlayed under mouse pointer\n        svg\n            .append(\"g\")\n            .classed(\"eventrect\", true)\n            .append(\"rect\")\n                .attr(\"x\", getLeftPadding(this.props.showPurityPloidy))\n                .attr(\"y\", PADDING.top)\n                .attr(\"width\", width - PADDING.right - getLeftPadding(this.props.showPurityPloidy))\n                .attr(\"height\", height - PADDING.bottom - PADDING.top)\n                .style(\"fill\", \"none\")\n                .style(\"pointer-events\", \"all\")\n                .attr(\"clip-path\", \"url(#clip2)\");\n\n        var mouseover = function(d : Gene) {\n            self.previewDriver = d;\n        }\n\n        var mouseleave = function(d : Gene) {\n            self.previewDriver = null;\n        }\n\n\n        function redraw() {\n            \n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.clearColor(255,255,255,1);\n            const yr = ty().rescaleY(yScale);\n\n            gy.call(yAx, yr);\n            self._currYScale = yr;\n            if(!chr) {\n                const xr = tx().rescaleX(xScale);\n                gx.call(xAx , xr);\n                self._currXScale = xr;\n                pointSeries.xScale(xr).yScale(yr);\n            } else {\n                const xr = tx().rescaleX(xScale);\n                gx.call(xAx2 , xr);\n                self._currXScale = xr;\n                pointSeries.xScale(xr).yScale(yr);\n            }\n        \n            pointSeries(data);\n\n            if(driverGenes) {\n                svg.select(\".Drivers\").remove();\n                svg.select(\".eventrect\")\n                        .append(\"g\")\n                        .attr(\"clip-path\", \"url(#clip2)\")\n                        .classed(\"Drivers\", true)\n                        .selectAll(\"circle\")\n                        .data(driverGenes)\n                            .enter()\n                            .append(\"circle\")\n                            .attr(\"class\", \"point\")\n                            .attr(\"d\", d3.symbol().type(d3.symbolCircle))\n                            .attr(\"fill\", \"red\")\n                            .attr(\"fill-opacity\", 1)\n                            .attr(\"stroke-width\", 2)\n                            .attr(\"r\", 2)\n                            .attr(\"transform\", function(d) {\n                                return \"translate(\" + self._currXScale(genome.getImplicitCoordinates(d.location).getCenter()) + \",\" + ((self._currYScale(yr.domain()[0]) || 0) + 3) + \")\"; \n                            })\n                            .on(\"mouseover\", mouseover)\n                            .on(\"mouseleave\", mouseleave )\n                            .on(\"click\", d => {\n                                let dest = \"\";\n                                if(dataKeyToPlot === \"reverseBAF\" && self.props.applyLog) {\n                                    dest = \"logRD\"\n                                } else if(dataKeyToPlot === \"reverseBAF\" && self.props.showPurityPloidy) {\n                                    dest = \"fractional_cn\"\n                                } else if(dataKeyToPlot === \"reverseBAF\"){\n                                    dest = \"RD\"\n                                } else {\n                                    dest = \"reverseBAF\"\n                                }\n\n                                (self.lockedDrivers.has(d)) ? self.lockedDrivers.delete(d) : self.lockedDrivers.add(d);\n                                self.props.handleDriverGenesChange({gene: d, destination: dest});\n                            })\n            }\n        }\n\n        redraw();\n\n        function chooseColor(d: GenomicBin) {\n            if(previous_brushed_nodes.has(GenomicBinHelpers.toChromosomeInterval(d).toString())) {\n                return customColor;\n            } else if (d.CLUSTER === -1){\n                return UNCLUSTERED_COLOR;\n            } else if(d.CLUSTER === -2){\n                return DELETED_COLOR;\n            } else {\n                const cluster = d.CLUSTER;\n                const col_index = cluster % colors.length;\n                return colors[col_index];\n            }\n        }\n\n        let brush : any = null;\n        if(displayMode === DisplayMode.select || displayMode === DisplayMode.erase) {\n            brush = d3.brush()\n                .keyModifiers(false)\n                .extent([[getLeftPadding(this.props.showPurityPloidy), PADDING.top], \n                        [this.props.width, this.props.height - PADDING.bottom]])\n                .on(\"start brush\", () => {\n                    const {selection} = d3.event;\n                    if(selection && selection[0][0] !== selection[1][0] && selection[0][1] !== selection[1][1]) {\n                        function rectContains(rect : any, point : any) {\n                            const X = 0;\n                            const Y = 1;\n                            const TOP_LEFT = 0;\n                            const BOTTOM_RIGHT = 1;\n                            return rect[TOP_LEFT][X] <= point[X] && point[X] <= rect[BOTTOM_RIGHT][X] &&\n                                   rect[TOP_LEFT][Y] <= point[Y] && point[Y] <= rect[BOTTOM_RIGHT][Y];\n                        }\n                        \n                        let brushed : GenomicBin[] = data.filter(d => {\n                            const location = GenomicBinHelpers.toChromosomeInterval(d);\n                            const range = genome.getImplicitCoordinates(location);\n                            return rectContains(selection, [xScale(range.getCenter()), yScale(d[dataKeyToPlot])])\n                        });\n\n                        function currContains(currNode: any, toEraseSet: any) {\n                            let existingNode = (currNode[\"#CHR\"], currNode[\"START\"], currNode[\"END\"], currNode[\"genomicPosition\"]);\n                            if (toEraseSet.has(existingNode)) { // if existing node is one to delete\n                                return false; // filter out\n                            } else { // if existing node is not one to delete\n                                return true; // keep in \n                            }\n                        }\n\n                        if (brushed) {\n                            if(displayMode === DisplayMode.select) {\n                                brushed = _.uniqBy(_.union(brushed, brushedBins), element => element[\"#CHR\"] + \"_\" + element.START);  \n                            } else if(displayMode === DisplayMode.erase) {\n                                let toEraseSet = new Set(); \n                                for(let i = 0; i < brushed.length; i++) {\n                                    toEraseSet.add((brushed[i][\"#CHR\"], brushed[i][\"START\"], brushed[i][\"END\"], brushed[i][\"genomicPosition\"]));\n                                }\n                                brushed = brushedBins.filter(d => currContains(d, toEraseSet)); \n                                // brushed = _.difference(existingSet, newBrushSet); \n                            }\n        \n                            this.brushedNodes = new Set(brushed);                  \n                        }\n                        \n                    } else {\n                        this.brushedNodes = new Set([]);\n                    }\n                })\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    this.props.onBrushedBinsUpdated([...this.brushedNodes]);\n                });\n\n                svg.append('g')\n                    .attr('class', 'brush')\n                    .call(brush);\n        } else if(displayMode === DisplayMode.boxzoom) { // || displayMode === DisplayMode.zoom) {\n            brush = d3.brushX()\n                .extent([[getLeftPadding(this.props.showPurityPloidy), PADDING.top], \n                        [this.props.width, this.props.height - PADDING.bottom]])\n                .on(\"end\", () => {\n                    svg.selectAll(\".brush\").remove();\n                    const {selection} = d3.event;\n                    try {\n                        const startEnd = {\n                            start: selection[0],\n                            end: selection[1]\n                        };\n                        const implicitStart = xScale.invert(startEnd.start);\n                        const implicitEnd = xScale.invert(startEnd.end);\n                    \n                        if(this.props[\"dataKeyToPlot\"] === \"RD\" || this.props[\"dataKeyToPlot\"] === \"logRD\" || this.props[\"dataKeyToPlot\"] === \"fractional_cn\") {\n                            this.props.onLinearPlotZoom([implicitStart, implicitEnd], [self._currYScale.domain()[0], self._currYScale.domain()[1]], true);\n                        } else {\n                            this.props.onLinearPlotZoom([implicitStart, implicitEnd], [self._currYScale.domain()[0], self._currYScale.domain()[1]], false);\n                        }\n                    } catch (error) {}\n                })\n\n            svg.append('g')\n                .attr('class', 'brush')\n                .call(brush);\n        }\n        svg.call(zoom).call(zoom.transform, d3.zoomIdentity.scale(1.0));\n    }\n\n    renderHighlight() {\n        const {width, genome, chr, hoveredLocation} = this.props;\n        if (!hoveredLocation) {\n            return null;\n        }\n\n        if(this.previewDriver != null) {\n            return null;\n        }\n\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy);\n        const implicitCoords = genome.getImplicitCoordinates(hoveredLocation);\n        const start = xScale(implicitCoords.start);\n        const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n        if(start && start > 0) {\n            return <div className=\"highlight\" style={{\n                position: \"absolute\",\n                left: start,\n                width: boxWidth,\n                height: \"100%\",\n                backgroundColor: \"rgba(0,0,0,1)\",\n                border: \"1px solid rgba(0,0,0,1)\",\n                zIndex: 1,\n        }} />\n        }\n    }\n\n    handleMouseMove(event: React.MouseEvent) {\n        const {width, genome, chr, onLocationHovered} = this.props;\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy);\n        const range = xScale.range();\n        const mouseX = getRelativeCoordinates(event).x;\n        if (mouseX < range[0] || mouseX > range[1]) { // Count mouse events outside the range as mouseleaves\n            this.handleMouseLeave();\n            return;\n        }\n        const implicitLocation = xScale.invert(mouseX);\n        onLocationHovered(genome.getChromosomeLocation(implicitLocation));\n    }\n\n    handleMouseLeave() {\n        this.props.onLocationHovered(null);\n    }\n\n    render() {\n        const {width, height, dataKeyToPlot} = this.props;\n        return <div\n                className=\"LinearPlot\"\n                style={{position: \"relative\", width: width, height: height}}\n                onMouseMove={this.handleMouseMove}\n                onMouseLeave={this.handleMouseLeave}\n            >\n\n            {this.renderLockedDrivers()}\n            {this.renderTooltip()}\n            {this.renderHighlight()}\n            \n            <canvas\n                ref={node => this._canvas = node}\n                width={width}\n                height={height}\n                className={\"canvas\"}\n                style={{position: \"absolute\", \n                        top: PADDING.top, \n                        zIndex: -1, \n                        left: getLeftPadding(this.props.showPurityPloidy), \n                        width: width-getLeftPadding(this.props.showPurityPloidy) - PADDING.right, \n                        height: height-PADDING.top-PADDING.bottom}} />\n            \n            <svg ref={node => this._svg = node} preserveAspectRatio={'xMinYMin meet'} viewBox={'0 0 ' + (width) + ' ' + (height)}/>\n            <div className=\"LinearPlot-tools\">\n                {(dataKeyToPlot === \"RD\" || dataKeyToPlot === \"logRD\" || dataKeyToPlot === \"fractional_cn\")\n                && <button className=\"custom-button linear-plot-button\" onClick={() => {\n                    this.props.onLinearPlotZoom(null, null, true, true);\n                }}\n                >Reset View</button>}\n            </div>\n        </div>;\n    }\n\n    renderLockedDrivers() {\n        const {width, genome, chr, height} = this.props;\n        let shouldAddBack = false;\n        if(this.previewDriver != null && this.lockedDrivers.has(this.previewDriver)) {\n            this.lockedDrivers.delete(this.previewDriver);\n            shouldAddBack = true;\n        }\n\n        const drivers = [...this.lockedDrivers].sort((a:Gene, b: Gene) => a.location.start - b.location.start);\n        if(this.previewDriver != null && shouldAddBack) {\n            this.lockedDrivers.add(this.previewDriver);\n        }\n\n        const label_divs : number[][] = [];\n        \n        return (\n            drivers.map(\n                (driver, idx) => {\n                    const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy);\n                    const implicitCoords = genome.getImplicitCoordinates(driver.location);\n                    const start = xScale(implicitCoords.start) || 0;\n                    const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n                    const driverSymbol = driver.symbol;\n                    const contents = <React.Fragment>\n                                        <div> {driverSymbol} </div>\n                                    </React.Fragment>;\n\n                    let shouldRenderLabel = true;\n                    const w = (driverSymbol.length > 4) ? DRIVER_LABEL_WIDTH + 5*(driverSymbol.length-4) : DRIVER_LABEL_WIDTH;\n                    const currentCoord = [start-w/2, start + w/2];\n                    for(const coord of label_divs) {\n                        if(coord[0] > currentCoord[0] && coord[0] < currentCoord[1]) {\n                            shouldRenderLabel = false;\n                            break;\n                        } else if(currentCoord[0] > coord[0] && currentCoord[0] < coord[1]) {\n                            shouldRenderLabel = false;\n                            break;\n                        }\n                    }\n                    if(shouldRenderLabel) {\n                        label_divs.push(currentCoord);\n                    }\n                    if(start > getLeftPadding(this.props.showPurityPloidy) && start < width - PADDING.right) {\n                        \n                        return (\n                            <div key={this.props.dataKeyToPlot + driverSymbol}>\n                                <div style={{\n                                    position: \"absolute\",\n                                    left: start-w/2,\n                                    width: w,\n                                    bottom: height,\n                                    border: \"1px solid rgba(0,0,0,0)\",\n                                    zIndex: idx,\n                                    pointerEvents: \"none\",\n                                    display: (shouldRenderLabel) ? \"\" : \"none\",\n                                }}>\n                                    {contents}\n                                </div>\n                                <div className=\"highlight\" style={{\n                                    position: \"absolute\",\n                                    left: start,\n                                    width: boxWidth,\n                                    height: \"75%\",\n                                    backgroundColor: \"rgba(255,165,0,1)\",\n                                    border: \"1px solid rgba(255,165,0,1)\",\n                                    zIndex: idx,\n                                }} />   \n                        </div>\n                        )\n                    } else {\n                        return null;\n                    }\n                }\n            ))\n    }\n\n    renderTooltip() {\n        const {driverGenes, hoveredLocation, width, genome, chr, height} = this.props;\n\n        if (!hoveredLocation) {\n            return null;\n        }\n\n        if(!driverGenes) {\n            return null;\n        }\n\n        if(!this.previewDriver) {\n            return null;\n        }\n\n        const xScale = this.getXScale(width, genome, chr, this.props.implicitStart, this.props.implicitEnd, this.props.showPurityPloidy);\n        const implicitCoords = genome.getImplicitCoordinates(this.previewDriver.location);\n        const start = xScale(implicitCoords.start) || 0;\n        const boxWidth = Math.ceil((xScale(implicitCoords.end) || 0) - (start || 0));\n        const driverSymbol = this.previewDriver.symbol;\n\n        const contents = <React.Fragment>\n                            <div> {driverSymbol} </div>\n                        </React.Fragment>\n\n        const w = (driverSymbol.length > 4) ? DRIVER_LABEL_WIDTH + 5*(driverSymbol.length-4) : DRIVER_LABEL_WIDTH;\n\n        return (\n            <div>\n                <div style={{\n                    position: \"absolute\",\n                    left: start-w/2,\n                    bottom: height+1,\n                    backgroundColor: \"white\",\n                    border: \"1px solid rgba(0,0,0,0)\",\n                    zIndex: 2\n                }}>\n                    {contents}\n                </div>\n                <div className=\"highlight\" style={{\n                    position: \"absolute\",\n                    left: start,\n                    width: boxWidth + 1,\n                    height: \"75%\",\n                    backgroundColor: (this.lockedDrivers.has(this.previewDriver)) ?\"red\" : \"rgba(0, 200 , 0, 1)\",\n                    zIndex: 0\n                }} />   \n            </div>\n        )\n    }\n}","import React from \"react\";\n\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport {DisplayMode, genome} from \"../App\";\nimport { LinearPlot } from \"./LinearPlot\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { Gene } from \"../model/Gene\";\nimport { cn_pair, fractional_copy_number } from \"../constants\";\n\ninterface Props {\n    pointsize: number; \n    data: GenomicBin[];\n    chr: string;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered?: (location: ChromosomeInterval | null) => void\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    customColor: string;\n    colors: string[];\n    yScale: [number, number] | null;\n    xScale: [number, number] | null;\n    clusterTableData: any;\n    applyLog: boolean;\n    displayMode: DisplayMode;\n    width: number;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    implicitStart: number | null;\n    implicitEnd: number | null;\n    onZoom: (newScales: any) => void;\n    driverGenes: Gene[] | null;\n    handleDriverGenesChange: (sentGene: {gene: Gene | null, destination: string | null}) => void;\n    driverGeneUpdate: {gene: Gene | null, destination: string | null};\n    purity: number;\n    ploidy: number;\n    meanRD: number;\n    fractionalCNTicks: fractional_copy_number[];\n    showPurityPloidy: boolean;\n    showTetraploid: boolean;\n    BAF_lines: cn_pair[];\n}\n\nexport function RDLinearPlot(props: Props & {rdRange: [number, number]}) {\n    const {data, chr, pointsize, rdRange, hoveredLocation, onLocationHovered, onBrushedBinsUpdated, \n        brushedBins, customColor, colors, yScale, clusterTableData, applyLog, \n        displayMode, width, onLinearPlotZoom, implicitStart, implicitEnd, onZoom, driverGenes, purity, ploidy, meanRD, fractionalCNTicks, showPurityPloidy, showTetraploid, BAF_lines} = props;\n\n    return <LinearPlot\n                pointsize={pointsize}\n                data={data}\n                dataKeyToPlot={(applyLog) ? \"logRD\" : ((showPurityPloidy) ? \"fractional_cn\" : \"RD\")}\n                applyLog={applyLog}\n                genome={genome}\n                chr={chr}\n                hoveredLocation={hoveredLocation}\n                onLocationHovered={onLocationHovered}\n                onBrushedBinsUpdated={onBrushedBinsUpdated}\n                yMin={yScale ? yScale[0] : (showPurityPloidy ? rdRange[0] : (applyLog ? -2 : 0))}\n                yMax={yScale ? yScale[1] : rdRange[1]}\n                yLabel={applyLog ? \"log RDR\" : (showPurityPloidy ? \"Copy Number\" : \"RDR\")}\n                brushedBins={brushedBins}\n                customColor={customColor}\n                colors={colors}\n                clusterTableData={clusterTableData}\n                displayMode={displayMode}\n                width={width}\n                onZoom={onZoom}\n                onLinearPlotZoom={onLinearPlotZoom}\n                implicitStart={implicitStart}\n                implicitEnd={implicitEnd}\n                driverGenes={driverGenes}\n                driverGeneUpdate={props.driverGeneUpdate}\n                handleDriverGenesChange={props.handleDriverGenesChange}\n                purity={purity}\n                ploidy={ploidy}\n                meanRD={meanRD}\n                fractionalCNTicks={fractionalCNTicks}\n                showPurityPloidy={showPurityPloidy}\n                showTetraploid={showTetraploid}\n                BAF_lines={BAF_lines}\n        />\n}\n\nexport function BAFLinearPlot(props: Props) {\n    const {data, chr, pointsize, hoveredLocation, onLocationHovered, onBrushedBinsUpdated, brushedBins, \n            customColor, colors, xScale, clusterTableData, displayMode, width, onLinearPlotZoom, \n            implicitStart, implicitEnd, onZoom, driverGenes, applyLog, purity, ploidy, meanRD, showPurityPloidy, showTetraploid, fractionalCNTicks, BAF_lines} = props;\n\n    return <LinearPlot\n                pointsize={pointsize}\n                data={data}\n                chr={chr}\n                dataKeyToPlot=\"reverseBAF\"\n                applyLog={applyLog}\n                genome={genome}\n                hoveredLocation={hoveredLocation}\n                onLocationHovered={onLocationHovered}\n                onBrushedBinsUpdated= {onBrushedBinsUpdated}\n                yMin={xScale ? xScale[0] : -.01}\n                yMax={xScale ? xScale[1] : 0.51}\n                yLabel={\"0.5 - BAF\"}\n                brushedBins={brushedBins}\n                customColor={customColor}\n                colors={colors} \n                clusterTableData={clusterTableData}\n                displayMode={displayMode}\n                width={width}\n                onLinearPlotZoom={onLinearPlotZoom}\n                implicitStart={implicitStart}\n                implicitEnd={implicitEnd}\n                onZoom={onZoom}\n                driverGenes={driverGenes}\n                driverGeneUpdate={props.driverGeneUpdate}\n                handleDriverGenesChange={props.handleDriverGenesChange}\n                purity={purity}\n                ploidy={ploidy}\n                meanRD={meanRD}\n                showPurityPloidy={showPurityPloidy}\n                showTetraploid={showTetraploid}\n                fractionalCNTicks={fractionalCNTicks}\n                BAF_lines={BAF_lines}\n        />;\n}\n\n\n","import React from \"react\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { DivWithBullseye } from \"./DivWithBullseye\";\nimport { RDLinearPlot, BAFLinearPlot} from \"./RdrBafLinearPlots\";\n\nimport \"./SampleViz.css\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { DisplayMode } from \"../App\";\nimport { Gene } from \"../model/Gene\";\nimport { cn_pair, fractional_copy_number } from \"../constants\";\n\nimport classnames from 'classnames'; \n\ninterface Props {\n    pointsize: number; \n    data: GenomicBin[];\n    chr: string;\n    hoveredLocation?: ChromosomeInterval;\n    initialSelectedSample: string;\n    onLocationHovered?: (location: ChromosomeInterval | null) => void;\n    onBrushedBinsUpdated: (brushedBins: GenomicBin[]) => void;\n    brushedBins: GenomicBin[];\n    customColor: string;\n    colors: string[];\n    selectedSample: string;\n    yScale: [number, number] | null;\n    xScale: [number, number] | null;\n    rdRange: [number, number];\n    clusterTableData: any;\n    applyLog: boolean;\n    displayMode: DisplayMode;\n    width: number;\n    onLinearPlotZoom: (genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) => void;\n    onZoom: (newScales: any) => void;\n    implicitRange: [number, number] | null;\n    driverGenes: Gene[] | null;\n    purity: number;\n    ploidy: number;\n    meanRD: number;\n    fractionalCNTicks: fractional_copy_number[];\n    showPurityPloidy: boolean;\n    showTetraploid: boolean; \n    BAF_lines: cn_pair[];\n}\n\ninterface State {\n    selectedSample: string;\n    sentDriver: {gene: Gene | null, destination: string | null} // keeps baf and RD driver markers in sync by sending what update was done to the lockedDrivers set\n}\n\nexport class SampleViz1D extends React.Component<Props, State> {\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            selectedSample: props.initialSelectedSample,\n            sentDriver: {gene: null, destination: null}\n        };\n\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleDriverGenesChange = this.handleDriverGenesChange.bind(this);\n    }\n\n    handleSelectedSampleChanged(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedSample: event.target.value});\n    }\n\n    handleDriverGenesChange(sentGene: {gene: Gene | null, destination: string | null}) {\n        this.setState({sentDriver: sentGene});\n    }\n\n    render() {\n        const {data, chr, hoveredLocation, pointsize, onLocationHovered, onBrushedBinsUpdated, brushedBins,\n             customColor, yScale, xScale, rdRange, clusterTableData, applyLog, displayMode, width, onLinearPlotZoom, implicitRange, onZoom, driverGenes,\n            purity, ploidy, meanRD, fractionalCNTicks, showPurityPloidy, showTetraploid, BAF_lines} = this.props;\n        \n            const myDisplayClasses = classnames ({\n            'is-pan' : displayMode === DisplayMode.zoom,\n            'is-zoom' : displayMode === DisplayMode.boxzoom, \n            'is-select' : displayMode === DisplayMode.select, \n            'is-erase' : displayMode === DisplayMode.erase\n        })\n    \n        let visualization: React.ReactNode = null;\n            // visualization = <DivWithBullseye className=\"SampleViz-pane\">\n            visualization = <DivWithBullseye className={myDisplayClasses}>\n            {/* <DivWithBullseye className={myDisplayClasses}>  */}\n                <RDLinearPlot\n                    pointsize={pointsize}\n                    data={data}\n                    chr={chr}\n                    rdRange={rdRange}\n                    hoveredLocation={hoveredLocation}\n                    onLocationHovered={onLocationHovered} \n                    onBrushedBinsUpdated={onBrushedBinsUpdated}\n                    brushedBins={brushedBins}\n                    customColor={customColor}\n                    colors={this.props.colors}\n                    yScale= {yScale}\n                    xScale= {xScale}\n                    clusterTableData={clusterTableData}\n                    applyLog={applyLog}\n                    displayMode={displayMode}\n                    width={width}\n                    onLinearPlotZoom ={onLinearPlotZoom}\n                    implicitStart={(implicitRange) ? implicitRange[0] : implicitRange}\n                    implicitEnd={(implicitRange) ? implicitRange[1] : implicitRange}\n                    onZoom={onZoom}\n                    driverGenes={driverGenes}\n                    handleDriverGenesChange={this.handleDriverGenesChange}\n                    driverGeneUpdate={this.state.sentDriver}\n                    purity={purity}\n                    ploidy={ploidy}\n                    meanRD={meanRD}\n                    fractionalCNTicks={fractionalCNTicks}\n                    showPurityPloidy={showPurityPloidy}\n                    BAF_lines={BAF_lines}\n                    />\n\n                <div className=\"SampleViz-separator\" />\n                    <BAFLinearPlot\n                    pointsize={pointsize}\n                    data={data}\n                    chr={chr}\n                    hoveredLocation={hoveredLocation}\n                    onLocationHovered={onLocationHovered}\n                    onBrushedBinsUpdated={onBrushedBinsUpdated}\n                    brushedBins={brushedBins} \n                    customColor={customColor}\n                    colors={this.props.colors}\n                    yScale={yScale}\n                    xScale= {xScale}\n                    clusterTableData={clusterTableData}\n                    applyLog={applyLog}\n                    displayMode={displayMode}\n                    width={width}\n                    onLinearPlotZoom={onLinearPlotZoom}\n                    onZoom={onZoom}\n                    implicitStart={(implicitRange) ? implicitRange[0] : implicitRange}\n                    implicitEnd={(implicitRange) ? implicitRange[1] : implicitRange}\n                    driverGenes={driverGenes}\n                    handleDriverGenesChange={this.handleDriverGenesChange}\n                    driverGeneUpdate={this.state.sentDriver}\n                    purity={purity}\n                    ploidy={ploidy}\n                    meanRD={meanRD}\n                    fractionalCNTicks={fractionalCNTicks}\n                    showPurityPloidy={showPurityPloidy}\n                    showTetraploid={showTetraploid}\n                    BAF_lines={BAF_lines}\n                />\n\n                    \n            </DivWithBullseye>;\n\n        return <div className=\"SampleViz-linear\" >\n            {visualization}\n        </div>;\n    }\n}\n","import React from \"react\"\nimport _ from \"lodash\";\nimport DataTable from 'react-data-table-component';\nimport {BlockPicker} from \"react-color\";\nimport \"./ClusterTable.css\"\n\nconst UNCLUSTERED_COLOR = \"#999999\";\n\ninterface Props {\n    data : any;\n    onClusterRowsChange : any;\n    onClusterColorChange: any;\n    currentFilters: String[];\n    selectable ?: boolean;\n    expandable ?: boolean;\n    colOneName : string;\n    colTwoName: string;\n    colThreeName?: string;\n    colFourName?: string;\n    cols: any;\n    centroidTable?: boolean;\n    colors : string[];\n    updatedClusterTable?: () => void;\n}\n\nexport class ClusterTable extends React.Component<Props> {\n    private readonly table_data : any;\n    \n    constructor(props: Props) {\n        super(props);\n        this.table_data = props.data;\n        this.handleColorChange = this.handleColorChange.bind(this);\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return this.props[\"data\"] !== nextProps[\"data\"] ||  this.props[\"colors\"] !== nextProps[\"colors\"];\n    }\n\n    handleColorChange(color : any, index: any) {\n        this.props.colors[index] = color.hex;\n        const tempColors = _.cloneDeep(this.props.colors);\n        this.props.onClusterColorChange(tempColors);\n        this.forceUpdate();\n    }\n    \n    componentDidUpdate(prevProps: Props) {\n        if(this.props.updatedClusterTable)\n            this.props.updatedClusterTable();\n    }\n\n    render() {\n        const {colOneName, colTwoName, colThreeName, colFourName, data, expandable, selectable, colors, centroidTable} = this.props;\n        const ExpandedComponent =(data:any) => \n        <div> \n            <BlockPicker \n                width=\"100%\"\n                color={this.props.colors[data.data.key]}\n                onChangeComplete={c => this.handleColorChange(c, data.data.key)} \n            />\n        </div>;\n\n        type styleType  = {when: (row:any) => any, style: (row:any) => object}\n        const conditionalRowStyles : styleType[] = [\n            {\n              when: (row:any) => row,\n              style: (row:any) => ({\n                backgroundColor: (Number(row.key) === -1) ? UNCLUSTERED_COLOR : colors[Number(row.key) % colors.length],\n                alignItems: 'center',\n                justifyContent: 'center',\n                innerWidth: 50,\n                outerWidth: 50\n\n              }),\n            }\n        ];\n\n        const columns = [\n            {\n              name: colOneName,\n              selector: 'key',\n              sortable: true,\n              compact: true,\n              wrap: true,\n              innerWidth: 40,\n              outerWidth: 40,\n              width: \"50\",\n              center: true\n            },\n            {\n              name: colTwoName,\n              selector: 'value',\n              sortable: true,\n              right: true,\n              compact: true,\n              wrap: true,\n              innerWidth: 40,\n              outerWidth: 40,\n              width: \"50\",\n              center: true\n            },\n        ];\n\n        const columns3 = [\n            {\n                name: colOneName,\n                selector: 'key',\n                sortable: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n            {\n                name: colTwoName,\n                selector: 'value',\n                sortable: true,\n                right: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n            {\n                name: colThreeName,\n                selector: 'selectPerc',\n                sortable: true,\n                right: true,\n                compact: true,\n                wrap: true,\n                center: true\n                // width: \"50\"\n            },\n            {\n                name: colFourName,\n                selector: 'binPerc',\n                sortable: true,\n                right: true,\n                compact: true,\n                wrap: true,\n                center: true\n            }\n        ];\n\n        if(centroidTable) {\n            let colNames : any[] = [];\n            \n            if(data !== null && data !== undefined && data.length > 0) {\n                colNames.push({name: \"Cluster ID\", type: \"key\"})\n                for(const s of Object.keys(data[0].sample)) {\n                    colNames.push({name: s, type: \"sample.\"+s});\n                }\n            }\n        \n            const centroidColumns = [];\n            for(const name of colNames) {\n                let centroidCol = {\n                    name: name.name,\n                    selector: name.type,\n                    sortable: true,\n                    compact: true,\n                    wrap: true,\n                    center: true\n                }\n                centroidColumns.push(centroidCol);\n            }\n            \n            return (\n                <DataTable\n                    columns={centroidColumns}\n                    data={data}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={5}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            )\n\n        }\n        \n        if(!expandable && !selectable) { // selection table\n            return (\n                <DataTable\n                    columns={columns3}\n                    data={data}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={3}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[3, 5, 10, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    noDataComponent={<div style={{padding: 10}}>No Records Selected</div>}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            )\n        }\n\n        return (\n            <div className=\"scroll\">\n                <DataTable\n                    columns={columns}\n                    data={data}\n                    selectableRows\n                    onSelectedRowsChange={this.props.onClusterRowsChange}\n                    selectableRowSelected={row => {\n                        if(this.props.currentFilters.includes(String(row.key))) {\n                            return row;\n                        }\n                    }}\n                    expandableRows\n                    expandableRowsComponent={<ExpandedComponent/>}\n                    expandableRowDisabled={row => row.key === -1 || row.key === -2}\n                    pagination={true}\n                    dense={true}\n                    paginationPerPage={5}\n                    paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                    paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                    noContextMenu={true}\n                    noHeader={true}\n                    conditionalRowStyles={conditionalRowStyles}\n                />\n            </div>\n\n            \n        )\n    }\n};\n\n","import React from \"react\";\nimport { ChromosomeInterval } from \"../model/ChromosomeInterval\";\nimport { DataWarehouse } from \"../model/DataWarehouse\";\nimport { SampleViz2D } from \"./SampleViz2D\";\nimport { SampleViz1D } from \"./SampleViz1D\";\nimport \"./SampleViz.css\";\nimport {DisplayMode} from \"../App\"\nimport {ClusterTable} from \"./ClusterTable\";\nimport { GenomicBin } from \"../model/GenomicBin\";\nimport { Gene } from \"../model/Gene\";\nimport {DEFAULT_PLOIDY, DEFAULT_PURITY, DEFAULT_OFFSET, CN_STATES, cn_pair, START_CN, END_CN, UNCLUSTERED_ID, DELETED_ID, MAX_PLOIDY, MIN_PLOIDY, MAX_PURITY, MIN_PURITY, MIN_OFFSET, MAX_OFFSET} from \"../constants\";\nimport {useRef} from 'react'; \n\n\ninterface Props {\n    pointsize: number; \n    parentCallBack: any;\n    data: DataWarehouse;\n    chr: string;\n    cluster: string;\n    initialSelectedSample: string;\n    initialSelectedCluster?: string;\n    width?: number;\n    height?: number;\n    hoveredLocation?: ChromosomeInterval;\n    onLocationHovered: (location: ChromosomeInterval | null, record?: GenomicBin | null) => void;\n    invertAxis?: boolean;\n    customColor: string;\n    colors: string[];\n    onBrushedBinsUpdated: any;\n    brushedBins: GenomicBin[];\n    updatedBins: boolean;\n    dispMode: DisplayMode;\n    onRemovePlot: (sample: string) => void;\n    onAddSample: () => void;\n    plotId: number;\n    clusterTableData: any;\n    applyLog: boolean;\n    onClusterSelected: any;\n    showLinearPlot: boolean;\n    showScatterPlot: boolean;\n    onUndoClick: () => void;\n    sampleAmount: number;\n    syncScales: boolean;\n    handleZoom: (newScales: any) => void;\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n    showCentroids: boolean;\n    driverGenes: Gene[] | null;\n    showPurityPloidyInputs: boolean;\n    showTetraploid: boolean; \n    onChangeSample: (newSample: string, oldSample: string) => void;\n    samplesShown: Set<string>;\n}\n\ninterface State {\n    selectedSample: string;\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n    selectedCluster:string;\n    implicitRange: [number, number]  | null;\n    purity: number;\n    ploidy: number;\n    offset: number; \n    // showTetraploid: boolean; \n}\n\nexport class SampleViz extends React.Component<Props, State> {\n    private _clusters : string[];\n    constructor(props: Props) {\n        super(props);\n        this._clusters = this.initializeListOfClusters();\n        this.state = {\n            selectedSample: props.initialSelectedSample || props.data.getSampleList()[0],\n            scales: {xScale: null, yScale: null},\n            selectedCluster: (this._clusters.length > 0) ? this._clusters[0] : UNCLUSTERED_ID,\n            implicitRange: null,\n            purity: DEFAULT_PURITY,\n            ploidy: DEFAULT_PLOIDY,\n            offset: DEFAULT_OFFSET, \n            // showTetraploid: true, \n        }\n\n        this.handleSelectedSampleChanged = this.handleSelectedSampleChanged.bind(this);\n        this.handleSelectedSampleChange = this.handleSelectedSampleChange.bind(this);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.handleLinearPlotZoom = this.handleLinearPlotZoom.bind(this);\n        this.onUpdatePurity = this.onUpdatePurity.bind(this);\n        this.onUpdatePloidy = this.onUpdatePloidy.bind(this);\n        this.onUpdateOffset = this.onUpdateOffset.bind(this);\n    }\n\n    initializeListOfClusters() : string[] {\n        let clusterTableData = this.props.clusterTableData;\n\n        this._clusters = [];\n        for(const obj of clusterTableData) {\n            this._clusters.push(obj.key);\n        }\n\n        while(this._clusters.length > 0 \n            && (Number(this._clusters[0]) === Number(UNCLUSTERED_ID)\n            || Number(this._clusters[0]) === Number(DELETED_ID))) {\n            this._clusters.shift();\n        }\n        \n        return this._clusters;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.clusterTableData !== prevProps.clusterTableData) {\n            this.initializeListOfClusters();\n        } else if(this.props.applyLog !== prevProps.applyLog || this.props.showPurityPloidyInputs !== prevProps.showPurityPloidyInputs || (this.props.showTetraploid !== prevProps.showTetraploid)) {\n            let newScale = {xScale: this.state.scales.xScale, yScale: null}; // keep x zoom but reset y\n            this.setState({scales: newScale});\n        } \n    }\n\n    handleSelectedSampleChanged(selected : string) {\n        this.setState({selectedSample: selected});\n    }\n\n    handleSelectedSampleChange(event : any) {\n        this.setState({selectedSample: event.target.value});\n    }\n\n    handleZoom(newScales: any) {\n        // console.log(\"Handle zoom: \", newScales);\n        this.setState({scales: newScales});\n    }\n\n    handleLinearPlotZoom(genomicRange: [number, number] | null, yscale: [number, number] | null, key: boolean, reset?: boolean) {\n        if(reset) {\n            this.setState({implicitRange: null});\n            let newScale = {xScale: null, yScale: null};\n            this.setState({scales: newScale});\n        } else {\n            this.setState({implicitRange: genomicRange});\n            let newScale = (!key) ? {xScale: yscale, yScale: this.state.scales.yScale} : {xScale: this.state.scales.xScale, yScale: yscale};\n            this.setState({scales: newScale});\n        }\n    }\n\n    onUpdatePurity(purity: number) {\n        this.setState({purity: purity});\n    }\n\n    onUpdatePloidy(ploidy: number) {\n        this.props.data.setSamplePloidy(this.state.selectedSample, ploidy);\n        this.setState({ploidy: ploidy});\n        // this.setState({scales: {xScale: null, yScale: null}});\n    }\n\n    onUpdateOffset(offset: number) {\n        this.setState({offset: offset}); \n    }\n\n    getSelectedBins(syncScales : boolean, implicitRange : [number, number] | null, selectedSample:string, applyLog:boolean, showPurityPloidy: boolean, meanRD:number, data:DataWarehouse) {\n        let selectedRecords : GenomicBin[] = [];\n        let scales = (syncScales) ? this.props.scales : this.state.scales;\n        let dataKey : keyof Pick<GenomicBin, \"RD\" | \"logRD\" | \"fractional_cn\"> = (applyLog) ? \"logRD\" : ((showPurityPloidy) ? \"fractional_cn\" : \"RD\");\n\n        if (implicitRange !== null || scales.xScale !== null || scales.yScale !== null) {\n            let implicitStart = (implicitRange) ? implicitRange[0] : null;\n            let implicitEnd = (implicitRange) ? implicitRange[1] : null;\n            selectedRecords = data.getRecords(selectedSample, dataKey, implicitStart, implicitEnd, scales.xScale, scales.yScale, meanRD, this.state.ploidy);\n        } else { \n            selectedRecords = data.getRecords(selectedSample, dataKey, null, null, null, null, meanRD, this.state.ploidy);\n        }\n        return selectedRecords;\n    }\n\n    render() {\n        const {data, initialSelectedSample, applyLog, \n        showLinearPlot, showScatterPlot, dispMode, sampleAmount, syncScales, showPurityPloidyInputs, showTetraploid, samplesShown} = this.props;\n        const {implicitRange} = this.state;\n        \n        const selectedSample = this.state.selectedSample;\n        let rdRange = data.getRdRange(selectedSample, applyLog);\n        const sampleOptions = data.getSampleList().map(sampleName =>\n            <option key={sampleName} value={sampleName} disabled={!(sampleName === this.state.selectedSample) && samplesShown.has(sampleName)}>{sampleName} </option> //disabled={data.sampleIsDisplaying(sampleName)}\n        );\n\n        const meanRD = data.getMeanRD(selectedSample)\n\n        let selectedRecords : GenomicBin[] = this.getSelectedBins(syncScales, implicitRange, selectedSample, applyLog, showPurityPloidyInputs, meanRD, data);\n        let BAF_lines = data.getBAFLines(this.state.purity, this.state.selectedSample, this.state.offset); //, showTetraploid); // gc: add offset as a parameter\n\n        // Derived from formula: FRACTIONAL_COPY_NUMBER = purity * (TOTAL_CN) + 2*(1 - purity)\n        const max_cn = (this.state.purity) ? ((rdRange[1]) * this.state.ploidy / meanRD - 2*(1-this.state.purity)) / this.state.purity : 0;\n        \n        rdRange[1] += 0.5;\n        \n        const fractionalCNTicks = data.getFractionalCNTicks(this.state.purity, START_CN, END_CN, Math.ceil(max_cn), this.state.selectedSample);\n\n        if(showPurityPloidyInputs) {\n            rdRange = [rdRange[0]* this.state.ploidy /meanRD, rdRange[1] * this.state.ploidy /meanRD];\n        }\n\n        let clusterOptions = this._clusters.map((clusterName) =>\n            <option key={clusterName} value={clusterName} >{clusterName}</option>\n        );\n        \n        const scaleFactor = (showPurityPloidyInputs) ? this.state.ploidy / meanRD  :  1; // Sent into getCentroids to scale the centroids to the new yAxis for purity/ploidy\n\n        clusterOptions.unshift(<option key={UNCLUSTERED_ID} value={UNCLUSTERED_ID} >{UNCLUSTERED_ID}</option>);\n        clusterOptions.unshift(<option key={DELETED_ID} value={DELETED_ID} >{DELETED_ID}</option>);\n        let disableSelectOptions = (data.getBrushedBins().length === 0);\n        \n        return <div className=\"SampleViz-wrapper\">\n            \n            <div style={{verticalAlign: \"middle\"}}>\n            {(showLinearPlot || showScatterPlot) &&\n            <div className=\"SampleViz-select\" title=\"Selects a sample from the loaded data.\">\n                <span>Sample: </span>\n                <select value={selectedSample} onChange={(event: any) => {\n                    this.props.onChangeSample(event.target.value, this.state.selectedSample);\n                    this.handleSelectedSampleChange(event);\n                }}>\n                    {sampleOptions}\n                </select>\n                <button className=\"custom-button-add\" title=\"Add the next sequential sample in the dropdown menu.\" onClick={() => {\n                    this.props.onAddSample();\n                }} disabled={sampleAmount >= sampleOptions.length}> Add </button>\n                <button className=\"custom-button-remove\" title=\"Removes this sample.\" onClick={() => {\n                    this.props.onRemovePlot(this.state.selectedSample);\n                }} disabled={sampleAmount <= 1}> Remove </button>\n            </div>}\n            \n            {(showLinearPlot || showScatterPlot) &&\n            <div className=\"SampleViz-select\" title=\"Selects a cluster from the loaded data.\">\n                    <span >Cluster: </span>\n\n                    <select\n                    name=\"Select Cluster\" \n                    // title=\"Pick a cluster to assign your selected bins to!\"\n                    className=\"Sampleviz-cluster-select\"\n                    value={this.state.selectedCluster}\n                    disabled={disableSelectOptions}\n                    onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {this.setState({selectedCluster: event.target.value})}} >\n                    {clusterOptions}\n                    </select>\n                   \n                   <button className=\"custom-button\" title=\"Assigns your selected bins to the selected cluster.\" onClick={() => {\n                        this.props.parentCallBack(this.state.selectedCluster);\n                        this.props.onBrushedBinsUpdated([]);\n                    }}\n                    disabled={disableSelectOptions}>Assign</button>\n\n                    <button className=\"custom-button\" title=\"Assigns your selected bins to a new cluster.\" onClick={()=>{\n                        this.initializeListOfClusters();\n                        let clusters = this._clusters;\n                        clusters.sort((a: string, b:string) => (Number(a) - Number(b)))\n                        const highestCurrentCluster = (clusters.length > 0) ? Number(clusters[clusters.length-1]) : -1;\n                        let nextAvailable = highestCurrentCluster + 1;\n\n                        for(let i = 0; i < clusters.length; i++) {\n                            if(Number(clusters[i]) !== i){\n                                nextAvailable = i;\n                                break;\n                            }\n                        }\n                        \n                        this.props.parentCallBack(nextAvailable);\n                        this.props.onBrushedBinsUpdated([]);\n                    }}\n                    disabled={disableSelectOptions} >New</button>\n                    {/* <button className=\"custom-button\" title=\"Undo cluster assignment.\" onClick={this.props.onUndoClick}> Undo Cluster Assignment</button> */}\n                </div>}\n\n                {(showLinearPlot || showScatterPlot) && showPurityPloidyInputs\n                && <div className=\"Inputs\">\n                    <label>Ploidy:</label> <input value={this.state.ploidy} type=\"number\" id=\"Purity-Input\" name=\"volume\"\n                        step=\"0.01\" title=\"Set ploidy gridlines.\" onChange={event => {\n                            const newPloidy = Number(event.target.value);\n                            // if(newPloidy <= MAX_PLOIDY && newPloidy >= MIN_PLOIDY) {\n                                this.onUpdatePloidy(newPloidy);\n                            // }\n                        }}></input>\n                    {/* <div className=\"input-class\" title=\"Set purity gridlines. Max purity is 1.\">   */}\n                        <label className=\"input-label\">Purity:</label> <input type=\"number\" id=\"Purity-Input\" name=\"volume\"\n                            step=\"0.01\" value={this.state.purity} title=\"Set purity gridlines. Max purity is 1.\" onChange={event => {\n                                const newPurity = Number(event.target.value);\n                                if(newPurity <= MAX_PURITY) { // && newPurity >= MIN_PURITY) {\n                                    this.onUpdatePurity(newPurity);\n                                }\n                                \n                            }}></input>\n                    {/* </div> */}\n                    {/* <div className=\"input-class\" title=\"Set offset for first vertical gridline. Max offset is 1.\">   */}\n                        <label className=\"input-label\">BAF Balance: Offset for (x,x):</label> <input type=\"number\" id=\"Purity-Input\" name=\"volume\" \n                            step=\"0.01\" value={this.state.offset} title=\"Set offset for first vertical gridline. Max offset is 1.\" onChange={event => {\n                                const newoffset = Number(event.target.value);\n                                if(newoffset <= MAX_OFFSET) { // } && newoffset >= MIN_OFFSET) {\n                                    this.onUpdateOffset(newoffset);\n                                // }\n                            }}}></input>\n                    {/* </div> */}\n                </div>}\n                \n            </div>\n            <div className=\"SampleViz-plots\">\n                {showScatterPlot && <SampleViz2D \n                        {...this.props} \n                        data={selectedRecords}\n                        onSelectedSample={this.handleSelectedSampleChanged}\n                        selectedSample={selectedSample}\n                        initialSelectedSample={initialSelectedSample}\n                        onZoom={this.handleZoom}\n                        rdRange={rdRange}\n                        implicitRange={this.state.implicitRange}\n                        scales={(syncScales) ? this.props.scales : this.state.scales}\n                        centroidPts={data.getCentroidPoints(selectedSample, this.props.chr, scaleFactor)}\n                        purity={this.state.purity}\n                        ploidy={this.state.ploidy}\n                        offset={this.state.offset}\n                        meanRD={meanRD}\n                        fractionalCNTicks={fractionalCNTicks}\n                        showPurityPloidy={showPurityPloidyInputs}\n                        showTetraploid={showTetraploid}\n                        BAF_lines={BAF_lines}\n                        max_cn = {Math.ceil(max_cn)}\n                        />\n                }\n                {showLinearPlot && <SampleViz1D \n                    {...this.props}  \n                    data={selectedRecords} // selectedRecords\n                    onLinearPlotZoom={this.handleLinearPlotZoom}\n                    onZoom={this.handleZoom}\n                    yScale={this.state.scales.yScale}\n                    xScale={this.state.scales.xScale} \n                    selectedSample={this.state.selectedSample} \n                    initialSelectedSample={initialSelectedSample}\n                    rdRange={rdRange}\n                    displayMode={dispMode}\n                    width={600} \n                    implicitRange={this.state.implicitRange}\n                    purity={this.state.purity}\n                    ploidy={this.state.ploidy}\n                    meanRD={meanRD}\n                    fractionalCNTicks={fractionalCNTicks}\n                    showPurityPloidy={showPurityPloidyInputs}\n                    showTetraploid={showTetraploid}\n                    BAF_lines={BAF_lines}\n                />}\n\n            </div>\n            \n\n            {(showLinearPlot || showScatterPlot) &&\n            <div className={(showLinearPlot && showScatterPlot) ? \"SampleViz-clusters\" : \"\"}>\n                <ClusterTable \n                    data={data.brushedTableData()} \n                    onClusterRowsChange={() => {}} \n                    onClusterColorChange={() => {}}\n                    currentFilters={[\"-1\"]}\n                    colOneName={\"Cluster ID\"}\n                    colTwoName={\"Cluster (%)\"}\n                    colThreeName={\"Selection (%)\"}\n                    colFourName={\"Bin (%)\"}\n                    cols={\"\"}\n                    expandable={false}\n                    selectable={false}\n                    colors={this.props.colors}\n                ></ClusterTable>\n            </div>}\n            \n            \n        </div>\n    }\n}","export default \"data:image/gif;base64,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\"","import React from \"react\"\nimport DataTable from 'react-data-table-component';\nimport \"./ClusterTable.css\";\n\ninterface Props {\n    data : any;\n    onClusterRowsChange : any;\n    onClusterColorChange: any;\n    colName : string;\n    updatedClusterTable?: () => void;\n}\n\nexport class LogTable extends React.Component<Props> {\n    private readonly table_data : any;\n\n    constructor(props: Props) {\n        super(props);\n        this.table_data = props.data;\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return this.props[\"data\"] !== nextProps[\"data\"];\n    }\n\n    render() {\n        const {colName, data} = this.props;\n\n        const columns = [\n            {\n              name: colName,\n              selector: \"action\",\n              compact: true,\n              wrap: true,\n            }\n        ];\n        let newData = [];\n        for(let s of data) {\n            newData.push(s);\n        }\n        return <div>\n            <DataTable\n                columns={columns}\n                data={newData}\n                pagination={true}\n                paginationPerPage={5}\n                paginationComponentOptions={{rowsPerPageText: '', selectAllRowsItem: true}}\n                paginationRowsPerPageOptions={[5, 10, 15, 20]}\n                noContextMenu={true}\n                noHeader={true}\n            ></DataTable>\n        </div>\n\n\n    }\n\n}   ","import _ from \"lodash\";\nimport { OpenInterval } from \"./OpenInterval\";\nimport { ChromosomeInterval } from \"./ChromosomeInterval\";\n\n/**\n * Container to hold the name and length of a chromosome in bases.\n */\nexport interface Chromosome {\n    /** Name of the chromosome. */\n    readonly name: string;\n    /** Length of the chromosome, in bases. */\n    readonly length: number;\n}\n\n/**\n * A named set of chromosomes.  Because a single number system is easier to work with for visualization, instances\n * assign a unique base number to every location in the genome.  We term these unique base numbers as members of an \n * \"implicit\" coordinate system.  In contrast, locations specified by a set of base numbers in a specific chromosome,\n * for example \"chr1:0-1000\", are termed \"chromosome\" locations.\n * \n * You may assume that if bases are adjacent in chromosomes, they are also adjacent in the implicit coordinate system.\n * For instance, if the first base of chr10 maps to an implicit coordinate of 1000, and chr10 is five hundred bases\n * long, then it is safe to assume that chr10 maps to implicit bases 10000 to 10499.\n * \n * @author Silas Hsu\n */\nexport class Genome {\n    /** The name of this genome. */\n    private _name: string;\n\n    /** Ordered list of chromosomes in the genome. */\n    private _chromosomes: Chromosome[];\n\n    /**\n     * Mapping from chromosome name to the implicit coordinate of the chromosome's first base (see class description).\n     */\n    private _chrStarts: {[chrName: string]: number};\n\n    /** Total number of bases in the genome. */\n    private _length: number;\n\n    private nameToChr: {[chr: string]: Chromosome}\n\n    /**\n     * Makes a new instance, with name and list of chromosomes.  Chromosomes *must* have unique names.\n     * \n     * @param name - name of the genome\n     * @param chromosomes - list of chromosomes in the genome\n     * @throws {Error} if there are duplicate chromosome names\n     */\n    constructor(chromosomes: Chromosome[], name?: string) {\n        this._name = name ? name : \"\";\n        this._chromosomes = chromosomes;\n        this._chrStarts = {};\n        this._length = 0;\n\n        for (const chromosome of chromosomes) {\n            const chrName = chromosome.name;\n            if (this._chrStarts[chrName] !== undefined) {\n                throw new Error(`Duplicate chromosome name \"${chrName}\" in genome \"${name}\"`);\n            }\n            this._chrStarts[chrName] = this._length;\n            this._length += chromosome.length;\n        }\n        \n        this.nameToChr = {};\n        for (const chr of this._chromosomes) {\n            this.nameToChr[chr.name] = chr;\n        }\n    }\n\n    /**\n     * @return this genome's name\n     */\n    getName(): string {\n        return this._name;\n    }\n\n    /**\n     * Returns the list of Chromosome objects backing this instance.  Caution: modifying this list or objects in the\n     * list will modify this instance.\n     * \n     * @return the list of Chromosome objects backing this instance.\n     */\n    getChromosomeList(): Chromosome[] {\n        return this._chromosomes;\n    }\n\n    /**\n     * Gets a list of implicit coordinates of each chromosome's 0th base.  This list is in the same order as the list of\n     * chromosomes returned by `getChromosomeList()`.\n     * \n     * @return list of implicit coordinates of each chromosome's 0th base\n     */\n    getChromosomeStarts(): number[] {\n        return this._chromosomes.map(chr => this._chrStarts[chr.name]);\n    }\n\n    getChrStartMap() : any {\n        return this._chrStarts;\n    }\n\n    getChromosomeStarts2(chrs: Chromosome[]): number[] {\n        \n        // return chrStarts;\n        return chrs.map(chr => {\n           return this._chrStarts[chr.name];\n        });\n    }\n\n    /**\n     * Gets a length of a chromosome in base pairs, or the entire genome if the chromosome is unspecified.  Returns 0\n     * if the chromosome does not exist.\n     * \n     * @param chrName - the name of the chromosome to query, or `undefined` to query the entire genome's length\n     * @return length of the chromosome or genome.\n     */\n    getLength(chrName?: string | number): number {\n        if (!chrName) {\n            return this._length;\n        } else {\n            if ( !(chrName in this._chrStarts) ) {\n                return 0; // Chr not in this genome\n            }\n            \n            return this._chromosomes.find(chr => String(chr.name) === String(chrName))!.length;\n        }\n    }\n\n    getLength2(chrs: Chromosome[]) : number {\n        let length = 0;\n        for(const chr of chrs) {\n            length += chr.length;\n        }\n        return length\n    }\n\n    /**\n     * Converts a chromosome location into this instance's implicit coordinates.  See class description for more about\n     * implicit coordinates.\n     * \n     * @param location the genomic location to convert into implicit coordinates\n     * @return implicit base numbers in this instance that represent the genomic location\n     * @throws {Error} if the chromosome in the genomic location does not exist in this instance\n     */\n    getImplicitCoordinates(location: ChromosomeInterval): OpenInterval {\n        const {chr, start, end} = location;\n        if ( !(chr in this._chrStarts) ) {\n            throw new Error(`Chromosome \"${chr}\" not in this genome`);\n        }\n        const chrStart = this._chrStarts[chr];\n        return new OpenInterval(chrStart + start, chrStart + end);\n    }\n\n    /**\n     * Converts an implicit base number into a base number of a specific chromosome.  The result is returned in a\n     * ChromosomeInterval that has a length of 1.\n     * \n     * Input base numbers will be clamped to be a valid implicit coordinate before conversion takes place.  More\n     * formally, inputs will be clamped to be between [0, this.getLength() - 1].\n     * \n     * @param implicit the implicit base number to convert\n     * @return base number in a specific chromosome\n     */\n    getChromosomeLocation(implicit: number): ChromosomeInterval {\n        // Clamp the input\n        if (implicit < 0) {\n            implicit = 0;\n        } else if (implicit >= this.getLength()) {\n            implicit = this.getLength() - 1;\n        }\n\n        const sortedChrStarts = Object.values(this._chrStarts).sort((a, b) => a - b); // Sorted smallest to largest\n        const index = _.sortedLastIndex(sortedChrStarts, implicit) - 1;\n        const chrCoordinate = implicit - sortedChrStarts[index];\n        return new ChromosomeInterval(this._chromosomes[index].name, chrCoordinate, chrCoordinate + 1);\n    }\n\n    getChrs(chrs : string[]) {\n        let filteredChrs : Chromosome[] = [];\n        for(const chr of chrs) {\n            filteredChrs.push(this.nameToChr[chr]);\n        }\n        \n        return filteredChrs;\n    }\n}\n\nexport const hg38 = new Genome([\n    {name: \"chr1\", length: 248956422},\n    {name: \"chr2\", length: 242193529},\n    {name: \"chr3\", length: 198295559},\n    {name: \"chr4\", length: 190214555},\n    {name: \"chr5\", length: 181538259},\n    {name: \"chr6\", length: 170805979},\n    {name: \"chr7\", length: 159345973},\n    {name: \"chr8\", length: 145138636},\n    {name: \"chr9\", length: 138394717},\n    {name: \"chr10\", length: 133797422},\n    {name: \"chr11\", length: 135086622},\n    {name: \"chr12\", length: 133275309},\n    {name: \"chr13\", length: 114364328},\n    {name: \"chr14\", length: 107043718},\n    {name: \"chr15\", length: 101991189},\n    {name: \"chr16\", length: 90338345},\n    {name: \"chr17\", length: 83257441},\n    {name: \"chr18\", length: 80373285},\n    {name: \"chr19\", length: 58617616},\n    {name: \"chr20\", length: 64444167},\n    {name: \"chr21\", length: 46709983},\n    {name: \"chr22\", length: 50818468}\n], \"hg38\");\n","import React from \"react\"\nimport {GenomicBin} from \"../model/GenomicBin\";\nimport {toCSV} from \"../util\";\nimport spinner from \"../loading-small.gif\";\nimport {TEMPORARY_COLUMNS} from \"../constants\";\n\ninterface Props {\n    data : readonly GenomicBin[];\n    // logData: any[];\n    fileName: string;\n    onExport: () => void;\n}\n\ninterface State {\n    loading: boolean;\n}\n\nfunction convertToTsv(data: readonly GenomicBin[]): Promise<string> {\n    return new Promise((resolve, reject) => {\n        let keys = Object.keys(data[0]);\n        const headings = keys.filter(d => !TEMPORARY_COLUMNS.has(d));//keys.slice(0, keys.length-3);\n\n        // iterate over the data\n        const rows : string = toCSV(data, headings, \"\\t\", \" \");\n        let csvContent : any = rows;\n        resolve(csvContent);\n    })  \n}\n\nexport class CSV extends React.Component<Props, State> {\n    private csvLink: any;\n    constructor(props: Props) {\n        super(props);\n        this.csvLink = React.createRef();\n        this.state = {\n            loading: false\n        }\n        this.handleFileDownload = this.handleFileDownload.bind(this);\n    }\n\n    async handleFileDownload() {\n        this.setState({loading: true});\n\n        let csvContent = \"\";\n        try {\n            csvContent = await convertToTsv(this.props.data);\n        } catch(error) {\n            console.error(error);\n            return;\n        }\n        \n        var hiddenElement = document.createElement('a');  \n        hiddenElement.href = 'data:text/tab-separated-values,' + encodeURIComponent(csvContent);  \n        \n        // provide the name for the CSV file to be downloaded\n        // Assume that underscore is not in actual filename (only used to separate datetime)\n        const fileName = this.props.fileName;\n        let nameExt = fileName.split(\".\"); \n        let newFileName = \"\";\n        for(let i = 0; i < nameExt.length-1; i++) {\n            newFileName += nameExt[i];\n            if(i !== nameExt.length - 2) {\n                newFileName += \".\";\n            }\n        }\n\n        let removeDateTime = newFileName.split(\"_\");\n\n        const currentDate = new Date();\n        let month = String(currentDate.getMonth() + 1);\n        if(month.length < 2) {\n            month = \"0\" + month;\n        }\n\n        let day = String(currentDate.getDate());\n        if(day.length < 2) {\n            day = \"0\" + day;\n        }\n\n        let date = currentDate.getFullYear()+ month + day; \n        let hrs = String(currentDate.getHours() )\n        let min = String(currentDate.getMinutes());\n        let sec = String(currentDate.getSeconds());\n        if(hrs.length < 2) {\n            hrs = \"0\" + hrs;\n        }\n        if(min.length < 2) {\n            min = \"0\" + min;\n        }\n        if(sec.length < 2) {\n            sec = \"0\" + sec;\n        }\n\n        let time = hrs + min + sec;\n        \n        // let actions = [];\n        // for(let action of this.props.logData) {\n        //     actions.push(action.action);\n        // }\n        // let logFileContent = \"\";\n        // logFileContent = actions.join(\"\\n\");\n        // var hiddenElement2 = document.createElement('a');  \n        // hiddenElement2.href = 'data:text/plain,' + encodeURIComponent(logFileContent);\n        // hiddenElement2.download = removeDateTime[0] + \"-log_\" + date + \"_\" + time;  \n        // hiddenElement2.click();\n\n        hiddenElement.download = removeDateTime[0] + \"_\" + date + time + \".tsv\";\n        hiddenElement.click();\n\n        this.setState({loading: false})\n    }\n\n    render() {\n        let csvButton = <div>\n                \n            <button type=\"button\" onClick={() => {\n                this.props.onExport();\n                this.handleFileDownload()\n            }} style={{display: \"none\"}}>Export</button>\n            {this.state.loading && <div>Reading file... <img src={spinner} alt=\"Loading\" /></div>}\n        </div>\n        return csvButton;\n    }\n}\n","import React from \"react\";\nimport \"./Sidebar.css\";\nimport {ClusterTable} from \"./ClusterTable\";\nimport {DisplayMode, ProcessingStatus} from \"../App\";\nimport {CSV} from \"./CSVLink\";\nimport { GenomicBin} from \"../model/GenomicBin\";\nimport {FiArrowLeftCircle, FiArrowRightCircle, FiZoomIn, FiUpload, FiDownload} from \"react-icons/fi\";\nimport {IoHandRight} from \"react-icons/io5\"\nimport {BiEraser, BiMessageSquareAdd} from \"react-icons/bi\";\nimport { Slider } from '@mui/material';\nimport Box from \"@mui/material/Box\";\nimport { isPropertySignature } from \"typescript\";\n\ninterface Props {\n    // pointsize : number; \n    selectedChr : string;\n    selectedColor : string;\n    onChrSelected : any;\n    onColorSelected : any;\n    onAbsorbThresh_rdr : any; \n    onAbsorbThresh_baf : any; \n    onMergeThresh_rdr : any; \n    onMergeThresh_baf : any; \n    demoOptions: any;\n    onDemoSelected: any;\n    selectedDemo: string; \n    chrOptions: any;\n    onAddSample: any;\n    onAssignCluster: any;\n    tableData: any;\n    onClusterRowsChange: any;\n    onClusterColorChange: any;\n    currentClusterFilters: String[];\n    handleClusterAssignmentInput: any;\n    value: string;\n    setDisplayMode: any;\n    currentDisplayMode: DisplayMode;\n    colors: string[];\n    onSidebarChange: any;\n    data: readonly GenomicBin[];\n    logData: any[];\n    onFileChosen: any;\n    onDriverFileChosen: any;\n    chosenFile: string;\n    show: boolean;\n    onToggleLog: () => void;\n    onToggleScatter: () => void;\n    onToggleLinear: () => void;\n    onToggleShowCentroids: () => void;\n    showCentroids: boolean;\n    showScatter: boolean;\n    showLinear: boolean;\n    syncScales: boolean;\n    onToggleSync: () => void;\n    onTogglesilhouettes: () => void;\n    showSilhouettes: ProcessingStatus;\n    onToggleDirections: () => void;\n    onToggleShowCentroidTable: () => void;\n    onToggleShowAbsorbBins: () => void;\n    onTogglePreviousActionLog: () => void;\n    onUndoClick: () => void; \n    onClearClustering: () => void;\n    handleDemoFileInput: (applyClustering: boolean) => void;\n    handleDemoDrivers: () => void;\n    setProcessingStatus: (status: ProcessingStatus) => void;\n    onTogglePurityPloidy: () => void;\n    onShowTetraploid: () => void; \n    showTetraploid: boolean; \n    showPurityPloidy: boolean;\n    applyLog: boolean;\n    processingStatus: ProcessingStatus;\n    onExport: () => void;\n    handleslider: (event: any, val: number) => void; \n    // pointslider: (value: number) => void; \n}\n\nexport const SIDEBAR_WIDTH = \"320px\";\n\nfunction Sidebar(props: Props) {\n  const showSidebar = () => {\n    props.onSidebarChange(!props.show)\n  };\n\n  let chosenFile = props.chosenFile;\n  if(chosenFile.length > 35) {\n    chosenFile = chosenFile.substring(0, 34) + \"...\";\n  }\n\n  // let pointslider(value: number) {\n  //   this.setState({pointsize: value}); \n  //   // return `${value}°C`;\n  // }\n\n  return (\n\n    <div\n      className=\"sidebar\"\n      style={{\n        width: SIDEBAR_WIDTH,\n        left: props.show ? 0 : \"-\" + SIDEBAR_WIDTH\n      }}\n    >\n      <div className=\"closemenu\" onClick={showSidebar} title=\"Close/open the sidebar.\">\n          <div> </div>\n          {props.show ? (\n                <div className=\"arrow-container\"> \n                  <FiArrowLeftCircle/>\n                </div>\n              ) : (\n                <div className=\"arrow-container\">\n                  <FiArrowRightCircle/>\n                </div>\n              )\n          }\n      </div>\n\n      <div className=\"contents\">\n      <div className=\"row-contents\" > <h1>CNAViz v2.1</h1> </div>\n        <div className=\"title-bar\"></div>\n          <div className=\"row-contents\" > Chosen File: {chosenFile}</div>\n          <div className=\"row-contents\">\n              <label className=\"custom-file-upload\" title=\"Uploads a file.\">\n                <input type=\"file\" id=\"fileUpload\" onChange={\n                  (event: any) =>\n                  props.onFileChosen(event, true)\n                } />\n                Import <FiUpload/>\n              </label>\n              \n              <label className=\"custom-file-export\" title=\"Exports your clustering.\">\n                {/* <CSV data={props.data} logData={props.logData} fileName={props.chosenFile} onExport={props.onExport}></CSV> */}\n                <CSV data={props.data} fileName={props.chosenFile} onExport={props.onExport}></CSV>\n                Export <FiDownload/>\n              </label>\n              {/* <label className=\"demo\" title=\"Loads CNAViz with demo data.\">\n                <input type=\"button\" id=\"custom-button\" onClick={\n                    (event: any) => props.handleDemoFileInput(true)\n                }/>\n                Demo\n              </label> */}\n          </div>\n\n          <div className=\"row-contents\" >\n            <label className={props.processingStatus !== ProcessingStatus.done ? \"custom-file-upload-disabled\" : \"custom-file-upload2\"} title=\"Uploads your driver genes.\">\n              <input type=\"file\" id=\"fileUpload\"  disabled={props.processingStatus !== ProcessingStatus.done} onChange={\n                (event: any) => props.onDriverFileChosen(event, true)\n              }/>\n              Import Driver Genes\n            </label>\n\n            <label className={props.processingStatus !== ProcessingStatus.done ? \"custom-file-upload-disabled\" : \"custom-file-upload3\"} title=\"Uploads Cancer Gene Census driver genes.\">\n              <input type=\"button\" id=\"custom-button\" disabled={props.processingStatus !== ProcessingStatus.done} onClick={\n                  (event: any) => props.handleDemoDrivers()\n              }/>\n              CGC Drivers\n            </label> \n          </div>\n\n          <div className=\"row-contents\" >\n            <div className=\"Select-Chrom\" title=\"Select a chromosome to visualize in the linear and scatter plots.\">\n              <label htmlFor=\"Select Demo\" style={{margin: 10}}> Demo: </label>\n              <select\n                  name=\"Select Demo\" \n                  id=\"Select Demo\"\n                  value={props.selectedDemo}\n                  onChange={props.onDemoSelected} >\n                      {props.demoOptions}\n              </select>\n            </div>\n          </div>\n          \n          <div className= \"row-contents\" >\n            <div className=\"Select-Chrom\" title=\"Select a chromosome to visualize in the linear and scatter plots.\">\n              <label htmlFor=\"Select Chromosome\" style={{margin: 10}}> Chromosome: </label>\n              <select\n                  name=\"Select Chromosome\" \n                  id=\"Select Chromosome\"\n                  value={props.selectedChr}\n                  onChange={props.onChrSelected} >\n                      {props.chrOptions}\n              </select>\n            </div>\n          </div>\n\n          <div className= \"row-contents\" >\n            <div className=\"selection-color\" title=\"Pick a color to represent your selected bins.\">\n              <label htmlFor=\"Select Cluster Color\" style={{margin: 10}}> Selection Color: </label>\n              <input type=\"color\"\n                  name=\"Select Color\" \n                  id=\"Select Color\"\n                  value={props.selectedColor}\n                  onChange={props.onColorSelected} >\n              </input>\n            </div>\n          </div>\n\n          <div className=\"row-contents\">\n          {/* <label className=\"point-slider\" title=\"Changes the size of the points in the scatterplot and linear plot.\"> */}\n          <Box sx={{ width: 300 }}>  \n              Point Size:\n              <Slider\n                aria-label=\"Point Size\"\n                defaultValue={3}\n                onChangeCommitted={props.handleslider}\n                // getAriaValueText={this.pointslider}\n                valueLabelDisplay=\"auto\"\n                step={1}\n                marks={true}\n                min={1}\n                max={20}\n              />\n            {/* </label> */}\n            </Box>\n          </div>\n\n          <div className= \"row-contents\" >\n            <label className=\"logrdr\" title=\"Shows read-depth ratio (RDR) in log form.\">\n              <span className=\"App-CheckBox-explanation\">Log RDR: </span>\n              <input type=\"checkbox\" onClick={props.onToggleLog} disabled={props.showPurityPloidy}/>\n            </label>\n            <label className=\"centroids\" title=\"Shows centroids for each visualized cluster on the scatterplot.\"> \n              <span className=\"App-CheckBox-explanation\">Centroids: </span>\n              <input type=\"checkbox\" onClick={props.onToggleShowCentroids} checked={props.showCentroids} readOnly/>\n            </label>\n          </div>\n          <div className= \"row-contents\" >\n            <label className=\"scatterplot\" title=\"Shows the scatterplots.\">\n              <span className=\"App-CheckBox-explanation\">Scatterplots: </span>\n              <input type=\"checkbox\" onClick={props.onToggleScatter} checked={props.showScatter} readOnly/>\n            </label>\n            <label className=\"linearplot\" title=\"Shows the linear plots.\">\n              <span className=\"App-CheckBox-explanation\">Linear Plots: </span>\n              <input type=\"checkbox\" onClick={props.onToggleLinear} checked={props.showLinear} readOnly/>\n            </label>\n          </div>\n          <div className= \"row-contents\" >\n            <label className=\"purityploidy\" title=\"Shows lines for purity and ploidy on the scatterplots.\">\n              <span className=\"App-CheckBox-explanation\">Purity/Ploidy: </span>\n              <input type=\"checkbox\" onClick={props.onTogglePurityPloidy} checked={props.showPurityPloidy} readOnly/>\n            </label>\n            <label className=\"tetraploid\" title=\"Shows tetraploid gridlines for purity and ploidy.\">\n              <span className=\"App-CheckBox-explanation\">Tetraploid: </span>\n              <input type=\"checkbox\" onClick={props.onShowTetraploid} checked={props.showTetraploid}readOnly/>\n            </label>\n          </div>\n         \n         \n\n          {/* Analytics:  */}\n          <div className= \"row-contents\" >\n            <label className=\"analytics\" title=\"Shows pop-up displaying cluster analytics.\">\n              <input type=\"button\" id=\"custom-button\" onClick={() => { \n                props.onTogglesilhouettes();\n              }}/>\n              Analytics (s)\n            </label>\n            <label className=\"centroidtable\" title=\"Shows pop-up displaying centroid table.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onToggleShowCentroidTable}/>\n              Centroids (c)\n            </label>\n            {/* <label className=\"absorbbins\" title=\"Shows pop-up helping user automate reallocation of bins.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onToggleShowAbsorbBins}/>\n              Absorb Bins (a)\n            </label> */}\n            {/* <label className=\"directions_label\" title=\"Shows pop-up describing instructions and shortcuts.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onToggleDirections}/>\n              HELP (?)\n            </label> */}\n          </div>\n\n          <div className=\"row-contents\">\n            <label className=\"absorbbins\" title=\"Shows pop-up helping user automate reallocation of bins.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onToggleShowAbsorbBins}/>\n              Absorb Bins (a)\n            </label>\n          </div>\n\n          {/* Cluster Actions: */}\n          <div className=\"row-contents\" >\n            <label className=\"showlog\" title=\"Shows the cluster assignment log.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onTogglePreviousActionLog}/>\n              Log (l)\n            </label>\n            <label className=\"clearclustering\" title=\"Clears the clustering.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onClearClustering}/>\n              Clear Clustering\n            </label>\n            <label className=\"undocluster\" title=\"Undo the last cluster assignment action, including the ''Clear Clustering'' action.\">\n              <input type=\"button\" id=\"custom-button\" onClick={props.onUndoClick}/>\n              Undo Cluster\n            </label>\n          </div>\n\n      </div>\n        <div className=\"contents2\">\n          <ClusterTable \n                data={props.tableData} \n                onClusterRowsChange={props.onClusterRowsChange} \n                onClusterColorChange={props.onClusterColorChange}\n                currentFilters={props.currentClusterFilters}\n                colOneName={\"Cluster ID\"}\n                colTwoName={\"Bin (%)\"}\n                cols={\"\"}\n                expandable={true}\n                selectable={true}\n                colors={props.colors}\n            ></ClusterTable>\n          \n        </div>\n      \n    </div>\n  );\n}\n\nexport default Sidebar;\n","import React from \"react\"\nimport * as d3 from \"d3\";\nimport \"./BarPlot.css\";\nimport _ from \"lodash\";\n\nconst margins = {top: 0, right: 0, bottom: 0, left: 0};\nconst margin = { left: 0, top: 0, right: 0, bottom: 50};\nconst UNCLUSTERED_COLOR = \"#999999\";\n\nexport type clusterAvg = {\n    cluster: number,\n    avg: number\n};\n\ninterface Props {\n    data: clusterAvg[];\n    avgClusterSilhouette: number;\n    width: number;\n    height: number;\n    colors: string[];\n}\n\ninterface State {\n    showTooltip: boolean;\n    tooltipX: number;\n    tooltipY: number;\n}\n\nexport class SilhouetteBarPlot extends React.Component<Props, State> {\n\n    private _svg: SVGSVGElement | null;\n\n    constructor(props: Props) {\n        super(props);\n        this.state = {\n            showTooltip: false,\n            tooltipX: 0,\n            tooltipY: 0\n        }\n        this._svg = null;\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return true;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.propsDidChange(prevProps, [])) {\n            this.redraw();\n        }\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n\n    componentDidMount() { \n        this.redraw();\n    }\n\n    renderTooltipContent(contents: JSX.Element | null) {\n        const {showTooltip} = this.state;\n        if (!contents) {\n            return null;\n        }\n\n        if(!showTooltip) {\n            return null;\n        }\n\n        return <div\n            className=\"Scatterplot-tooltip\"\n            style={{\n                position: \"absolute\",\n                top: \"90%\",\n                left: \"1%\",\n                pointerEvents: \"none\"\n            }}\n        >\n            {contents}\n        </div>;\n    }\n    \n    renderTooltip() {\n        return this.renderTooltipContent(<React.Fragment><div>Note: The Silhouette coefficient ranges from -1 to 1 where the larger the number the more tightly grouped the cluster </div></React.Fragment>)\n    }\n\n    render() {\n        return (\n            <div id=\"chart-container\">\n                {this.renderTooltip()}\n            </div>\n        )\n    }\n\n    redraw() {\n        const {width, height, data, colors} = this.props;\n        let sortedData = _.sortBy(data, \"avg\");\n        const marginRatio = {\n            left: margins.left / width * 100 + \"%\",//getRatio('left'),\n            top: margins.top / width * 100 + \"%\",\n            right: margins.right / width * 100 + \"%\",\n            bottom: margins.bottom / width * 100 + \"%\"\n        }\n\n        var svg = d3.select('div#chart-container')\n            .append('svg')\n            .style(\n                'padding',\n                    marginRatio.top +\n                    ' ' +\n                    marginRatio.right +\n                    ' ' +\n                    marginRatio.bottom +\n                    ' ' +\n                    marginRatio.left +\n                    ' '\n            )\n        .attr('preserveAspectRatio', 'xMinYMin meet')\n        .attr(\n          'viewBox',\n          '0 0 ' +\n            (width + margin.left + margin.right) +\n            ' ' +\n            (height + margin.top + margin.bottom)\n        )\n       \n        // Add X axis\n        var x = d3.scaleLinear()\n        .domain([-1, 1])\n        .range([15, width-10]);\n\n        svg.append(\"text\")\n            .classed(\"scale\", true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"font-size\", 20)\n            .attr(\"x\", _.mean([15, width-10]))\n            .attr(\"y\", height + 40)\n            .text(\"Approximate Average Silhouette Coefficient\")\n            .on(\"mouseover\", () => {\n                this.setState({showTooltip: true});\n                this.setState({tooltipX: d3.event.offsetX, tooltipY: d3.event.offsetY});\n            })\n            .on(\"mouseleave\", () => {\n                this.setState({showTooltip: false});\n            });\n\n        svg.append(\"g\")\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .call(d3.axisBottom(x))\n            .selectAll(\"text\")\n                .attr(\"transform\", \"translate(-10,0)rotate(-45)\")\n                .style(\"text-anchor\", \"end\")\n\n        // Y axis\n        var y = d3.scaleBand()\n            .range([ 0, height])\n            .domain(sortedData.map(d => String(d.cluster)))\n            .padding(.1);\n        \n\n        //Bars\n        svg.selectAll(\"myRect\")\n            .data(sortedData)\n            .enter()\n            .append(\"rect\")\n            .attr(\"class\", function(d) { return \"bar bar--\" + (d.avg < 0 ? \"negative\" : \"positive\"); })\n            .attr(\"x\", function(d) { return x(Math.min(0, d.avg)) || 0; })\n            .attr(\"y\", function(d) { return y(String(d.cluster)) || 0; })\n            .attr(\"width\", function(d) { return Math.abs((x(d.avg) || 0) - (x(0) || 0)); })\n            .attr(\"height\", y.bandwidth())\n            .attr(\"fill\", row => (row.cluster === -1) ? UNCLUSTERED_COLOR : colors[row.cluster % colors.length]);\n            \n        svg.append(\"g\")\n            .call(d3.axisLeft(y).tickSize(0).tickPadding(6))\n            .attr(\"transform\", \"translate(\" + x(0) + \",0)\")\n    }\n }\n","import React from \"react\"\nimport * as d3 from \"d3\";\nimport \"./BarPlot.css\";\nimport _ from \"lodash\"\n\nconst margins = {top: 0, right: 0, bottom: 0, left: 0};\nconst margin = { left: 10, top: 0, right: 0, bottom: 50};\nconst UNCLUSTERED_COLOR = \"#999999\";\n\ninterface Props {\n    data: Map<number, number> | undefined;\n    width: number;\n    height: number;\n    colors: string[];\n    selectedCluster: number;\n}\n\n\nexport class ClusterDistancesBarPlot extends React.Component<Props> {\n\n    private _svg: SVGSVGElement | null;\n\n    constructor(props: Props) {\n        super(props);\n        this._svg = null;\n    }\n\n    shouldComponentUpdate(nextProps: Props) {\n        return true;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.propsDidChange(prevProps, [\"selectedCluster\"])) {\n            this.redraw();\n        }\n    }\n\n    propsDidChange(prevProps: Props, keys: (keyof Props)[]) {\n        return keys.some(key => this.props[key] !== prevProps[key]);\n    }\n\n    componentDidMount() { \n        this.redraw();\n    }\n\n    render() {\n        const {width, height} = this.props;\n        const marginRatio = {\n            left: margins.left / width * 100 + \"%\",\n            top: margins.top / width * 100 + \"%\",\n            right: margins.right / width * 100 + \"%\",\n            bottom: margins.bottom / width * 100 + \"%\"\n        }\n        return (\n            <div id=\"chart-container2\">\n                <svg \n                    ref={node => this._svg = node}\n                    style={{padding: marginRatio.top + ' ' + marginRatio.right + ' ' + marginRatio.bottom + ' ' + marginRatio.left + ' '}}\n                    preserveAspectRatio=\"xMinYMin meet\"\n                    viewBox={'0 0 ' + (width + margin.left + margin.right) + ' ' + (height + margin.top + margin.bottom)}\n                ></svg>\n            </div>\n        )\n    }\n\n    redraw() {\n        const {width, height, data, colors} = this.props;\n\n        if(!this._svg) {\n            return;\n        }\n\n        let dataObjectArr : any[] = [];\n        if(data !== undefined) {\n            dataObjectArr = Array.from(data, function (item) {\n                return { key: item[0], value: item[1] }\n            });          \n        }\n        \n        dataObjectArr = _.sortBy(dataObjectArr, \"value\");\n\n        var svg = d3.select(this._svg)\n        svg.selectAll(\".scales\").remove();\n\n        // Add X axis\n        let max = _.maxBy(dataObjectArr, \"value\");\n        \n        var x = d3.scaleLinear()\n        .domain([0,  (max) ? max.value : 1])\n        .range([30, width-10]);\n\n\n        svg.append(\"text\")\n            .classed(\"scales\", true)\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"font-size\", 20)\n            .attr(\"x\", _.mean([0, width]))\n            .attr(\"y\", height + 40)\n            .text(\"Approximate Average Euclidean Distance\");\n\n        svg.append(\"g\")\n            .classed(\"scales\", true)\n            .attr(\"transform\", \"translate(0,\" + height + \")\")\n            .call(d3.axisBottom(x))\n            .selectAll(\"text\")\n                .attr(\"transform\", \"translate(-10,0)rotate(-45)\")\n                .style(\"text-anchor\", \"end\");\n\n        // Y axis\n        var y = d3.scaleBand()\n            .range([ 0, height])\n            .domain(dataObjectArr.map(d => String(d.key)))\n            .padding(.1);\n        \n\n        // Bars\n        svg.selectAll(\".bar\").remove();\n        svg.selectAll(\"myRect\")\n            .classed(\"bars\", true)\n            .data(dataObjectArr)\n            .enter()\n            .append(\"rect\")\n            .attr(\"class\", function(d) { return \"bar bar--\" + (d.value < 0 ? \"negative\" : \"positive\"); })\n            .attr(\"x\", function(d) { return x(Math.min(0, d.value)) || 0; })\n            .attr(\"y\", function(d) { return y(String(d.key)) || 0; })\n            .attr(\"width\", function(d) { return Math.abs((x(d.value) || 0) - (x(0) || 0)); })\n            .attr(\"height\", y.bandwidth())\n            .attr(\"fill\", row => (row.key === -1) ? UNCLUSTERED_COLOR : colors[row.key % colors.length]);\n            \n        svg.append(\"g\")\n            .classed(\"scales\", true)\n            .call(d3.axisLeft(y).tickSize(0).tickPadding(6))\n            .attr(\"transform\", \"translate(\" + x.range()[0] + \",0)\")\n    }\n }\n","import React from \"react\";\nimport {clusterAvg} from \"./SilhouetteBarPlot\";\nimport { SilhouetteBarPlot } from \"./SilhouetteBarPlot\";\nimport {FiX} from \"react-icons/fi\";\nimport {ClusterDistancesBarPlot} from \"./ClusterDistancesBarPlot\";\nimport \"./AnalyticsTab.css\"\n\nconst UNCLUSTERED_ID = \"-1\";\nconst DELETED_ID = \"-2\";\n\ninterface Props {\n    silhouetteData: clusterAvg[],\n    avgClusterSilhouette: number,\n    clusterDistances: Map<number, Map<number, number>>,\n    clusterTableData: any,\n    colors: string[],\n    onToggleSilhoutteBarPlot: () => void;\n}\n\ninterface State {\n    selectedCluster: string;\n}\n\nexport class AnalyticsTab extends React.Component<Props, State> {\n    private _clusters : string[];\n    constructor(props: Props) {\n        super(props);\n        this._clusters = this.initializeListOfClusters(); \n        this.state = {\n            selectedCluster: this._clusters[0]\n        }\n         \n\n    }\n\n    initializeListOfClusters() : string[] {\n        let clusterTableData : any = this.props.clusterTableData;\n\n        this._clusters = [];\n        for(const obj of clusterTableData) {\n            this._clusters.push(obj.key);\n        }\n\n        while(this._clusters.length > 0 \n            && (Number(this._clusters[0]) === Number(UNCLUSTERED_ID)\n            || Number(this._clusters[0]) === Number(DELETED_ID))) {\n            this._clusters.shift();\n        }\n        \n        return this._clusters;\n    }\n\n    componentDidUpdate(prevProps: Props) {\n        if(this.props.clusterTableData !== prevProps.clusterTableData) {\n            this.initializeListOfClusters();\n        }\n    }\n    \n    render() {\n        const {silhouetteData, clusterDistances, colors} = this.props;\n        \n        let clusterOptions = this._clusters.map((clusterName) =>\n            <option key={clusterName} value={clusterName} >{clusterName}</option>\n        );\n\n        return <div className=\"Directions2\">\n            <h2 className=\"pop-up-window-header\"> Cluster Analytics </h2>\n            <div className=\"Exit-Popup\" onClick={this.props.onToggleSilhoutteBarPlot}> \n                <FiX/>\n            </div>\n            {/* <div className=\"Bar-Select\"> */}\n            <div className=\"scroll\">\n                <div className=\"ClusterDistances-Select\">\n                    <div className=\"Overall-Average\"> Average Cluster Silhouette Score: <b>{this.props.avgClusterSilhouette || 0}</b> </div>\n                    <label className=\"cluster-select\"> Cluster:\n                        <select\n                            name=\"Select Cluster\" \n                            title=\"Cluster\"\n                            value={this.state.selectedCluster}\n                            onChange={(event: React.ChangeEvent<HTMLSelectElement>) => {this.setState({selectedCluster: event.target.value})}} >\n                            {clusterOptions}\n                        </select>\n                    </label>\n                </div>\n\n                <div className=\"BarPlots\">\n                    <SilhouetteBarPlot\n                        width={700}\n                        height={700}\n                        data={silhouetteData}\n                        avgClusterSilhouette={this.props.avgClusterSilhouette}\n                        colors={colors}\n                    ></SilhouetteBarPlot> \n                    <ClusterDistancesBarPlot\n                        data={clusterDistances.get(Number(this.state.selectedCluster))}\n                        selectedCluster={Number(this.state.selectedCluster)}\n                        width={700}\n                        height={700}\n                        colors={colors}\n                    ></ClusterDistancesBarPlot> \n                </div>\n            </div>\n        </div>\n    }\n}","import \"./Toolbox.css\";\nimport React from \"react\";\nimport {FiArrowLeftCircle, FiArrowRightCircle, FiZoomIn, FiUpload, FiDownload} from \"react-icons/fi\";\nimport {IoHandRight} from \"react-icons/io5\"\nimport {BiEraser, BiMessageSquareAdd, BiMessageSquareMinus} from \"react-icons/bi\";\nimport _ from \"lodash\";\nimport { DisplayMode } from \"../App\";\n\ninterface Props {\n    currentDisplayMode: DisplayMode;\n    setDisplayMode: (mode: DisplayMode) => void;\n}\n\nexport class Toolbox extends React.Component<Props> {\n\n    render () {\n        return <div className=\"Toolbox\">\n            <div>Modes:</div>\n            <Tool \n                iconElement={<FiZoomIn color={this.props.currentDisplayMode === DisplayMode.boxzoom ? \"red\" : \"black\"} />}\n                label=\"Zoom\"\n\t\t        label2=\"(z)\"\n                onClick={() => this.props.setDisplayMode(DisplayMode.boxzoom)}\n            />\n            <Tool \n                iconElement={<IoHandRight color={this.props.currentDisplayMode === DisplayMode.zoom ? \"red\" : \"black\"} />}\n                label=\"Pan\"\n\t\t        label2=\"(p)\"\n                onClick={() => this.props.setDisplayMode(DisplayMode.zoom)}\n            />\n            <Tool \n                iconElement={<BiMessageSquareAdd color={this.props.currentDisplayMode === DisplayMode.select ? \"red\" : \"black\"} />}\n                label=\"Select\"\n                label2=\"(b)\"\n\t\tonClick={() => this.props.setDisplayMode(DisplayMode.select)}\n            />\n            <Tool \n                iconElement={<BiMessageSquareMinus color={this.props.currentDisplayMode === DisplayMode.erase ? \"red\" : \"black\"} />}\n                label=\"Deselect\"\n\t\tlabel2=\"(d)\"\n                onClick={() => this.props.setDisplayMode(DisplayMode.erase)}\n            />\n        </div>\n    }\n}  \n\n\ninterface ToolProps {\n    iconElement: JSX.Element,\n    label: string,\n    label2: string,\n    onClick: () => void\n}\n\nclass Tool extends React.Component<ToolProps> {\n    render() {\n        return <div className=\"Toolbox-Tool\" title={this.props.label} onClick={this.props.onClick}>\n            {this.props.iconElement}\n            <div className=\"Toolbox-Tool-label\">{this.props.label}</div>\n\t    <div className=\"Toolbox-Tool-label2\">{this.props.label2}</div>\n        </div>\n    }\n}\n","import React from \"react\"\nimport {GenomicBin} from \"../model/GenomicBin\";\nimport {toCSV} from \"../util\";\nimport spinner from \"../loading-small.gif\";\nimport {TEMPORARY_COLUMNS} from \"../constants\";\n\ninterface Props {\n    // data : readonly GenomicBin[];\n    logData: any[];\n    fileName: string;\n    onExport: () => void;\n}\n\ninterface State {\n    loading: boolean;\n}\n\nfunction convertToTsv(data: readonly GenomicBin[]): Promise<string> {\n    return new Promise((resolve, reject) => {\n        let keys = Object.keys(data[0]);\n        const headings = keys.filter(d => !TEMPORARY_COLUMNS.has(d));//keys.slice(0, keys.length-3);\n\n        // iterate over the data\n        const rows : string = toCSV(data, headings, \"\\t\", \" \");\n        let csvContent : any = rows;\n        resolve(csvContent);\n    })  \n}\n\nexport class Log extends React.Component<Props, State> {\n    private csvLink: any;\n    constructor(props: Props) {\n        super(props);\n        this.csvLink = React.createRef();\n        this.state = {\n            loading: false\n        }\n        this.handleFileDownload = this.handleFileDownload.bind(this);\n    }\n\n    async handleFileDownload() {\n        this.setState({loading: true});\n\n        // let csvContent = \"\";\n        // try {\n        //     csvContent = await convertToTsv(this.props.data);\n        // } catch(error) {\n        //     console.error(error);\n        //     return;\n        // }\n        // var hiddenElement = document.createElement('a');  \n        // hiddenElement.href = 'data:text/tab-separated-values,' + encodeURIComponent(csvContent);  \n        \n        // provide the name for the CSV file to be downloaded\n        // Assume that underscore is not in actual filename (only used to separate datetime)\n        const fileName = this.props.fileName;\n        let nameExt = fileName.split(\".\"); \n        let newFileName = \"\";\n        for(let i = 0; i < nameExt.length-1; i++) {\n            newFileName += nameExt[i];\n            if(i !== nameExt.length - 2) {\n                newFileName += \".\";\n            }\n        }\n\n        let removeDateTime = newFileName.split(\"_\");\n\n        const currentDate = new Date();\n        let month = String(currentDate.getMonth() + 1);\n        if(month.length < 2) {\n            month = \"0\" + month;\n        }\n\n        let day = String(currentDate.getDate());\n        if(day.length < 2) {\n            day = \"0\" + day;\n        }\n\n        let date = currentDate.getFullYear()+ month + day; \n        let hrs = String(currentDate.getHours() )\n        let min = String(currentDate.getMinutes());\n        let sec = String(currentDate.getSeconds());\n        if(hrs.length < 2) {\n            hrs = \"0\" + hrs;\n        }\n        if(min.length < 2) {\n            min = \"0\" + min;\n        }\n        if(sec.length < 2) {\n            sec = \"0\" + sec;\n        }\n\n        let time = hrs + min + sec;\n        \n        let actions = [];\n        for(let action of this.props.logData) {\n            actions.push(action.action);\n        }\n        let logFileContent = \"\";\n        logFileContent = actions.join(\"\\n\");\n        var hiddenElement2 = document.createElement('a');  \n        hiddenElement2.href = 'data:text/plain,' + encodeURIComponent(logFileContent);\n        hiddenElement2.download = removeDateTime[0] + \"-log_\" + date + \"_\" + time;  \n        hiddenElement2.click();\n\n        // hiddenElement.download = removeDateTime[0] + \"_\" + date + time + \".tsv\";\n        // hiddenElement.click();\n\n        this.setState({loading: false})\n    }\n\n    render() {\n        let csvButton = <div>\n                \n            <button type=\"button\" onClick={() => {\n                this.props.onExport();\n                this.handleFileDownload()\n            }} style={{display: \"none\"}}>Export</button>\n            {this.state.loading && <div>Downloading...<img src={spinner} alt=\"Loading\" /></div>}\n        </div>\n        return csvButton;\n    }\n}\n","import React from \"react\";\nimport parse from \"csv-parse\";\nimport _, { conformsTo, Dictionary, range, zip } from \"lodash\";\nimport { ChromosomeInterval } from \"./model/ChromosomeInterval\";\nimport { GenomicBin } from \"./model/GenomicBin\";\nimport {Chromosome} from \"./model/Genome\";\nimport { DataWarehouse} from \"./model/DataWarehouse\";\nimport {SampleViz} from \"./components/SampleViz\";\nimport spinner from \"./loading-small.gif\";\nimport \"./App.css\";\nimport {LogTable} from \"./components/LogTable\";\nimport * as d3 from \"d3\";\nimport {Genome} from \"./model/Genome\";\nimport Sidebar, {SIDEBAR_WIDTH} from \"./components/Sidebar\";\nimport \"./App.css\";\nimport { ClusterTable } from \"./components/ClusterTable\";\nimport { Gene } from \"./model/Gene\";\nimport {FiX} from \"react-icons/fi\";\nimport {AiOutlineQuestionCircle} from \"react-icons/ai\";\nimport {IconContext} from \"react-icons\"; \nimport {AnalyticsTab} from \"./components/AnalyticsTab\";\nimport {DEFAULT_PLOIDY, REQUIRED_COLS, REQUIRED_DRIVER_COLS} from \"./constants\";\nimport {Toolbox} from \"./components/Toolbox\";\nimport {Log} from \"./components/LogLink\";\nimport {FiDownload} from \"react-icons/fi\";\n// import { zip, unzip, unzipAssets, subscribe } from 'react-native-zip-archive';\n// import {JSZip} from \"jszip\"; \n// import React, { useState } from 'react';\n\n\nconst fs = require('fs');\nconst zlib = require('zlib');\n\nfunction getExtension(filename) {\n    const tokens = filename.split('.');\n    const ext = tokens.pop();\n    return ext; \n  }\n\n// const [files, setFiles] = useState<File[]>(undefined);\n// const [fileInfo, setFileInfo] = useState<IFileInfo>(undefined);\n\n    // const ext = getExtension(file.name);\n    // console.log(\"ext is \" + ext); \n    // if (ext === \"zip\") {\n    //     console.log(\"Is a .zip file.\"); \n    //     var zip = new JSZip(); \n    //     zip.loadAsync(file)\n    //         .then((zip) => {\n    //             const contents = [];\n    //         }, (e) => {\n    //         setFileInfo({\n    //             contents: [],\n    //             error: \"Error reading \" + file.name + \": \" + e.message\n    //         });\n    //         });\n    // }\n    // } else if (ext == \"gz\") {\n    //     console.log(\"Is a .gz file.\"); \n\n    //     const fileContents = fs.createReadStream(file.name);\n    //     const writeStream = fs.createWriteStream(file.name + \".txt\");\n    //     const unzip = zlib.createGunzip();\n\n    //     fileContents.pipe(unzip).pipe(writeStream);\n    // }\n\nfunction getFileContentsAsString(file: File) {\n    return new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.readAsText(file);\n        reader.onload = function() {\n            resolve(reader.result as string);\n        }\n        reader.onerror = reject;\n        reader.onabort = reject;\n    });\n}\n\n// Colors picked using the following tool: http://jnnnnn.github.io/category-colors-constrained.html\nconst CLUSTER_COLORS = [\n    \"#d3fe14\", \"#c9080a\", \"#fec7f8\", \"#0b7b3e\", \"#3957ff\", \"#0bf0e9\", \"#c203c8\", \"#fd9b39\", \n    \"#906407\", \"#98ba7f\", \"#fe6794\", \"#10b0ff\", \"#ac7bff\", \"#fee7c0\", \"#964c63\", \"#1da49c\", \"#0ad811\", \n    \"#bbd9fd\", \"#fe6cfe\", \"#d1a09c\", \"#78579e\", \"#81ffad\", \"#739400\", \"#ca6949\", \"#d9bf01\", \n    \"#646a58\", \"#d5097e\", \"#bb73a9\", \"#ccf6e9\", \"#9cb4b6\", \"#b6a7d4\", \"#9e8c62\", \"#6e83c8\", \"#01af64\", \n    \"#a71afd\", \"#cfe589\", \"#d4ccd1\", \"#fd4109\", \"#bf8f0e\", \"#2f786e\", \"#4ed1a5\", \"#d8bb7d\", \"#a54509\", \n    \"#6a9276\", \"#a4777a\", \"#fc12c9\", \"#606f15\", \"#3cc4d9\", \"#f31c4e\", \"#73616f\", \"#f097c6\", \"#fc8772\", \n    \"#92a6fe\", \"#875b44\", \"#699ab3\", \"#94bc19\", \"#7d5bf0\", \"#d24dfe\", \"#c85b74\", \"#68ff57\", \"#b62347\", \n    \"#994b91\", \"#646b8c\", \"#977ab4\", \"#d694fd\", \"#c4d5b5\", \"#fdc4bd\", \"#1cae05\", \"#7bd972\", \"#e9700a\",\n    \"#d08f5d\", \"#8bb9e1\", \"#fde945\", \"#a29d98\", \"#1682fb\", \"#9ad9e0\", \"#d6cafe\", \"#8d8328\", \"#b091a7\", \n    \"#647579\", \"#1f8d11\", \"#e7eafd\", \"#b9660b\", \"#a4a644\", \"#fec24c\", \"#b1168c\", \"#188cc1\", \"#7ab297\", \n    \"#c949a6\", \"#d48295\", \"#eb6dc2\", \"#d5b0cb\", \"#ff9ffb\", \"#fdb082\", \"#af4d44\", \"#a759c4\", \n    \"#a9e03a\", \"#0d906b\", \"#9ee3bd\", \"#5b8846\", \"#0d8995\", \"#f25c58\", \"#70ae4f\", \"#847f74\", \"#9094bb\", \n    \"#ffe2f1\", \"#a67149\", \"#936c8e\", \"#d04907\", \"#c3b8a6\", \"#cef8c4\", \"#7a9293\", \"#fda2ab\", \"#2ef6c5\", \n    \"#807242\", \"#cb94cc\", \"#b6bdd0\", \"#b5c75d\", \"#fde189\", \"#b7ff80\", \"#fa2d8e\", \"#839a5f\", \"#28c2b5\", \n    \"#e5e9e1\", \"#bc79d8\", \"#7ed8fe\", \"#9f20c3\", \"#4f7a5b\", \"#f511fd\", \"#09c959\", \"#bcd0ce\", \"#8685fd\", \n    \"#98fcff\", \"#afbff9\", \"#6d69b4\", \"#aaa87e\", \"#b59dfb\", \"#d9a742\", \"#ac5c86\", \n    \"#9468d5\", \"#a4a2b2\", \"#b1376e\", \"#d43f3d\", \"#05a9d1\", \"#c38375\", \"#24b58e\", \"#6eabaf\", \"#66bf7f\", \n    \"#92cbbb\", \"#ddb1ee\", \"#1be895\", \"#c7ecf9\", \"#a6baa6\", \"#8045cd\", \"#a9d796\", \"#ce62cb\", \n    \"#0e954d\", \"#a97d2f\", \"#fcb8d3\", \"#9bfee3\", \"#4e8d84\", \"#fc6d3f\", \"#7b9fd4\", \"#8c6165\", \"#72805e\", \n    \"#d53762\", \"#f00a1b\", \"#de5c97\", \"#8ea28b\", \"#fccd95\", \"#ba9c57\", \"#b79a82\", \"#7c5a82\", \"#7d7ca4\", \n    \"#958ad6\", \"#cd8126\", \"#bdb0b7\", \"#10e0f8\", \"#dccc69\", \"#d6de0f\", \"#616d3d\", \"#985a25\", \"#30c7fd\", \n    \"#0aeb65\", \"#e3cdb4\", \"#bd1bee\", \"#ad665d\", \"#d77070\", \"#8ea5b8\", \"#76655e\", \"#598100\", \n    \"#86757e\", \"#5ea068\", \"#a590b8\", \"#c1a707\", \"#85c0cd\", \"#e2cde9\", \"#dcd79c\", \"#d8a882\", \"#b256f9\",\n    \"#b13323\", \"#519b3b\", \"#dd80de\", \"#f1884b\", \"#74b2fe\", \"#a0acd2\", \"#d199b0\", \"#f68392\", \"#8ccaa0\",\n    \"#64d6cb\", \"#e0f86a\", \"#75671b\", \"#796e87\", \"#6d8075\", \"#9b8a8d\", \"#f04c71\", \"#61bd29\", \n    \"#bcc18f\", \"#fecd0f\", \"#1e7ac9\", \"#927261\", \"#dc27cf\", \"#979605\", \"#ec9c88\", \"#8c48a3\", \"#676769\", \n    \"#546e64\", \"#8f63a2\", \"#b35b2d\", \"#7b8ca2\", \"#b87188\", \"#4a9bda\", \"#eb7dab\", \"#f6a602\", \"#cab3fe\", \n    \"#ddb8bb\", \"#107959\", \"#885973\", \"#5e858e\", \"#b15bad\", \"#e107a7\", \"#2f9dad\", \"#4b9e83\", \"#b992dc\", \n    \"#6bb0cb\", \"#bdb363\", \"#ccd6e4\", \"#a3ee94\", \"#9ef718\", \"#fbe1d9\", \"#a428a5\", \"#93514c\", \"#487434\", \n    \"#e8f1b6\", \"#d00938\", \"#fb50e1\", \"#fa85e1\", \"#7cd40a\", \"#f1ade1\", \"#b1485d\", \"#7f76d6\", \"#d186b3\", \n    \"#90c25e\", \"#b8c813\", \"#a8c9de\", \"#7d30fe\", \"#815f2d\", \"#737f3b\", \"#c84486\", \"#946cfe\", \"#e55432\", \n    \"#a88674\", \"#c17a47\", \"#b98b91\", \"#fc4bb3\", \"#da7f5f\", \"#df920b\", \"#b7bbba\", \"#99e6d9\", \"#a36170\", \n    \"#c742d8\", \"#947f9d\", \"#a37d93\", \"#889072\", \"#9b924c\", \"#23b4bc\", \"#e6a25f\", \"#86df9c\", \"#a7da6c\", \n    \"#3fee03\", \"#eec9d8\", \"#aafdcb\", \"#7b9139\", \"#92979c\", \"#72788a\", \"#994cff\", \"#c85956\", \"#7baa1a\", \n    \"#de72fe\", \"#c7bad8\", \"#85ebfe\", \"#6e6089\", \"#9b4d31\", \"#297a1d\", \"#9052c0\", \"#698eba\", \n    \"#d46222\", \"#6da095\", \"#b483bb\", \"#04d183\", \"#9bcdfe\", \"#2ffe8c\", \"#9d4279\", \"#c909aa\", \"#826cae\"]\n\nexport let genome : Genome;\n\nfunction parseGenomicBins(data: string, applyLog: boolean, applyClustering: boolean): Promise<GenomicBin[]> {\n    return new Promise((resolve, reject) => {\n        parse(data, {\n            cast: true,\n            columns: true,\n            delimiter: \"\\t\",\n            skip_empty_lines: true,\n        }, (error, parsed) => {\n            if (error) {\n                reject(error);\n                return;\n            }\n\n\n            if(parsed.length > 0) {\n                for(const col of REQUIRED_COLS) {\n                    if(!(\"CLUSTER\" in parsed[0])) {\n                        console.log(\"Missing CLUSTER, but continuing with -1...\")\n                        applyClustering = false; \n                    } else if(!(col in parsed[0])) {\n                        throw new Error(\"COLUMN: \" + col + \" IS MISSING FROM INPUTTED DATA\");\n                    }\n                }\n           \n\n            \n                let end = 0;\n                let lastChr = parsed[0][\"#CHR\"];\n                let chrNameLength: Chromosome[] = [];\n\n                const rdMeans : { [sample: string] : number } = {};\n\n                let sampleGrouped = _.groupBy(parsed, \"SAMPLE\");\n                for(const sample in sampleGrouped) {\n                    rdMeans[sample] = _.meanBy(sampleGrouped[sample], (d:GenomicBin) => d.RD)\n                }\n\n                for (const bin of parsed) {\n                    if(!applyClustering || bin.CLUSTER === undefined) {\n                        bin.CLUSTER = -1;\n                    }\n\n                    bin.fractional_cn = bin.RD * DEFAULT_PLOIDY / rdMeans[bin.SAMPLE]\n                    bin.logRD = Math.log2(bin.RD);\n\n                    if(lastChr !==  bin[\"#CHR\"]) {\n                        chrNameLength.push({name: lastChr, length: (end - 0)})\n                        lastChr = bin[\"#CHR\"]\n                    }\n\n                    end = Number(bin.END);\n                    bin.reverseBAF = 0.5 - bin.BAF;\n                }\n\n                chrNameLength.push({name: lastChr, length: (end - 0)})\n\n                chrNameLength.sort((a: Chromosome, b : Chromosome) => {\n                    return String(a.name).localeCompare(b.name, undefined, {\n                        numeric: true,\n                        sensitivity: 'base'\n                    })\n                })\n\n                genome = new Genome(chrNameLength);\n\n                for (const bin of parsed) {\n                    bin.genomicPosition = genome.getImplicitCoordinates(new ChromosomeInterval(bin[\"#CHR\"], bin.START, bin.END)).start;\n                }\n            }\n            resolve(parsed);\n        });\n    })\n}\n\nfunction parseDriverGenes(data: string, validChromosomes: string[]): Promise<Gene[]> { \n    return new Promise((resolve, reject) => {\n        parse(data, {\n            cast: true,\n            columns: true,\n            delimiter: \"\\t\",\n            skip_empty_lines: true,\n            skip_lines_with_error: true\n        }, (error, parsed) => {\n            if (error) {\n                reject(error);\n                return;\n            }\n\n            if(parsed.length > 0) {\n                for(const col of REQUIRED_DRIVER_COLS) {\n                    if(!(col in parsed[0])) {\n                        throw new Error(\"COLUMN: \" + col + \" IS MISSING FROM INPUTTED DRIVER DATA\");\n                    }\n                }\n            }\n            \n            const genes = [];\n            const chrs = new Set<string>(validChromosomes);\n            for(const gene of parsed) {\n                \n                const components : string[] = gene[\"Genome Location\"].split(\":\");\n                \n                if(chrs.has(components[0])) {\n                    const start_end = components[1].split(\"-\");\n                    let interval : ChromosomeInterval = new ChromosomeInterval(components[0], Number(start_end[0]), Number(start_end[1]));\n                    gene.location = interval;\n                    genes.push(gene);\n                }\n            }\n\n            resolve(genes);\n        });\n    })\n}\n\n/**\n * Possible states of processing input data.\n */\nexport enum ProcessingStatus {\n    /** No data input (yet) */\n    none,\n\n    /** Reading data into memory */\n    readingFile,\n\n    /** Reformatting, aggregating, converting, or otherwise analyzing data. */\n    processing,\n\n    /** The results of data processing step are available. */\n    done,\n\n    /** An error happened during any step. */\n    error\n}\n\ninterface State {\n\n    processingStatus: ProcessingStatus; //  Current status of reading/processing input data\n   \n    indexedData: DataWarehouse; // Holds all the genomic bins\n\n    hoveredLocation: ChromosomeInterval | null; // Current genomic location that the user has selected.  Null if no such location.\n\n    pointsize: number; // size of the points on linear and scatter plots\n\n    selectedChr: string;  // Name of the chromosome selected for detailed viewing.  Empty string if no chromosome is selected.\n\n    selectedDemo: string; // Name of demo file selected.\n\n    selectedColor: string; // Name of selected cluster color. Should default to that blue.  gc\n\n    absorbThresh_rdr: Map<String, number>; // Threshold value to join unassigned bins into the existing. gc \n\n    absorbThresh_baf: Map<String, number>; // Threshold value to join unassigned bins into the existing. gc \n\n    mergeThresh_rdr: Map<String, number>; // Threshold value to join unassigned bins into the existing. gc \n\n    mergeThresh_baf: Map<String, number>; // Threshold value to join unassigned bins into the existing. gc \n\n    showTetraploid: boolean; // show gridlines for purity and plodiy corresponding to tetraploid? gc\n\n    selectedCluster: string; // cluster selected to be assigned to\n\n    invertAxis: boolean;\n\n    mergeValues: number[]; \n\n    sampleAmount: number;\n\n    color: string;\n\n    colors: string[];\n\n    assignCluster: boolean;\n\n    assigned: boolean;\n    \n    applyLog: boolean;\n\n    applyClustering: boolean;\n    \n    value: string;\n\n    updatedBins: boolean;\n\n    selectedSample: string;\n\n    displayMode: DisplayMode;\n\n    sidebar: boolean;\n\n    chosenFile: string;\n\n    showLinearPlot: boolean;\n\n    showScatterPlot: boolean;\n\n    showDirections: boolean;\n\n    showAbsorbBins: boolean; \n\n    showLog: boolean;\n\n    showCentroidTable: boolean;\n\n    showCentroids: boolean;\n\n    syncScales: boolean;\n\n    scales: {xScale: [number, number] | null, yScale: [number, number] | null};\n\n    driverGenes: Gene[] | null;\n\n    showSilhouettes: ProcessingStatus;\n\n    silhouettes: {\n        cluster: number;\n        avg: number;\n    }[];\n\n    showPurityPloidyInputs: boolean;\n    \n    samplesShown: string[];\n\n    samplesNotShown: string[];\n}\n\n\nexport enum DisplayMode {\n    zoom,\n    select,\n    boxzoom,\n    erase\n};\n\n/**\n * Top-level container.\n * \n * @author Silas Hsu\n */\n\nexport class App extends React.Component<{}, State> {\n    \n    constructor(props: {}) {\n        super(props);\n        this.state = {\n            processingStatus: ProcessingStatus.none,\n            indexedData: new DataWarehouse([]),\n            hoveredLocation: null,\n            selectedChr: DataWarehouse.ALL_CHRS_KEY,\n            selectedDemo: 'none', \n            pointsize: 3, // gc \n            selectedCluster: DataWarehouse.ALL_CLUSTERS_KEY,\n            selectedColor: \"black\", // gc: when set to red, this changes\n            // absorbThresh_rdr: 2.5, // gc\n            // absorbThresh_baf: 0.5, // gc\n            absorbThresh_rdr: new Map(), // gc\n            absorbThresh_baf: new Map(), // gc\n            mergeThresh_rdr: new Map(), // gc\n            mergeThresh_baf: new Map(), // gc\n            mergeValues: [], // gc\n            invertAxis: false,\n            sampleAmount: 1,\n            color: 'blue',\n            colors:  CLUSTER_COLORS,\n            assignCluster: false,\n            assigned: false,\n            applyLog: false,\n            applyClustering: false,\n            value: \"0\",\n            updatedBins: false,\n            selectedSample: \"\",\n            displayMode: DisplayMode.zoom,  \n            sidebar:  true,\n            chosenFile: \"\",\n            showLinearPlot: true,\n            showScatterPlot: true,\n            showDirections: false,\n            showAbsorbBins: false, \n            showLog: false,\n            showCentroidTable: false,\n            showCentroids: false,\n            syncScales: false,\n            scales: {xScale: null, yScale: null},\n            driverGenes: null,\n            showSilhouettes: ProcessingStatus.none,\n            silhouettes: [],\n            showPurityPloidyInputs: false,\n            showTetraploid: true, // gc\n            samplesShown: [],\n            samplesNotShown: []\n        };\n\n        this.handleFileChoosen = this.handleFileChoosen.bind(this);\n        this.handleDemoFileInput = this.handleDemoFileInput.bind(this);\n        this.handleDriverFileChosen = this.handleDriverFileChosen.bind(this);\n        this.handleDemoDrivers = this.handleDemoDrivers.bind(this);\n        this.handleChrSelected = this.handleChrSelected.bind(this);\n        this.handleDemoSelected = this.handleDemoSelected.bind(this);\n        this.handleslider = this.handleslider.bind(this); \n        // this.pointslider = this.pointslider.bind(this);\n        this.handleColorSelection = this.handleColorSelection.bind(this); // gc\n        this.handleAbsorbThresh_rdr = this.handleAbsorbThresh_rdr.bind(this); // gc\n        this.handleAbsorbThresh_baf = this.handleAbsorbThresh_baf.bind(this); // gc\n        // this.handleMergeThresh_rdr = this.handleMergeThresh_rdr.bind(this); // gc\n        // this.handleMergeThresh_baf = this.handleMergeThresh_baf.bind(this); // gc\n\n        this.handleClusterSelected = this.handleClusterSelected.bind(this);\n        this.handleLocationHovered = _.throttle(this.handleLocationHovered.bind(this), 50);\n        this.handleAxisInvert = this.handleAxisInvert.bind(this);\n        this.handleAddSampleClick = this.handleAddSampleClick.bind(this);\n        this.handleColorChange = this.handleColorChange.bind(this);\n        this.handleAssignCluster = this.handleAssignCluster.bind(this);\n        this.handleCallBack = this.handleCallBack.bind(this);\n        this.handleClusterAssignmentInput = this.handleClusterAssignmentInput.bind(this);\n        this.updateBrushedBins = this.updateBrushedBins.bind(this);\n        this.onClusterRowsChange = this.onClusterRowsChange.bind(this);\n        this.onClusterColorChange = this.onClusterColorChange.bind(this);\n        this.onClusterRowsToChange = this.onClusterRowsToChange.bind(this);\n        this.onClusterColorToChange = this.onClusterColorToChange.bind(this);\n        this.onClusterRowsFromChange = this.onClusterRowsFromChange.bind(this);\n        this.onClusterColorFromChange = this.onClusterColorFromChange.bind(this);\n        this.onSelectedSample = this.onSelectedSample.bind(this);\n        this.handleRemovePlot = this.handleRemovePlot.bind(this);\n        this.setDisplayMode = this.setDisplayMode.bind(this);\n        this.onSideBarChange = this.onSideBarChange.bind(this);\n        this.toggleLog = this.toggleLog.bind(this);\n        this.onToggleLinear = this.onToggleLinear.bind(this); \n        this.onToggleScatter = this.onToggleScatter.bind(this); \n        this.onToggleSync = this.onToggleSync.bind(this);\n        this.goBackToPreviousCluster = this.goBackToPreviousCluster.bind(this);\n        this.handleZoom = this.handleZoom.bind(this);\n        this.onToggleShowCentroids = this.onToggleShowCentroids.bind(this);\n        this.onToggleSilhoutteBarPlot = this.onToggleSilhoutteBarPlot.bind(this);\n        this.onToggleDirections = this.onToggleDirections.bind(this);\n        this.onToggleShowAbsorbBins = this.onToggleShowAbsorbBins.bind(this);\n        this.onToggleShowCentroidTable = this.onToggleShowCentroidTable.bind(this);\n        this.onTogglePreviousActionLog = this.onTogglePreviousActionLog.bind(this);\n        this.onClearClustering = this.onClearClustering.bind(this);\n        this.setProcessingStatus = this.setProcessingStatus.bind(this);\n        this.onTogglePurityPloidy = this.onTogglePurityPloidy.bind(this);\n        this.changeDisplayedSamples = this.changeDisplayedSamples.bind(this);\n        this.onExport = this.onExport.bind(this);\n\n        this.onShowTetraploid = this.onShowTetraploid.bind(this);\n\n\n        let self = this;\n        d3.select(\"body\").on(\"keypress\", function(){\n            if (d3.event.key === \"p\") {\n                self.setState({displayMode: DisplayMode.zoom});\n            } else if (d3.event.key === \"z\") {\n                self.setState({displayMode: DisplayMode.boxzoom}); \n            } else if (d3.event.key === \"b\") {\n                self.setState({displayMode: DisplayMode.select});\n            } else if(d3.event.key === \"d\") {\n                self.setState({displayMode: DisplayMode.erase});\n            } else if(d3.event.keyCode === 32) {\n                self.onSideBarChange(!self.state.sidebar);\n            } else if(d3.event.key === \"l\") {\n                self.setState({showLog: !self.state.showLog});\n            } else if(d3.event.key === \"c\") {\n                self.setState({showCentroidTable: !self.state.showCentroidTable});\n            } else if(d3.event.key === \"s\") {\n                self.onToggleSilhoutteBarPlot();\n            } else if(d3.event.key === \"a\") {\n                self.onToggleShowAbsorbBins(); \n            }\n            // else if(d3.event.key === \"t\") {\n            //     self.state.indexedData.calculateCopyNumbers();\n            // }\n        })\n\n        d3.select(\"body\").on(\"keydown\", function() {\n            if (self.state.displayMode === DisplayMode.zoom && d3.event.key === \"Shift\") {\n                self.setState({displayMode: DisplayMode.boxzoom})\n            } else if(d3.event.key === \"/\" || d3.event.key === \"?\") {\n                self.setState({showDirections: true})\n            } else if((self.state.displayMode === DisplayMode.zoom ||  self.state.displayMode === DisplayMode.erase) && (d3.event.key === \"Meta\" || d3.event.key === \"Control\")) {\n                self.setState({displayMode: DisplayMode.select})\n            } else if((self.state.displayMode === DisplayMode.zoom ||  self.state.displayMode === DisplayMode.select) && d3.event.key === \"Alt\") {\n                self.setState({displayMode: DisplayMode.erase})\n            } \n        })\n\n        d3.select(\"body\").on(\"keyup\", function(){\n            if (self.state.displayMode === DisplayMode.boxzoom && d3.event.key === \"Shift\") {\n                self.setState({displayMode: DisplayMode.zoom})\n            } else if(d3.event.key === \"/\" || d3.event.key === \"?\") {\n                self.setState({showDirections: false})\n            } else if(self.state.displayMode === DisplayMode.select && (d3.event.key === \"Meta\" || d3.event.key === \"Control\")) {\n                self.setState({displayMode: DisplayMode.zoom})\n            } else if(self.state.displayMode === DisplayMode.erase && d3.event.key === \"Alt\") {\n                self.setState({displayMode: DisplayMode.zoom})\n            }\n        });\n    }\n\n    async handleFileChoosen(event: React.ChangeEvent<HTMLInputElement>, applyClustering: boolean) {\n        const files = event.target.files;\n        if (!files || !files[0]) {\n            return;\n        }\n\n        this.setState({chosenFile: files[0].name})\n        this.setState({processingStatus: ProcessingStatus.readingFile});\n\n        let contents = \"\";\n        try {\n            contents = await getFileContentsAsString(files[0]);\n        } catch (error) {\n            console.error(error);\n            this.setState({processingStatus: ProcessingStatus.error});\n            return;\n        }\n\n        this.setState({processingStatus: ProcessingStatus.processing});\n        let indexedData = null;\n        try {\n            const parsed = await parseGenomicBins(contents, this.state.applyLog, applyClustering);\n            indexedData = new DataWarehouse(parsed);\n\n        } catch (error) {\n            console.error(error);\n            this.setState({processingStatus: ProcessingStatus.error});\n            return;\n        }\n\n        const samples = indexedData.getSampleList();\n        const initalDisplayedSamples = [];\n        const initalNotDisplayedSamples = [];\n        for(let i = 0; i < samples.length; i++) {\n            if(i < this.state.sampleAmount) {\n                initalDisplayedSamples.push(samples[i]);\n            } else {\n                initalNotDisplayedSamples.push(samples[i]);\n            }\n        }\n\n        this.setState({\n            indexedData: indexedData,\n            processingStatus: ProcessingStatus.done,\n            samplesShown: initalDisplayedSamples,\n            samplesNotShown: initalNotDisplayedSamples\n        });\n\n    }\n\n    // async handleDemoFileInput(applyClustering: boolean) {\n    handleDemoFileInput(applyClustering: boolean, c: string) {\n\n        // this.setState({chosenFile: \"a12.tsv\"})\n        // let c = this.state.selectedDemo; \n        this.setState({processingStatus: ProcessingStatus.readingFile});\n        \n        let url = \"\";\n        if (c === \"a12\") {\n            url = \"https://raw.githubusercontent.com/elkebir-group/cnaviz/master/data/demo/a12.tsv\";\n            this.setState({chosenFile: \"a12.tsv\"});\n        } else if (c === \"kim\") {\n            url = \"https://raw.githubusercontent.com/elkebir-group/cnaviz/master/data/demo/cnaviz_kim.tsv\";\n            this.setState({chosenFile: \"cnaviz_kim.tsv\"});\n        } else if (c === \"10x\") {\n            url = \"https://raw.githubusercontent.com/elkebir-group/cnaviz/master/data/demo/cnaviz_10x.tsv\";\n            this.setState({chosenFile: \"cnaviz_10x.tsv\"});\n        } else {\n            this.setState({samplesNotShown: [],\n                           processingStatus: ProcessingStatus.done\n            })\n            window.location.reload(false);\n            return; \n        }\n        fetch(url)\n            .then(r => r.text())\n            .then(text => {\n                this.setState({processingStatus: ProcessingStatus.processing});\n\n                parseGenomicBins(text, this.state.applyLog, applyClustering)\n                .then(parsed => {\n                    let indexedData = new DataWarehouse(parsed);\n                    const samples = indexedData.getSampleList();\n                    const initalDisplayedSamples = [];\n                    const initalNotDisplayedSamples = [];\n                    for(let i = 0; i < samples.length; i++) {\n                        if(i < this.state.sampleAmount) {\n                            initalDisplayedSamples.push(samples[i]);\n                        } else {\n                            initalNotDisplayedSamples.push(samples[i]);\n                        }\n                    }\n\n                    \n                    this.setState({\n                        indexedData: indexedData,\n                        processingStatus: ProcessingStatus.done,\n                        samplesShown: initalDisplayedSamples,\n                        samplesNotShown: initalNotDisplayedSamples\n                    });\n                })\n                .catch(error => {\n                    console.error(error);\n                    this.setState({processingStatus: ProcessingStatus.error});\n                    return;\n                }) \n            });\n    }\n\n    setProcessingStatus(status: ProcessingStatus) {\n        this.setState({processingStatus: status});\n    }\n\n    async handleDriverFileChosen(event: React.ChangeEvent<HTMLInputElement>) {\n        const files = event.target.files;\n        if (!files || !files[0]) {\n            return;\n        }\n\n        let contents = \"\";\n        try {\n            contents = await getFileContentsAsString(files[0]);\n        } catch (error) {\n            console.error(error);\n            return;\n        }\n        \n        let driverGenes = null;\n        try {\n            const parsed = await parseDriverGenes(contents, this.state.indexedData.getAllChromosomes());\n            driverGenes = parsed;\n            \n\n        } catch (error) {\n            console.error(error);\n            return;\n        }\n        this.setState({driverGenes: driverGenes});\n    }\n\n    async handleDemoDrivers() {\n        fetch(\"https://raw.githubusercontent.com/elkebir-group/cnaviz/master/data/demo/drivers.tsv\")\n        .then(r => r.text())\n        .then(text => {\n            parseDriverGenes(text, this.state.indexedData.getAllChromosomes())\n            .then(parsed => {\n               this.setState({driverGenes: parsed});\n            })\n            .catch(error => {\n                console.error(error);\n                return;\n            }) \n        });\n    }\n\n    // pointslider(value: number) {\n    //     this.setState({pointsize: value}); \n    //     // return `${value}°C`;\n    //   }\n\n    handleDemoSelected(event: React.ChangeEvent<HTMLSelectElement>) {\n        console.log(\"inside handleDemoSelected...\");\n        this.setState({selectedDemo: event.target.value});\n        // console.log(event.target.value, this.state.selectedDemo); \n        console.log(event.target.value);\n        this.handleDemoFileInput(true, event.target.value);\n        console.log(\"Done w handleDemoSelected.\");\n    }\n\n    handleChrSelected(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedChr: event.target.value});\n        this.state.indexedData.setChrFilter(event.target.value);\n    }\n\n    handleslider(event: any, val: number) {\n        console.log(\"Pointsize updated to\", val);\n        this.setState({pointsize: val});\n    }\n\n    handleColorSelection(event: React.ChangeEvent<HTMLSelectElement>) { // gc\n        this.setState({selectedColor: event.target.value});\n    }\n\n // const newthresh = Number(event.target.value);\n //                    if(newthresh <= 0 && newPloidy >= 5) {\n //                        this.onUpdateThresh(newthresh);\n //                    }\n    handleAbsorbThresh_rdr(sample: String, event: React.ChangeEvent<HTMLInputElement>) { // gc\n        console.log(\"inside handleMergeThresh_rdr() with\", sample, \"updated value to\", Number(event.target.value)); \n        this.state.absorbThresh_rdr.set(sample, Number(event.target.value)); \n    }\n    handleAbsorbThresh_baf(sample: String, event: React.ChangeEvent<HTMLInputElement>) { // gc\n        console.log(\"inside handleMergeThresh_baf() with\", sample, \"updated value to\", Number(event.target.value)); \n        this.state.absorbThresh_baf.set(sample, Number(event.target.value)); \n    }\n\n    // handleAbsorbThresh_rdr(event: React.ChangeEvent<HTMLInputElement>) { // gc\n    //     // if event.target.value <= 0 && event.target.value >= 5 ... \n    //     this.setState({absorbThresh_rdr: Number(event.target.value)}); \n    //     // this.state.indexedData.absorbUnassigned( Number(event.target.value) );\n    // }\n    // handleAbsorbThresh_baf(event: React.ChangeEvent<HTMLInputElement>) { // gc\n    //     // if event.target.value <= 0 && event.target.value >= 5 ... \n    //     this.setState({absorbThresh_baf: Number(event.target.value)}); \n    //     // this.state.indexedData.absorbUnassigned( Number(event.target.value) );\n    // }\n\n    handleMergeThresh_rdr(sample: String, event: React.ChangeEvent<HTMLInputElement>) { // gc\n        console.log(\"inside handleMergeThresh_rdr() with\", sample, \"updated value to\", Number(event.target.value)); \n        this.state.mergeThresh_rdr.set(sample, Number(event.target.value)); \n    }\n    handleMergeThresh_baf(sample: String, event: React.ChangeEvent<HTMLInputElement>) { // gc\n        console.log(\"inside handleMergeThresh_baf() with\", sample, \"updated value to\", Number(event.target.value)); \n        this.state.mergeThresh_baf.set(sample, Number(event.target.value)); \n    }\n\n    handleClusterSelected(event: React.ChangeEvent<HTMLSelectElement>) {\n        this.setState({selectedCluster: event.target.value});\n        this.state.indexedData.setClusterFilters([event.target.value]);\n    }\n\n    handleLocationHovered(location: ChromosomeInterval | null) {\n        if (!location) {\n            this.setState({hoveredLocation: null});\n            return;\n        }\n\n        this.setState({hoveredLocation: location});\n    }\n\n    handleClusterAssignmentInput(event: any) {\n        this.setState({value: event.target.value})\n    }\n\n    handleCallBack(selectedCluster: string | number) {\n        this.state.indexedData.updateCluster(Number(selectedCluster));\n        this.setState({assignCluster: false});\n        this.state.indexedData.setChrFilter(this.state.selectedChr);\n    }\n\n    updateBrushedBins(brushedBins: GenomicBin[]) {\n        this.state.indexedData.setbrushedBins(brushedBins);\n        this.setState({updatedBins: true});\n    }\n\n    handleAxisInvert() {\n        this.setState({invertAxis: !this.state.invertAxis});\n    }\n\n    changeDisplayedSamples(newSample: string, oldSample: string) {\n        const samplesShown = this.state.samplesShown;\n        for(let i = 0; i < samplesShown.length; i++) {\n            if(samplesShown[i] === oldSample) {\n                samplesShown[i] = newSample;\n            }\n        }\n\n        let samplesNotShown = this.state.samplesNotShown;\n        samplesNotShown = samplesNotShown.filter(sample => sample !== newSample)\n        samplesNotShown.push(oldSample);\n\n        this.setState({sampleAmount: this.state.sampleAmount, samplesShown: samplesShown, samplesNotShown: samplesNotShown});\n    }\n\n    handleAddSampleClick() {\n        const newSample = this.state.samplesNotShown[0]; //this.state.indexedData.getSampleList()[this.state.sampleAmount];\n\n        const samplesShown = this.state.samplesShown;\n        samplesShown.push(newSample);\n\n        let samplesNotShown = this.state.samplesNotShown;\n        samplesNotShown = samplesNotShown.filter(sample => sample !== newSample)\n\n        this.setState({sampleAmount: this.state.sampleAmount + 1, samplesShown: samplesShown, samplesNotShown: samplesNotShown});\n    }\n\n    handleRemovePlot(sample: string) {\n        const samplesShown = this.state.samplesShown;\n        const removedSample = samplesShown[samplesShown.length-1];\n        samplesShown.pop();\n\n        const samplesNotShown = this.state.samplesNotShown;\n        samplesNotShown.push(removedSample);\n\n        this.setState({sampleAmount: this.state.sampleAmount - 1});\n    }\n\n    handleAssignCluster() {\n        this.setState({assignCluster: !this.state.assignCluster});\n    }\n\n    handleColorChange(color : any) {\n        this.setState({color: color.hex});\n    }\n\n    getStatusCaption() {\n        switch (this.state.processingStatus) {\n            case ProcessingStatus.readingFile:\n                return <div>Reading file... <img src={spinner} alt=\"Loading\" /></div>;\n            case ProcessingStatus.processing:\n                return <div>Processing data... <img src={spinner} alt=\"Loading\" /></div>;\n            case ProcessingStatus.error:\n                return \"ERROR\";\n            case ProcessingStatus.none:\n            case ProcessingStatus.done:\n            default:\n                return \"\";\n        }\n    }\n\n    onToggleDirections() {\n        this.setState({showDirections: !this.state.showDirections});\n    }\n\n    absorbBinsAll() {\n        console.log(\"Absorb bins!\");\n        console.log(\"Merge bins...\"); \n        this.setState({processingStatus: ProcessingStatus.processing});\n\n        // let s = this.state.indexedData.getSampleList()[0]; \n        this.setState({processingStatus: ProcessingStatus.processing});\n        let from_set = this.state.indexedData.getFilteredFromClusters();\n        let to_set = this.state.indexedData.getFilteredToClusters(); \n\n        let ythresh = this.state.absorbThresh_rdr;\n        let xthresh = this.state.absorbThresh_baf; \n        console.log(ythresh); \n        console.log(xthresh); \n\n        let is_continue : boolean = true; \n        for (let i = 0; i < this.state.indexedData.getSampleList().length; i++) {\n            let sample = this.state.indexedData.getSampleList()[i]; \n            let x_thr = xthresh.get(sample); \n            let y_thr = ythresh.get(sample);\n            console.log(\"sample\", sample, \"x_thr\", x_thr, \"y_thr\", y_thr); \n            if (Number(x_thr) <= 0 || x_thr === undefined || Number(y_thr) <= 0 || y_thr === undefined) {\n                is_continue = false; \n            }\n        }\n\n        if (is_continue) {\n            // iterate through all bins in from\n            let new_reassign_group = this.state.indexedData.absorbBins(from_set, to_set, xthresh, ythresh);\n\n            let mergestring = '';\n            // build mergestring\n            for (var clusterName of Array.from(new_reassign_group.keys())) {\n                mergestring += String(clusterName); // + \": [\"; \n                // console.log(clusterName, \"assigning bins:\", Array.from(new_reassign_group.get(clusterName))); \n                // for (var toCluster of Array.from(new_reassign_group.get(clusterName))) {\n                //     mergestring += String(toCluster) + \",\";\n                // }\n                mergestring += \",\"; \n            }\n\n            let confirmAction = window.confirm(\"Are you sure you want to absorb bins into: \" + mergestring);\n            if (confirmAction) {\n                alert(\"Bins absorbed.\");\n                this.state.indexedData.assignAbsorb(new_reassign_group); \n            } else {\n                alert(\"Action canceled, bins not absorbed.\");\n            }  \n        } else {\n            window.confirm(\"Please use a threshold > 0 for all samples.\");\n        }  \n        this.setState({processingStatus: ProcessingStatus.done});\n    }\n\n    // mergeBins(sample: String) {\n    //     console.log(\"Merge bins...\"); \n    //     this.setState({processingStatus: ProcessingStatus.processing});\n    //     for(let i = 0; i < this.state.indexedData.getSampleList().length; i++) {\n    //         let s = this.state.indexedData.getSampleList()[i]; \n    //         if (sample === s) {\n    //             let ythresh = this.state.mergeThresh_rdr.get(sample); // mergeThresh_rdr\n    //             let xthresh = this.state.mergeThresh_baf.get(sample);\n    //             let new_reassign_group = this.state.indexedData.mergeBins(s, Number(xthresh), Number(ythresh));\n    //             // window.prompt('Are you sure?', 'Yes');\n    //             let mergestring = '\\n';\n    //             // build mergestring\n    //             for (var clusterName of Array.from(new_reassign_group.keys())) {\n    //                 mergestring += String(clusterName) + \": [\"; \n    //                 for (var toCluster of Array.from(new_reassign_group.get(clusterName))) {\n    //                     mergestring += String(toCluster) + \",\";\n    //                 }\n    //                 mergestring += \"]\\n\"; \n    //             }\n\n    //             let confirmAction = window.confirm(\"Are you sure you want to merge the following bins?\" + mergestring);\n    //             if (confirmAction) {\n    //                 alert(\"Clusters merged.\");\n    //                 this.state.indexedData.assignMerge(s, new_reassign_group); \n    //             } else {\n    //                 alert(\"Action canceled, clusters not merged.\");\n    //             }\n    //         }\n    //     }\n    //     this.setState({processingStatus: ProcessingStatus.done});\n    // }\n\n    mergeBinsAll() {\n        console.log(\"Merge bins...\"); \n        this.setState({processingStatus: ProcessingStatus.processing});\n\n        let s = this.state.indexedData.getSampleList()[0]; \n        let new_reassign_group = this.state.indexedData.mergeBinsAll(s, this.state.mergeThresh_rdr, this.state.mergeThresh_baf);\n        let mergestring = '\\n';\n        // build mergestring\n        for (var clusterName of Array.from(new_reassign_group.keys())) {\n            mergestring += String(clusterName) + \": [\"; \n            for (var toCluster of Array.from(new_reassign_group.get(clusterName))) {\n                mergestring += String(toCluster) + \",\";\n            }\n            mergestring += \"]\\n\"; \n        }\n\n        let confirmAction = window.confirm(\"Are you sure you want to merge the following bins?\" + mergestring);\n        if (confirmAction) {\n            alert(\"Clusters merged.\");\n            this.state.indexedData.assignMerge(s, new_reassign_group); \n        } else {\n            alert(\"Action canceled, clusters not merged.\");\n        }            \n        this.setState({processingStatus: ProcessingStatus.done});\n    }\n\n    onToggleShowAbsorbBins() {\n        this.setState({showAbsorbBins: !this.state.showAbsorbBins});\n    }\n\n    onShowTetraploid() {\n        console.log(\"ShowTetraplod\", this.state.showTetraploid); \n        this.setState({showTetraploid: !this.state.showTetraploid});\n    }\n\n    toggleLog() {\n        if(this.state.applyLog) {\n            this.state.indexedData.setDataKeyType(\"RD\");\n            this.state.indexedData.recalculateCentroids(\"RD\");\n        } else {\n            this.state.indexedData.setDataKeyType(\"logRD\");\n            this.state.indexedData.recalculateCentroids(\"logRD\");\n        }\n        \n        this.setState({\n            applyLog: !this.state.applyLog\n        });\n        this.state.indexedData.setShouldRecalculatesilhouettes(true);\n        \n    }\n    toggleClustering() {\n        this.setState({\n            applyClustering: !this.state.applyClustering\n        });\n    }\n\n    onClusterRowsChange(state: any) {\n        this.state.indexedData.setClusterFilters( state.selectedRows.map((d:any)  => String(d.key)));\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    onClusterRowsToChange(state: any) { // gc\n        this.state.indexedData.setClusterFiltersTo( state.selectedRows.map((d:any)  => String(d.key)));\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    onClusterRowsFromChange(state: any) {// gc\n        this.state.indexedData.setClusterFiltersFrom( state.selectedRows.map((d:any)  => String(d.key)));\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    onClusterColorChange(colors: string[]) {\n        let newColors = [];\n        for(const col of colors) {\n            newColors.push(col);\n        }\n        this.setState({colors: newColors});\n    }\n\n    onClusterColorToChange(colors: string[]) {// gc\n        let newColors = [];\n        for(const col of colors) {\n            newColors.push(col);\n        }\n        this.setState({colors: newColors});\n    }\n    onClusterColorFromChange(colors: string[]) {// gc\n        let newColors = [];\n        for(const col of colors) {\n            newColors.push(col);\n        }\n        this.setState({colors: newColors});\n    }\n\n    onSelectedSample(selectedSample : any) {\n        this.setState({selectedSample : selectedSample});\n    }\n\n    setDisplayMode(mode: DisplayMode) {\n        this.setState({displayMode: mode});\n    }\n\n    onSideBarChange(sidebar: boolean) {\n        this.setState({sidebar: sidebar});\n    }\n\n    onToggleScatter(){\n        this.setState({showScatterPlot: !this.state.showScatterPlot});\n    }\n\n    onToggleLinear(){\n        this.setState({showLinearPlot: !this.state.showLinearPlot});\n    }\n\n    onToggleSync() {\n        this.setState({syncScales: !this.state.syncScales});\n    }\n\n    onToggleShowCentroids() {\n        this.setState({showCentroids: !this.state.showCentroids});\n    }\n\n    onToggleShowCentroidTable() {\n        this.setState({showCentroidTable: !this.state.showCentroidTable});\n    }\n\n    goBackToPreviousCluster() {\n        this.state.indexedData.undoClusterUpdate();\n        this.setState({indexedData: this.state.indexedData});\n    }\n\n    handleZoom(newScales: any) {\n        this.setState({scales: newScales});\n    }\n\n    onTogglePreviousActionLog() {\n        this.setState({showLog: !this.state.showLog});\n    }\n\n    onClearClustering() {\n        let confirmAction = window.confirm(\"Are you sure you want to clear all clusters?\");\n        if (confirmAction) {\n            alert(\"All clusters cleared.\");\n            this.state.indexedData.clearClustering();\n            this.setState({indexedData: this.state.indexedData});\n        } else {\n            alert(\"Action canceled, clustering not cleared.\");\n        }  \n    }\n\n    onExport() {\n        // only export copy number columns (6) if purity ploidy is toggled on.\n        if (this.state.showPurityPloidyInputs) {\n            this.state.indexedData.calculateCopyNumbers();\n            this.state.indexedData.calculateCopyNumbers_Cluster();\n        } else {\n            console.log(\"onExport does nothing because purity ploidy is not toggled on.\")\n        }\n    }\n\n    onTogglePurityPloidy() {\n        if(this.state.showPurityPloidyInputs) {\n            this.state.indexedData.setDataKeyType(\"RD\");\n        } else {\n            this.state.indexedData.setDataKeyType(\"fractional_cn\");\n        }\n\n        this.setState({showPurityPloidyInputs: !this.state.showPurityPloidyInputs});\n    }\n\n    async onToggleSilhoutteBarPlot() {\n        this.setState({processingStatus: ProcessingStatus.processing});\n        if(this.state.showSilhouettes === ProcessingStatus.none) {\n            this.setState({showSilhouettes: ProcessingStatus.processing});\n            this.state.indexedData.recalculatesilhouettes(this.state.applyLog)\n            .then((data: {cluster: number, avg: number}[] | undefined) => {\n                if(data !== undefined) {\n                    this.setState({silhouettes: data});\n                    this.setState({showSilhouettes: ProcessingStatus.done});\n                }\n            });\n        } else {\n            this.setState({showSilhouettes: ProcessingStatus.none});\n        }\n    \n        this.setState({processingStatus: ProcessingStatus.done});\n    }\n\n    render() {\n        const {indexedData, selectedChr, selectedDemo, selectedCluster, showTetraploid, hoveredLocation, invertAxis, selectedColor, assignCluster, updatedBins, value, sampleAmount} = this.state; // gc \n        const samplesDisplayed = this.state.samplesShown;\n        const samplesShown = new Set<string>(samplesDisplayed);\n        const brushedBins = indexedData.getBrushedBins();\n        const allData = indexedData.getAllRecords();\n        let mainUI = null;\n        let visualizeMerge = null; \n        let visualizeAbsorb = null; \n        // let mergeItems = null; \n        let clusterTableData = indexedData.getClusterTableInfo();\n        let clusterTableData2 = indexedData.getClusterTableInfo2();\n        let clusterTableData3 = indexedData.getClusterTableInfo3();\n        let demoOptions : JSX.Element[] = [<option key={'None'} value={'None'}>None</option>, <option key={'A12'} value={'a12'}>A12 (bulk)</option>, <option key={'Kim'} value={'kim'}>Kim et al. (SCS)</option>, <option key={'10x'} value={'10x'}>10X (SCS)</option>];\n        let chrOptions : JSX.Element[] = [<option key={DataWarehouse.ALL_CHRS_KEY} value={DataWarehouse.ALL_CHRS_KEY}>ALL</option>]; \n        let actions = indexedData.getActions();\n\n        if (this.state.processingStatus === ProcessingStatus.done && !indexedData.isEmpty()) {\n            const clusterTableData = indexedData.getClusterTableInfo();\n            const clusterTableData2 = indexedData.getClusterTableInfo2();\n            const clusterTableData3 = indexedData.getClusterTableInfo3();\n\n            // console.log(\"Before passing to scatterplotProps\", this.state.pointsize);\n            const scatterplotProps = {\n                pointsize: this.state.pointsize, \n                data: indexedData,\n                hoveredLocation: hoveredLocation || undefined,\n                onLocationHovered: this.handleLocationHovered,\n                invertAxis,\n                chr: selectedChr,\n                cluster: selectedCluster,\n                customColor: selectedColor, // gc?\n                showTetraploid: showTetraploid, // gc\n                colors: this.state.colors,\n                assignCluster,\n                onBrushedBinsUpdated: this.updateBrushedBins,\n                parentCallBack: this.handleCallBack,\n                brushedBins: brushedBins,\n                updatedBins: updatedBins,\n                onSelectedSample: this.onSelectedSample,\n                selectedSample: this.state.selectedSample,\n                dispMode: this.state.displayMode,\n                onRemovePlot: this.handleRemovePlot,\n                onAddSample: this.handleAddSampleClick,\n                onChangeSample: this.changeDisplayedSamples,\n                clusterTableData: clusterTableData,\n                clusterTableData2: clusterTableData,\n                clusterTableData3: clusterTableData,\n                applyLog: this.state.applyLog,\n                onClusterSelected: this.handleClusterSelected,\n                onUndoClick: this.goBackToPreviousCluster,\n                showCentroids: this.state.showCentroids,\n                driverGenes: this.state.driverGenes,\n            };\n\n            const sortAlphaNum = (a : string, b:string) => a.localeCompare(b, 'en', { numeric: true })\n\n            chrOptions = indexedData.getAllChromosomes().sort(sortAlphaNum).map(chr => <option key={chr} value={chr}>{chr}</option>);\n            chrOptions.push(<option key={DataWarehouse.ALL_CHRS_KEY} value={DataWarehouse.ALL_CHRS_KEY}>ALL</option>);\n\n            const clusterOptions = indexedData.getAllClusters().map((clusterName : string) =>\n                <option key={clusterName} value={clusterName}>{clusterName}</option>\n            );\n            clusterOptions.push(<option key={DataWarehouse.ALL_CLUSTERS_KEY} value={DataWarehouse.ALL_CLUSTERS_KEY}>ALL</option>);\n\n            demoOptions = [<option key={'None'} value={'None'}>None</option>,\n                           <option key={'A12'} value={'a12'}>A12 (bulk)</option>, \n                           <option key={'Kim'} value={'kim'}>Kim et al. (SCS)</option>,\n                           <option key={'10x'} value={'10x'}>10X (SCS)</option>];\n\n            mainUI = (\n                <div id=\"grid-container\">\n                    <div className=\"sampleviz-wrapper-row\">\n                            {_.times(sampleAmount, i => samplesDisplayed.length > i \n                            && <SampleViz \n                                    key={i}\n                                    {...scatterplotProps} \n                                    initialSelectedSample={samplesDisplayed[i]} \n                                    plotId={i}\n                                    showLinearPlot={this.state.showLinearPlot}\n                                    showScatterPlot={this.state.showScatterPlot}\n                                    sampleAmount={sampleAmount}\n                                    syncScales={this.state.syncScales}\n                                    handleZoom={this.handleZoom}\n                                    scales={this.state.scales}\n                                    showPurityPloidyInputs = {this.state.showPurityPloidyInputs}\n                                    samplesShown={samplesShown}\n                                ></SampleViz>)}\n                            \n                    </div>\n                </div>);\n\n            visualizeMerge = <div className=\"grid-container\">\n                <div className=\"App-row-contents\">\n                    Set Merge Thresholds:\n                </div>\n                <div className=\"App-row-contents\">\n                    {this.state.indexedData.getSampleList().map( sample => \n                        <div id=\"grid-container\" key={sample}> \n                                <div className=\"scroll\">\n                                    {sample}\n                                    <div className=\"App-row-contents\">\n                                    BAF: \n                                        <input type=\"number\"\n                                            name=\"Merge Threshold\" \n                                            key={sample}\n                                            id=\"Merge-Thresh-BAF\"\n                                            min={0}\n                                            max={10}\n                                            step=\"0.001\"\n                                            placeholder={(this.state.mergeThresh_baf.has(sample)) ? String(this.state.mergeThresh_baf.get(sample)) : \"0\"}\n                                            onChange={this.handleMergeThresh_baf.bind(this, sample)}> \n                                        </input>\n                                    </div>\n                                    <div className=\"App-row-contents\">\n                                    RDR: \n                                        <input type=\"number\"\n                                            name=\"Merge Threshold\" \n                                            key={sample}\n                                            id=\"Merge-Thresh-RDR\"\n                                            min={0}\n                                            max={10}\n                                            step=\"0.001\"\n                                            placeholder={(this.state.mergeThresh_rdr.has(sample)) ? String(this.state.mergeThresh_rdr.get(sample)) : \"0\"}\n                                            onChange={this.handleMergeThresh_rdr.bind(this, sample)}> \n                                        </input>\n                                    </div>      \n                                </div>\n                        </div> \n                    )} \n                </div>\n                <div className=\"App-row-contents\">\n                    <label className=\"directions_label\" title=\"Merges any clusters with a pairwise centroid distance below the BAF and RDR thresholds in all samples.\">\n                        <input type=\"button\" id=\"custom-button\" disabled={this.state.processingStatus !== ProcessingStatus.done} onClick={this.mergeBinsAll.bind(this)}/>\n                        Merge Clusters \n                    </label> \n                </div>\n            </div>\n\n            visualizeAbsorb = <div className=\"grid-container\">\n                <div className=\"App-row-contents\">\n                    Set Absorb Thresholds:\n                </div>\n                <div className=\"App-row-contents\">\n                    {this.state.indexedData.getSampleList().map( sample => \n                        <div id=\"grid-container\" key={sample}> \n                                <div className=\"scroll\">\n                                    {sample}\n                                    <div className=\"App-row-contents\">\n                                    BAF: \n                                        <input type=\"number\"\n                                            name=\"Merge Threshold\" \n                                            key={sample}\n                                            id=\"Merge-Thresh-BAF\"\n                                            min={0}\n                                            max={10}\n                                            step=\"0.001\"\n                                            placeholder={(this.state.mergeThresh_baf.has(sample)) ? String(this.state.mergeThresh_baf.get(sample)) : \"0\"}\n                                            onChange={this.handleAbsorbThresh_baf.bind(this, sample)}> \n                                        </input>\n                                    </div>\n                                    <div className=\"App-row-contents\">\n                                    RDR: \n                                        <input type=\"number\"\n                                            name=\"Merge Threshold\" \n                                            key={sample}\n                                            id=\"Merge-Thresh-RDR\"\n                                            min={0}\n                                            max={10}\n                                            step=\"0.001\"\n                                            placeholder={(this.state.mergeThresh_rdr.has(sample)) ? String(this.state.mergeThresh_rdr.get(sample)) : \"0\"}\n                                            onChange={this.handleAbsorbThresh_rdr.bind(this, sample)}> \n                                        </input>\n                                    </div>                                    \n                                </div>\n                        </div> \n                    )} \n                </div>\n                <div className=\"App-row-contents\">\n                    <label className=\"directions_label\" title=\"Absorbs bins in the 'From' list of clusters to the closest 'To' list of centroids. Reassignment only happens if distance is below the BAF and RDR thresholds in every sample.\">\n                        <input type=\"button\" id=\"custom-button\" disabled={this.state.processingStatus !== ProcessingStatus.done} onClick={this.absorbBinsAll.bind(this)}/>\n                        Absorb Bins\n                    </label>\n                </div>\n            </div>\n            \n        }\n        // onChange={function(e : any){console.log(\"onChange BAF\", sample, e); this.handleMergeThresh_rdr(sample, e)}}> \n        const status = this.getStatusCaption();\n\n        return <div className=\"container-fluid\">\n            <div>\n                <Sidebar \n                    // pointsize={this.state.pointsize}\n                    // pointslider={this.pointslider}                    \n                    handleslider={this.handleslider}\n                    selectedChr={selectedChr} \n                    selectedDemo={selectedDemo}\n                    onDemoSelected={this.handleDemoSelected}\n                    demoOptions={demoOptions}\n                    onChrSelected={this.handleChrSelected} \n                    chrOptions={chrOptions}\n                    selectedColor={selectedColor} \n                    onColorSelected={this.handleColorSelection} \n                    onAbsorbThresh_rdr={this.handleAbsorbThresh_rdr}\n                    onAbsorbThresh_baf={this.handleAbsorbThresh_baf}\n                    onMergeThresh_rdr={this.handleMergeThresh_rdr}\n                    onMergeThresh_baf={this.handleMergeThresh_baf}\n\n                    onAddSample={this.handleAddSampleClick}\n                    onAssignCluster={this.handleAssignCluster}\n                    tableData={clusterTableData}\n                    onClusterRowsChange={this.onClusterRowsChange}\n                    onClusterColorChange={this.onClusterColorChange}\n                    currentClusterFilters={indexedData.getFilteredClusters()}\n                    handleClusterAssignmentInput={this.handleClusterAssignmentInput}\n                    value={value}\n                    setDisplayMode={this.setDisplayMode}\n                    currentDisplayMode={this.state.displayMode} \n                    colors={this.state.colors}\n                    onSidebarChange={this.onSideBarChange}\n                    data={allData}\n                    onFileChosen={this.handleFileChoosen}\n                    chosenFile={this.state.chosenFile}\n                    show={this.state.sidebar}\n                    onToggleLog = {this.toggleLog}\n                    onToggleLinear={this.onToggleLinear}\n                    onToggleScatter={this.onToggleScatter}\n                    showScatter={this.state.showScatterPlot}\n                    showLinear={this.state.showLinearPlot}\n                    onToggleSync={this.onToggleSync}\n                    syncScales={this.state.syncScales}\n                    logData = {actions}\n                    onToggleShowCentroids= {this.onToggleShowCentroids}\n                    onToggleShowAbsorbBins={this.onToggleShowAbsorbBins}\n                    onShowTetraploid={this.onShowTetraploid}\n                    showTetraploid={this.state.showTetraploid}\n                    showCentroids= {this.state.showCentroids}\n                    onDriverFileChosen={this.handleDriverFileChosen}\n                    onTogglesilhouettes={this.onToggleSilhoutteBarPlot}\n                    showSilhouettes={this.state.showSilhouettes}\n                    onToggleDirections = {this.onToggleDirections}\n                    onToggleShowCentroidTable={this.onToggleShowCentroidTable}\n                    onTogglePreviousActionLog={this.onTogglePreviousActionLog}\n                    onClearClustering={this.onClearClustering}\n                    // handleDemoFileInput={this.handleDemoFileInput}\n                    handleDemoDrivers={this.handleDemoDrivers}\n                    setProcessingStatus={this.setProcessingStatus}\n                    onTogglePurityPloidy={this.onTogglePurityPloidy}\n                    showPurityPloidy={this.state.showPurityPloidyInputs}\n                    applyLog={this.state.applyLog}\n                    processingStatus={this.state.processingStatus}\n                    onExport={this.onExport}\n                    onUndoClick={this.goBackToPreviousCluster}\n                />\n            </div>\n\n            {/* position: relative is important for this div because the child toolbar is position: fixed*/}\n            {/* position: fixed positions self relative to the nearest relatively positioned ancestor. */}\n            <div\n                style={{\n                    position: \"relative\",\n                    marginLeft: this.state.sidebar ? SIDEBAR_WIDTH : 0,\n                    overflowX: \"hidden\"\n                }}\n            >\n                <div\n                    className=\"toolbar\"\n                    style={{width: this.state.sidebar ?\n                        `calc(100% - ${SIDEBAR_WIDTH} - 20px)` : \"calc(100% - 20px)\"\n                    }}\n                >\n                    <Toolbox\n                        currentDisplayMode={this.state.displayMode}\n                        setDisplayMode={this.setDisplayMode}\n                    ></Toolbox>\n                    <div className=\"help-box\" title=\"Show a modal describing instructions and shortcuts.\">\n                        <label style={{cursor: \"pointer\"}}>\n                        <input style={{cursor: \"pointer\"}} type=\"button\" id=\"custom-button\" onClick={this.onToggleDirections}/>\n                            <IconContext.Provider value={{className: \"shared-class\", size: \"40\"}}>\n                                <AiOutlineQuestionCircle/>\n                            </IconContext.Provider>\n                        </label>\n                    </div>\n                </div>\n                {status && <div className=\"App-status-pane\">{status}</div>}\n                {mainUI}\n\n                {this.state.showDirections && <div className=\"black_overlay\" onClick={this.onToggleDirections}></div> }\n                {this.state.showDirections && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\">Directions</h2>\n                        <div className=\"Exit-Popup\" onClick={this.onToggleDirections}> \n                            <FiX/>\n                        </div>\n                        <h5> Selection </h5>\n                        <li> Hold down \"Command/Control\" in Zoom mode to temporarily enter add-to-selection mode. </li>\n                        <li> Hold down \"Alt\" in Zoom mode to temporarily enter remove-from-selection mode. </li>\n                        <li> To completely clear your selection, click anywhere in the plot while in add-to-selection or remove-from-selection modes. </li>\n                        <li> To stay in add-to-select mode, you can press (b) or click the + icon in the toolbar.</li>\n                        <li> To stay in remove-from-select mode, you can press (d) or click the - icon in the toolbar. </li>\n                        <h5> Zoom/Pan Mode </h5>\n                        <li> To enter zoom mode, click the magnifying glass icon in the toolbar, or press (z) on the keyboard. If you hold down shift, it will act as a bounding box zoom. </li>\n                        {/* <li> In zoom mode, if you hold down shift, it will act as a bounding box zoom </li> */}\n                        <li> To pan, click the grab icon in the toolbar, click and drag on the scatter plot or axes, or press (p) on the keyboard. </li>\n                        <h5> Other Key Modifiers: </h5>\n                        <li> Click \"l\" to toggle a log of previous actions. </li>\n                        <li> Click space to toggle the sidebar. </li>\n                        <li> Hold down \"?\" or \"/\" button to open direction panel. </li>\n                        <li> Click \"c\" to toggle a table of the centroids of each cluster for each sample. </li>\n                        <li> Click \"s\" to toggle a bar plot displaying approximate average silhoutte scores for each cluster. </li>\n                    </div> }\n\n                {this.state.showAbsorbBins && <div className=\"black_overlay\" onClick={this.onToggleShowAbsorbBins}></div> }\n                {this.state.showAbsorbBins && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\">Absorb Bins</h2>\n                        <div className=\"Exit-Popup\" onClick={this.onToggleShowAbsorbBins}> \n                            <FiX/>\n                        </div>\n                        <div className=\"App-row-contents\">\n                            From: \n                            <ClusterTable \n                                data={clusterTableData2} \n                                onClusterRowsChange={this.onClusterRowsFromChange}  // gc: need to edit this\n                                onClusterColorChange={this.onClusterColorChange} // gc: need to edit this\n                                currentFilters={indexedData.getFilteredFromClusters()}\n                                colOneName={\"Cluster ID\"}\n                                colTwoName={\"Bin (%)\"}\n                                cols={\"\"}\n                                expandable={true}\n                                selectable={true}\n                                colors={CLUSTER_COLORS}\n                            ></ClusterTable>\n                            To: \n                            <ClusterTable \n                                data={clusterTableData3} \n                                onClusterRowsChange={this.onClusterRowsToChange} // gc: need to edit this\n                                onClusterColorChange={this.onClusterColorChange} // gc: need to edit this\n                                currentFilters={indexedData.getFilteredToClusters()}\n                                colOneName={\"Cluster ID\"}\n                                colTwoName={\"Bin (%)\"}\n                                cols={\"\"}\n                                expandable={true}\n                                selectable={true}\n                                colors={CLUSTER_COLORS}\n                            ></ClusterTable>\n                        </div>\n                        {visualizeAbsorb}\n                    </div> }\n\n                {this.state.showLog && <div className=\"black_overlay\" onClick={()=> this.setState({showLog: !this.state.showLog})}></div> }\n                {this.state.showLog && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\"> Previous Actions </h2>\n                        <div className=\"Exit-Popup\" onClick={()=> this.setState({showLog: !this.state.showLog})}> \n                            <FiX/>\n                        </div>\n                        <LogTable\n                            data={actions}\n                            onClusterColorChange={this.onClusterColorChange}\n                            onClusterRowsChange={this.onClusterRowsChange}\n                            colName={\"Actions (Starting from most recent)\"}\n                        ></LogTable>\n                        <label className=\"custom-file-export\" title=\"Exports your clustering. Includes columns for copy number estimates if purity/ploidy is toggled on at export time.\">\n                            <Log logData={actions} fileName={this.state.chosenFile} onExport={this.onExport}></Log>\n                            Export <FiDownload/>\n                        </label>\n                    </div>}\n\n                {this.state.showCentroidTable && <div className=\"black_overlay\" onClick={()=> this.setState({showCentroidTable: !this.state.showCentroidTable})}></div> }\n                {this.state.showCentroidTable && \n                    <div className=\"Directions\">\n                        <h2 className=\"pop-up-window-header\"> Centroid Table </h2>\n                        <div className=\"Exit-Popup\" onClick={()=> this.setState({showCentroidTable: !this.state.showCentroidTable})}> \n                            <FiX/>\n                        </div>\n                        \n                        <ClusterTable\n                            data={indexedData.getCentroidData()}\n                            onClusterColorChange={this.onClusterColorChange}\n                            onClusterRowsChange={this.onClusterRowsChange}\n                            colors={CLUSTER_COLORS}\n                            currentFilters={[\"\"]}\n                            centroidTable={true}\n                            colOneName={\"Cluster\"}\n                            colTwoName={\"Sample\"}\n                            colThreeName={\"Centroid\"}\n                            cols={[{name: \"Cluster\", type: 'key'}, {name: \"Sample\", type: 'sample'}, {name: \"Centroid\", type: 'centroid'}]}\n                        ></ClusterTable>\n                        {visualizeMerge}\n                    </div> }\n                \n                {this.state.showSilhouettes === ProcessingStatus.done && <div className=\"black_overlay\" onClick={this.onToggleSilhoutteBarPlot}></div> }\n                {this.state.showSilhouettes === ProcessingStatus.done && \n                        <AnalyticsTab\n                            silhouetteData={this.state.silhouettes}\n                            avgClusterSilhouette={this.state.indexedData.getAvgSilhouette()}\n                            clusterDistances={this.state.indexedData.getClusterDistanceMatrix()}\n                            clusterTableData={clusterTableData}\n                            colors={CLUSTER_COLORS}\n                            onToggleSilhoutteBarPlot={this.onToggleSilhoutteBarPlot}\n                        ></AnalyticsTab>}\n                <div className=\"before-loading\">\n                    {/* Load your own data, or use the demo button to load the demo data! */}\n                </div> \n\n            </div>\n        </div>;\n    }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport { App } from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}